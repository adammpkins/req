The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encountered. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
.cursor/rules/grammar.mdc
# .cursor/rules/grammar.mdc

# req grammar - v0.1 specification

This documents the language. It is a DSL that reads like a sentence and runs in a shell.

## Command shape

    req <verb> <url> [clauses...]

Clauses are key=value pairs where keys are semantic words, not config words.

Order of clauses is free.

Unknown clause keys are errors.

## Verbs

- read - GET, print to stdout
- save - GET, write to file via to=
- send - default GET, POST if with= present
- upload - POST when attach= or with= present, else error
- watch - GET with SSE or polling
- inspect - HEAD only
- authenticate - login and store session state
- session show, session clear, session use - session management

## Clauses

| Clause     | Meaning                                     | Repeatable | Example                                                                 |
|-----------|---------------------------------------------|------------|-------------------------------------------------------------------------|
| using=    | HTTP method override                         | no         | using=PUT                                                               |
| include=  | Add headers, params, cookies                 | yes        | include='header: Authorization: Bearer token; param: q=search query'     |
| with=     | Request body                                 | no         | with=@user.json or with='{"name":"Adam"}'                               |
| expect=   | Assertions on response                       | no         | expect=status:200, header:Content-Type=application/json, contains:"ok"  |
| as=       | Output format for stdout                     | no         | as=json                                                                 |
| to=       | Destination path                             | no         | to=out.json                                                             |
| retry=    | Retry attempts for transient errors          | no         | retry=3                                                                 |
| under=    | Timeout or size limit                        | no         | under=30s or under=10MB                                                 |
| via=      | Proxy URL                                    | no         | via=http://proxy:8080                                                   |
| attach=   | Multipart parts for upload or send           | yes        | attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'    |
| follow=   | Redirect policy for write verbs              | no         | follow=smart                                                            |
| insecure= | Disable TLS verification for this request    | no         | insecure=true                                                           |

### include= value grammar

- One include clause may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - header: Name: Value
  - param: key=value
  - cookie: key=value
  - basic: username:password

Merging
- Headers: keep all values for multi valued headers, else last wins.
- Params: repeated keys become repeated pairs in insertion order.
- Cookies: last value wins per cookie name.
- Basic Auth: sets Authorization header, overrides any existing Authorization header.

Quoting
- If an item payload contains a semicolon, quote the value.
- Backslash escapes allowed inside quoted values for the quote char and backslash.

Errors
- Unknown tag before the first colon.
- Header without Name colon Value.
- Param or cookie missing equals.
- Basic item missing colon (must be username:password format).
- Unquoted semicolon inside an item payload.

Examples

    include='header: Accept: application/json, application/problem+json; q=0.9'
    include='param: q=search query; param: tag=ai; param: tag=ml'
    include='cookie: session=abc; cookie: prefs="a=1; b=2"'
    include='basic: user:pass; header: Accept: application/json'

### attach= value grammar

- One attach may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - part: name=..., file=@path  or  part: name=..., value=...
  - Optional filename=...
  - Optional type=media/type
  - boundary: TOKEN optional

Validation
- name is required.
- exactly one of file or value is required.
- for file parts, @path must exist at execution time.

Header behavior
- Any attach= forces multipart Content-Type with a generated boundary.
- If user included a manual Content-Type, override it and print a one line note.

Examples

    attach='part: name=avatar, file=@./me.png, filename=me.png, type=image/png'
    attach='part: name=meta, value={"name":"adam"}'
    attach='part: name=file, file=@./a.png; part: name=meta, value=xyz'

### with= body modes

- Inline text or JSON.
- @file to read from file.
- @- to read from stdin.

Content type
- If Content-Type is not set and inline begins with "{" or "[", infer application/json and note on stderr.
- An explicit Content-Type header always overrides inference.

### expect= assertions

Single clause with comma separated checks. All must pass.

Supported checks
- status:200
- header:Content-Type=application/json
- contains:"text"
- jsonpath:"$.items[0].id"
- matches:"^OK\\b"

Exit codes
- 0 success and expectations passed.
- 3 request ok but an expectation failed.

Failure messages must be concise and specific.

### Redirects

- read and save follow up to 5 redirects by default.
- write verbs do not follow by default.
- follow=smart for writes follows only 307 and 308, up to 5 hops.
- On 301, 302, 303 for writes, do not follow and print an advisory.

### Compression

- If user did not set Accept-Encoding, send "Accept-Encoding: gzip, br".
- Auto decompress gzip or br before as= and expect=.
- Print a one line note when decompression occurs.

### TLS

- insecure=true disables certificate verification for this request only.
- Print one line warning on stderr.

### Sessions

authenticate
- Follows redirects.
- Captures Set-Cookie.
- If response is JSON with a top level access_token, store it as a Bearer token.
- Store per host under user state dir with strict perms.

Auto use
- Any request to a host with a stored session auto applies cookies and Authorization unless caller includes those explicitly.
- Print "Using session for <host>" when applied.

session verbs
- session show <host> prints redacted info. as=json prints machine friendly form.
- session clear <host> deletes state.
- session use <host> prints env stub for shell scoping.

### Method defaults

- read GET
- save GET
- send GET by default, POST if with= present
- upload POST when attach= present, else POST if with= present, else error
- watch GET
- inspect HEAD
- authenticate POST if with= present, else require using=

### Multiplicity and ordering

- Singletons: using, with, expect, as, to, retry, under, via, insecure, follow.
- Repeatable: include, attach.
- Clause order is free.
- Explicit include of Authorization or Cookie overrides session.

### Token and quoting model

- Parser consumes argv tokens as provided by the shell.
- Do not re split on spaces.
- Values containing semicolons must be quoted.
- Backslash escapes allowed inside quotes for the quote char and backslash.
- Environment variables are expanded by the shell before argv.

### Errors that must be loud and specific

- Unknown clause key.
- Duplicate singletons.
- include item with unknown tag or malformed payload.
- header item missing Name colon Value.
- param or cookie missing equals.
- basic item missing colon (must be username:password format).
- unquoted semicolon in an item payload.
- attach part missing name, or missing both file and value, or providing both.
- URL parse failure.
- file path not found for with or attach.
- timeout or size limit exceeded.
- TLS error when insecure=false.

### Error message examples

Each error class must produce a specific, actionable message. Examples:

Unknown clause key

    $ req read https://example.com invalid=clause
    Error: parse error at position 2 (token: "invalid"): unknown clause

Duplicate singleton

    $ req read https://example.com with=test with=test2
    Error: parse error at position 3 (token: "with"): duplicate singleton clause 'with' (did you mean "remove duplicate 'with=' clause"?)

Unquoted semicolon in include

    $ req read https://example.com include='param: q=test;value'
    Error: parse error at position 2 (token: "include"): unquoted semicolon in include item

Malformed header (missing Name: Value)

    $ req read https://example.com include='header: InvalidHeader'
    Error: parse error at position 2 (token: "include"): header item missing Name: Value format

Missing equals in param or cookie

    $ req read https://example.com include='param: q'
    Error: parse error at position 2 (token: "include"): param missing equals

Basic item missing colon

    $ req read https://example.com include='basic: userpass'
    Error: parse error at position 2 (token: "include"): basic item must be in format username:password: basic: userpass

Attach part missing name

    $ req upload https://example.com attach='part: file=@test.png'
    Error: parse error at position 2 (token: "attach"): attach part missing name

Attach part with both file and value

    $ req upload https://example.com attach='part: name=test, file=@test.png, value=text'
    Error: parse error at position 2 (token: "attach"): attach part cannot have both file and value

File not found for with

    $ req send https://example.com with=@nonexistent.json
    Error: file not found: nonexistent.json

File not found for attach

    $ req upload https://example.com attach='part: name=file, file=@nonexistent.png'
    Error: file not found: nonexistent.png

### Output contracts

stdout
- Response body, formatted per as=.
- For save, write to file and keep stdout empty unless a specific mode says otherwise.

stderr
- Compact meta block: status, url, duration, bytes, content type.
- Notices: session use, decompression, redirect trace, TLS warning, multipart override note.
- Secrets redacted in meta lines.

### End to end examples

Read with params and header

    req read https://api.example.com/search \
      include='param: q=search query; header: X-Trace: 1' \
      as=json

Write JSON with auth and assertion

    req send https://api.example.com/users \
      using=POST \
      include='header: Authorization: Bearer $TOKEN' \
      with='{"name":"Adam"}' \
      expect=status:201, header:Content-Type=application/json \
      as=json

Multipart upload

    req upload https://api.example.com/upload \
      attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
      as=json

Authenticate then use session

    req authenticate https://api.example.com/login \
      using=POST \
      with='{"user":"adam","pass":"xyz"}'

    req read https://api.example.com/me as=json

Write with safe redirects

    req send https://api.example.com/endpoint \
      using=POST \
      with='{"a":1}' \
      follow=smart \
      expect=status:200

----
.cursor/rules/plan.mdc
---
alwaysApply: true
---
# /.cursor/plan.md

# req project plan - v0.1 to 90 percent curl coverage

This is a strict, test-driven plan. Each task has acceptance criteria. No code here. Use these goals as Cursor prompts.

## 1) Lock the surface grammar
- Enforce command shape: `req <verb> <url> [clauses...]`
- Allowed verbs: read, save, send, upload, watch, inspect, authenticate, session (show|clear|use)
- Allowed clauses: using=, include=, with=, expect=, as=, to=, retry=, under=, via=, attach=, follow=smart, insecure=true
- Clause order independent

Acceptance
- Unknown clause keys hard error with nearest suggestion
- Duplicate singletons hard error with fix hint
- Golden tests for valid and invalid examples
- `req help` prints the grammar summary

## 2) include= value grammar
Goal
- Implement semicolon separated items with explicit tags

Do
- Items: `header: Name: Value`, `param: key=value`, `cookie: key=value`
- Values may be quoted
- Multiple include= clauses allowed

Merging rules
- Headers: keep all for multi valued headers, else last wins
- Params: repeated keys become repeated pairs in order
- Cookies: last value wins

Acceptance
- Unit tests for quoting, embedded semicolons, repeated keys, error cases
- Golden tests for combined include payloads

## 3) attach= multipart grammar
Goal
- Repeatable clause for multipart form data

Do
- Items: `part: ...` and `boundary: ...`
- Part kvs: `name=`, one of `file=@path` or `value=`, optional `filename=`, optional `type=media/type`
- Validate name required, exactly one of file or value
- Any attach= forces `Content-Type: multipart/form-data; boundary=...`
- If user set Content-Type manually, override and print a one line note

Acceptance
- Unit tests for file, text, mixed parts, explicit boundary, malformed descriptors
- Integration test uses echo server to assert parts

## 4) follow=smart and insecure=true
Goal
- Add redirect and TLS toggles

Do
- follow accepts only `smart`
- insecure accepts `true` or `false`

Acceptance
- Unit tests parse both correctly and reject bad values

## 5) with= body modes and light inference
Goal
- Support inline, @file, @-

Do
- If Content-Type is not set and inline begins with `{` or `[`, infer `application/json` and log a one line note on stderr
- Explicit header always overrides inference

Acceptance
- Tests for inference, override, and no inference on file

## 6) expect= assertions
Goal
- Single clause with comma separated checks

Checks
- `status:200`
- `header:Content-Type=application/json`
- `contains:"text"`
- `jsonpath:"$.items[0].id"`
- `matches:"^OK\\b"`

Acceptance
- Exit 3 on any failure, with a concise diff-like message
- Tests for pass and fail cases

## 7) Verb defaults and method validation
Goal
- Map verbs to default methods and validate using=

Defaults
- read GET
- save GET
- send GET by default, POST if with= present
- upload POST if attach= or with= present, else error
- watch GET
- inspect HEAD
- authenticate default POST if with= present

Acceptance
- Tests for defaults and invalid combinations

## 8) Redirect policy
Goal
- Implement safe redirect rules

Rules
- read and save follow up to 5 by default
- write verbs do not follow by default
- follow=smart follows only 307 and 308 for writes, up to 5
- On 301, 302, 303 for writes, do not follow, print advisory

Acceptance
- Integration tests for 301, 302, 303, 307, 308 with and without smart
- Stderr shows compact trace

## 9) Transparent compression
Goal
- gzip and br on by default

Do
- Inject Accept-Encoding unless user set it
- Auto decompress before as= and expect=
- One line stderr note when decompressed

Acceptance
- gz and br tests, expect sees decoded text, user header respected

## 10) TLS control
Goal
- Implement insecure=true

Acceptance
- Self signed server fails normally, succeeds with insecure=true
- One line stderr warning: TLS verification disabled

## 11) Query param merging and URL assembly
Goal
- Merge URL params with include param items

Acceptance
- Repeated keys serialize in insertion order
- Proper percent encoding
- Existing URL params preserved and merged

## 12) Output control with as= and to=
Goal
- Finalize sinks and formatting

Do
- as=json, text, raw, csv
- to=PATH writes file. For save, derive filename from URL if needed
- stdout is body, stderr is compact meta with redaction

Acceptance
- Filename extraction, directory handling, percent decoding, meta block content

## 13) Sessions and authenticate
Goal
- Explicit session model

Do
- authenticate captures Set-Cookie and `access_token` from JSON
- Store per host in user state dir with strict perms
- Auto apply for matching host unless caller includes Authorization or Cookie
- Print `Using session for <host>` on use
- session show, session clear, session use implemented

Acceptance
- Integration tests for login, reuse, override, redaction, permission refusal

## 14) Multipart body construction
Goal
- Build body with generated boundary and proper part headers

Acceptance
- Echo server validates Content-Disposition, Content-Type, filenames and order
- Manual Content-Type overridden with a note

## 15) Errors, hints, exit codes
Goal
- Clear, specific failures

Acceptance
- Exit codes: 0 ok, 3 expect fail, 4 network, 5 grammar
- Hints for unquoted semicolons, missing equals, duplicate singletons, unknown clause, bad attach part

## 16) Help and explain
Goal
- Discoverability tools

Do
- `req help` prints grammar table and examples
- `req explain "<command>"` prints parsed plan without executing

Acceptance
- Golden tests for explain output

## 17) Cross shell quoting doc
Goal
- Portability guidance

Do
- Quoting cheat sheet for bash, zsh, fish, PowerShell
- Curl vs req mapping table for common tasks

Acceptance
- Docs included and examples parse in a simple parser smoke test

## 18) CI, golden, fixtures
Goal
- Stable test harness

Do
- Golden tests for parser and explain
- Local HTTP fixture: echo headers, cookies, query, gzip, br, 30x, multipart
- Run under race detector

Acceptance
- CI green across Go versions you support

## 19) Streaming and watch polish
Goal
- Memory efficient downloads and sensible watch output

Do
- Stream to file for save
- Watch prints timestamps on TTY, raw otherwise

Acceptance
- Large download uses low memory
- Watch behaves per TTY detection

## 20) README refresh
Goal
- Align docs with grammar

Do
- Replace stale examples with include, attach, expect forms
- Document redirect defaults and smart policy
- Add warning about insecure=true and shell history

Acceptance
- Doc snippets pass as golden examples

----
.github/ISSUE_TEMPLATE/bug_report.md
---
name: Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Description

A clear and concise description of what the bug is.

## Reproduction

**Command:**
```bash
req <your-command-here>
```

**Expected Output:**
```
<expected-output>
```

**Actual Output:**
```
<actual-output>
```

## Environment

- OS: [e.g., Linux, macOS, Windows]
- Architecture: [e.g., amd64, arm64]
- Version: [e.g., v0.1.0]
- Go version: [e.g., 1.24]

## Additional Context

Add any other context about the problem here, including:
- Error messages
- Stack traces (if applicable)
- Workarounds you've tried


----
.github/ISSUE_TEMPLATE/feature_request.md
---
name: Feature Request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Summary

A clear and concise description of the feature you'd like to see.

## Motivation

Why is this feature needed? What problem does it solve?

## Detailed Description

Describe the feature in detail:
- What should the command syntax look like?
- What should the output look like?
- Are there any edge cases to consider?

## Example Usage

```bash
req <example-command>
```

## Alternatives Considered

Describe any alternative solutions or features you've considered.

## Additional Context

Add any other context, mockups, or examples about the feature request here.


----
.github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Run tests with race detector
        run: make test
      
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          make vulncheck
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m
  
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-${{ matrix.os }}
          path: bin/req
  
  windows:
    name: Windows Build
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-windows
          path: bin/req.exe

  grammar-drift:
    name: Grammar Drift Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build binary
        run: make build
      
      - name: Run grammar drift tests
        run: go test -v ./tests -run 'TestGrammarDrift|TestBinaryHelpDrift'


----
.gitignore
# Binaries
bin/
req
req.exe

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
*.tar.gz
*.zip


----
.golangci.yml
# golangci-lint configuration with lean modern linter set
run:
  timeout: 5m
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  gocritic:
    enabled-tags:
      - diagnostic
  govet:
    check-shadowing: true
  misspell:
    locale: US
  nolintlint:
    allow-leading-space: true
    allow-unused: false
    require-explanation: false
    require-specific: false

linters:
  disable-all: true
  enable:
    - errcheck
    - gocritic
    - goimports
    - gosimple
    - govet
    - ineffassign
    - misspell
    - nolintlint
    - staticcheck

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
  max-issues-per-linter: 0
  max-same-issues: 0

----
.goreleaser.yml
# GoReleaser configuration for cross-platform releases
project_name: req

before:
  hooks:
    - go mod download

builds:
  - id: req
    main: ./cmd/req
    binary: req
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    goarm:
      - 6
      - 7
    ignore:
      - goos: windows
        goarch: arm64
    env:
      - CGO_ENABLED=0
    flags:
      - -trimpath
      - -ldflags=-s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.buildDate={{.Date}}

archives:
  - id: default
    builds:
      - req
    format_overrides:
      - goos: windows
        format: zip
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    files:
      - LICENSE
      - README.md

checksum:
  name_template: "{{ .ProjectName }}_{{ .Version }}_checksums.txt"

snapshot:
  name_template: "{{ .Tag }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"


----
LICENSE
MIT License

Copyright (c) 2025 Adam Perkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


----
Makefile
.PHONY: build test lint package golden clean help

# Variables
BINARY_NAME=req
MAIN_PATH=./cmd/req
VERSION?=dev
BUILD_DIR=./bin
COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build the req binary
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
ifeq ($(GOOS),windows)
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME).exe $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME).exe"
else
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"
endif

test: ## Run tests with race detector
	@echo "Running tests..."
	@go test -race -cover -v ./...

test-golden: ## Run golden file tests
	@echo "Running golden tests..."
	@go test -v ./tests -run TestGolden

golden: ## Regenerate golden test files
	@echo "Regenerating golden files..."
	@go test ./tests -run TestGolden -update

lint: ## Run golangci-lint
	@echo "Running golangci-lint..."
	@golangci-lint run

lint-fix: ## Run golangci-lint with auto-fix
	@golangci-lint run --fix

vulncheck: ## Run govulncheck
	@echo "Running govulncheck..."
	@govulncheck ./...

package: ## Build release artifacts locally (requires goreleaser)
	@echo "Building release artifacts..."
	@goreleaser build --snapshot --clean

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@go clean -cache

install: build ## Install binary to GOPATH/bin
	@go install $(MAIN_PATH)


----
README.md
# req

A semantic HTTP client written in Go that replaces traditional curl syntax with a natural, intent-based grammar.

## Overview

`req` is an HTTP client tool that focuses on:

- **Human-readable commands** (verbs + clauses)
- **Sensible defaults** (follow redirects, TLS verify, retries)
- **JSON/CSV/text awareness** with intelligent output
- **Watch mode** (poll or stream)
- **Session management** (authenticate and auto-apply)
- **Pretty diagnostics** and dry-run transparency

## Quick Start

```bash
# Read JSON from an API
req read https://api.example.com/users as=json

# Send JSON data
req send https://api.example.com/users with='{"name":"Adam"}'

# Send with headers and assertions
req send https://api.example.com/users \
  using=POST \
  include='header: Authorization: Bearer $TOKEN' \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json \
  as=json

# Save a file
req save https://example.com/file.zip to=file.zip

# Upload multipart form data
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png' \
  as=json

# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Use stored session automatically
req read https://api.example.com/me as=json
```

## Installation

```bash
go install github.com/adammpkins/req/cmd/req@latest
```

Or download a pre-built binary from the [Releases](https://github.com/adammpkins/req/releases) page.

## Grammar

The `req` command follows this grammar:

```
req <verb> <target> [clauses...]
```

### Verbs

- `read` - GET, print to stdout
- `save` - GET, write to file via to=
- `send` - default GET, POST if `with=` is present
- `upload` - POST when `attach=` or `with=` present, else error
- `watch` - GET with SSE or polling
- `inspect` - HEAD only
- `authenticate` - login and store session state
- `session` - session management (show, clear, use)

### Clauses

- `using=<method>` - HTTP method override
- `include=<items>` - Add headers, params, cookies (repeatable)
  - Format: `include='header: Name: Value; param: key=value; cookie: key=value'`
- `with=<body>` - Request body
  - Format: `with=@user.json` or `with='{"name":"Adam"}'`
  - JSON inference: Automatically sets Content-Type for JSON when inline starts with `{` or `[`
- `expect=<checks>` - Assertions on response
  - Format: `expect=status:200, header:Content-Type=application/json, contains:"ok"`
- `as=<format>` - Output format for stdout
- `to=<path>` - Destination path
- `retry=<count>` - Retry attempts for transient errors
- `under=<limit>` - Timeout or size limit
  - Format: `under=30s` or `under=10MB`
- `via=<url>` - Proxy URL
- `attach=<parts>` - Multipart parts for upload or send (repeatable)
  - Format: `attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'`
- `follow=<policy>` - Redirect policy for write verbs
  - Format: `follow=smart`
- `insecure=<bool>` - Disable TLS verification for this request
  - Format: `insecure=true`

## Examples

### Read JSON

```bash
req read https://api.example.com/users as=json
```

### Send JSON Data

```bash
req send https://api.example.com/users with='{"name":"Ada","email":"ada@example.com"}'
```

### Save a File

```bash
# Save with explicit filename
req save https://example.com/file.zip to=file.zip

# Save with auto-detected filename (extracts from URL)
req save https://example.com/file.zip

# Save to directory path
req save https://example.com/file.zip to=/tmp/file.zip
```

### With Headers, Params, and Cookies

```bash
# Using include clause
req read https://api.example.com/search \
  include='header: Authorization: Bearer $TOKEN; param: q=search query; cookie: session=abc123' \
  as=json
```

### With Assertions

```bash
req send https://api.example.com/users \
  using=POST \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json, contains:"id" \
  as=json
```

### Sessions

```bash
# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Session is automatically used for subsequent requests
req read https://api.example.com/me as=json

# Show stored session (redacted)
req session show api.example.com

# Show session in JSON format
req session show api.example.com as=json

# Clear session
req session clear api.example.com
```

### Redirects

```bash
# Read and save follow redirects by default (up to 5)
req read https://example.com/redirect

# Write verbs don't follow by default
req send https://api.example.com/create using=POST with='{"data":"value"}'

# Use smart follow for write verbs (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
```

### With Retry and Timeout

```bash
req read https://api.example.com/users retry=3 under=10s as=json
```

### Edge Cases

```bash
# Header with commas and q values (must be quoted)
req read https://api.example.com/search \
  include='header: Accept: application/json, application/problem+json; q=0.9' \
  as=json

# Cookie value containing semicolons (must be quoted)
req read https://api.example.com/search \
  include='cookie: prefs="a=1; b=2; c=3"' \
  as=json

# Multipart upload with file and text parts (Content-Type automatically overridden)
req upload https://api.example.com/upload \
  include='header: Content-Type: application/json' \
  attach='part: name=file, file=@avatar.png; part: name=meta, value={"name":"test"}' \
  as=json
# Note: Content-Type will be overridden to multipart/form-data

# Smart redirect on write verb (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
# Will follow 307/308 redirects, but not 301/302/303

# Write verb with 303 redirect (advisory printed, not followed)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}'
# If server returns 303, advisory message printed but redirect not followed
```

### Method Override

```bash
# Use PUT instead of POST
req send https://api.example.com/users/1 using=PUT with='{"name":"Updated"}'

# Use PATCH for partial updates
req send https://api.example.com/users/1 using=PATCH with='{"email":"new@example.com"}'

# Use HEAD to check headers without body
req read https://api.example.com/users using=HEAD
```

**Note:** The `using=` clause validates method-verb compatibility. For example, `read using=POST` will fail as `read` only allows GET, HEAD, or OPTIONS.

### Comparison with curl

| Task | curl | req |
|------|------|-----|
| **Basic GET with headers** | `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include='header: Authorization: Bearer $TOKEN'` |
| **Multipart upload** | `curl -F "file=@avatar.png" -F "name=test" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png; part: name=name, value=test'` |
| **Authenticated POST** | `curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users using=POST include='header: Authorization: Bearer $TOKEN' with='{"name":"Adam"}'` |

### Dry Run

```bash
req read https://api.example.com/users as=json --dry-run
```

### Interactive TUI Mode

```bash
# Launch interactive TUI mode
req --tui

# Or run without arguments to launch TUI
req
```

The TUI mode provides:
- Interactive command builder with form-based input
- **Syntax-highlighted JSON output** with color-coded keys, values, and punctuation
- **Scrollable viewport** for long responses with keyboard navigation
- Pretty-printed JSON with automatic indentation
- Real-time command execution and response display

**Keyboard Controls:**
- `↑` / `↓` or `k` / `j` - Scroll line by line
- `pgup` / `pgdown` - Page scrolling
- `home` - Jump to top
- `end` - Jump to bottom
- `ctrl+u` / `ctrl+d` - Half-page scrolling
- `esc` - Quit TUI

## Security

### Shell History

**Warning:** Commands containing secrets (tokens, passwords) are stored in your shell history by default. Use environment variables to avoid exposing secrets:

```bash
# Bad: Token appears in shell history
req read https://api.example.com/users include='header: Authorization: Bearer secret-token-123'

# Good: Use environment variable
TOKEN="secret-token-123"
req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"
```

To prevent secrets from being saved to history:
- **Bash/Zsh:** Prefix command with a space (requires `HISTCONTROL=ignorespace` or `setopt HIST_IGNORE_SPACE`)
- **Fish:** Use `history --delete` after running commands with secrets
- **PowerShell:** Use `Set-PSReadlineOption -HistoryNoDuplicates` and manually edit history

### Session Files

Session files are stored in `~/.config/req/session_<host>.json` with permissions `0600` (owner read/write only).

**Security rules:**
- Session files are created with strict permissions (`0600`)
- If a session file has group or world readable permissions, `req` will refuse to load it
- Session files contain sensitive data (cookies, tokens) and should be protected
- Never commit session files to version control

To check session file permissions:
```bash
ls -l ~/.config/req/session_*.json
```

## Current Status

**v0.1** - Core functionality complete

- ✅ Command parsing with full grammar validation
- ✅ All clauses implemented (include, attach, expect, follow, insecure, etc.)
- ✅ Execution plan generation with verb defaults
- ✅ HTTP request execution with redirect handling
- ✅ Transparent compression (gzip, br)
- ✅ Session management (authenticate, session show/clear/use)
- ✅ Auto-apply sessions for matching hosts
- ✅ File downloads with automatic filename extraction
- ✅ Multipart form data support
- ✅ Response assertions (expect clause)
- ✅ Proper exit codes (0 success, 3 expect fail, 4 network, 5 grammar)
- ✅ Helpful error messages with suggestions
- ✅ Help and explain commands
- ✅ Interactive TUI mode
- ✅ JSON output formatting
- ✅ Stderr meta output with redaction

## Roadmap

- **v0.1** ✅ - Core functionality (current)
- **v0.2** - Watch mode with SSE and polling
- **v0.3** - JSONPath selection and filtering
- **v0.4** - Advanced retry and backoff strategies
- **v1.0** - Stability hardening and release candidates

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

MIT License - see [LICENSE](LICENSE) file for details.


----
cmd/req/main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/adammpkins/req/internal/grammar"
	"github.com/adammpkins/req/internal/output"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
	"github.com/adammpkins/req/internal/tui"
	"github.com/adammpkins/req/internal/types"
)

var (
	version   = "dev"
	commit    = "unknown"
	buildDate = "unknown"
)

func main() {
	var (
		showHelp    = flag.Bool("help", false, "Show help message")
		showVersion = flag.Bool("version", false, "Show version information")
		dryRun      = flag.Bool("dry-run", false, "Print execution plan without executing")
		tuiMode     = flag.Bool("tui", false, "Launch interactive TUI mode")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: req <verb> <target> [clauses...]\n\n")
		fmt.Fprintf(os.Stderr, "Verbs: read, save, send, upload, watch, inspect, authenticate, session\n\n")
		fmt.Fprintf(os.Stderr, "Examples:\n")
		fmt.Fprintf(os.Stderr, "  req read https://api.example.com/users as=json\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users using=PUT with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req save https://example.com/file.zip to=file.zip\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showHelp {
		flag.Usage()
		os.Exit(0)
	}

	if *showVersion {
		fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
		os.Exit(0)
	}

	// Launch TUI mode if requested
	if *tuiMode {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Get remaining args after flags
	args := flag.Args()

	// Remove any remaining flags from args (in case they appear after command args)
	filteredArgs := make([]string, 0, len(args))
	for _, arg := range args {
		if arg == "--help" || arg == "-help" || arg == "-h" {
			flag.Usage()
			os.Exit(0)
		}
		if arg == "--version" || arg == "-version" || arg == "-v" {
			fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
			os.Exit(0)
		}
		if arg == "--dry-run" || arg == "-dry-run" {
			*dryRun = true
			continue
		}
		filteredArgs = append(filteredArgs, arg)
	}
	args = filteredArgs

	// If no args provided, launch TUI mode
	if len(args) == 0 {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Handle help command
	if len(args) > 0 && args[0] == "help" {
		printHelp()
		os.Exit(0)
	}

	// Handle explain command
	if len(args) > 0 && args[0] == "explain" {
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Usage: req explain \"<command>\"\n")
			os.Exit(5)
		}
		command := strings.Join(args[1:], " ")
		if err := explainCommand(command); err != nil {
			printError(err)
			os.Exit(5)
		}
		os.Exit(0)
	}

	// Join args into a single command string
	command := strings.Join(args, " ")

	// Parse the command
	cmd, err := parser.Parse(command)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar error
	}

	// Handle session commands specially
	if cmd.Verb == types.VerbSession {
		if err := handleSessionCommand(cmd); err != nil {
			printError(err)
			os.Exit(5)
		}
		return
	}

	// Plan the execution
	plan, err := planner.Plan(cmd)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar/planning error
	}

	// Output the plan (dry-run mode)
	if *dryRun {
		formatted, err := output.FormatPlan(plan)
		if err != nil {
			printError(fmt.Errorf("failed to format plan: %w", err))
			os.Exit(5)
		}
		fmt.Println(string(formatted))
		return
	}

	// Execute the plan
	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		printError(fmt.Errorf("failed to create executor: %w", err))
		os.Exit(5) // Grammar error
	}

	if err := executor.Execute(plan); err != nil {
		printError(err)
		// Check error type for exit code
		if execErr, ok := err.(*runtime.ExecutionError); ok {
			os.Exit(execErr.Code)
		}
		os.Exit(4) // Network error (default)
	}
}

// printError prints an error with helpful diagnostics.
func printError(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v\n", err)

	// Check if it's a ParseError with suggestions
	if parseErr, ok := err.(*parser.ParseError); ok && parseErr.Suggest != "" {
		fmt.Fprintf(os.Stderr, "Hint: Try using '%s' instead\n", parseErr.Suggest)
	}
}

// printHelp prints the grammar summary.
func printHelp() {
	fmt.Print(grammar.FormatHelp())
}

// explainCommand prints the parsed plan for a command without executing it.
func explainCommand(command string) error {
	cmd, err := parser.Parse(command)
	if err != nil {
		return err
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		return err
	}

	formatted, err := output.FormatPlan(plan)
	if err != nil {
		return fmt.Errorf("failed to format plan: %w", err)
	}

	fmt.Println(string(formatted))
	return nil
}

// handleSessionCommand handles session management commands.
func handleSessionCommand(cmd *types.Command) error {
	host, err := session.ExtractHost(cmd.Target.URL)
	if err != nil {
		return fmt.Errorf("invalid host: %w", err)
	}

	switch cmd.SessionSubcommand {
	case "show":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			fmt.Printf("No session found for %s\n", host)
			return nil
		}

		// Check if JSON output requested
		asJSON := false
		for _, clause := range cmd.Clauses {
			if asClause, ok := clause.(types.AsClause); ok && asClause.Format == "json" {
				asJSON = true
				break
			}
		}

		if asJSON {
			// Machine-friendly JSON output
			data, err := json.MarshalIndent(sess, "", "  ")
			if err != nil {
				return fmt.Errorf("failed to marshal session: %w", err)
			}
			fmt.Println(string(data))
		} else {
			// Human-readable redacted output
			redacted := session.RedactSession(sess)
			fmt.Printf("Session for %s:\n", redacted.Host)
			if len(redacted.Cookies) > 0 {
				fmt.Println("Cookies:")
				for name := range redacted.Cookies {
					fmt.Printf("  %s: ***\n", name)
				}
			}
			if redacted.Authorization != "" {
				fmt.Printf("Authorization: %s\n", redacted.Authorization)
			}
		}
		return nil

	case "clear":
		if err := session.DeleteSession(host); err != nil {
			return fmt.Errorf("failed to delete session: %w", err)
		}
		fmt.Printf("Session cleared for %s\n", host)
		return nil

	case "use":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			return fmt.Errorf("no session found for %s", host)
		}
		// Print environment variable stub for shell scoping
		fmt.Printf("export REQ_SESSION_HOST=%s\n", host)
		return nil

	default:
		return fmt.Errorf("unknown session subcommand: %s", cmd.SessionSubcommand)
	}
}

----
docs/QUOTING.md
# Cross Shell Quoting Guide

This guide provides examples of how to properly quote `req` commands in different shells.

## General Rules

- Values containing semicolons (`;`) must be quoted
- Values containing spaces should be quoted
- Values containing special characters should be quoted
- Environment variables are expanded by the shell before being passed to `req`

## Bash / Zsh

### Single Quotes (Recommended)
Single quotes preserve everything literally:

```bash
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

### Double Quotes
Double quotes allow variable expansion:

```bash
TOKEN="abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

### Escaping
Use backslash to escape special characters:

```bash
req read https://api.example.com/search include='param: q=test\;value' as=json
```

## Fish Shell

Fish uses different quoting rules:

```fish
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in fish:

```fish
set TOKEN "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## PowerShell

PowerShell uses backticks for escaping:

```powershell
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in PowerShell:

```powershell
$TOKEN = "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## Common Patterns

### Include Clause with Multiple Items

```bash
# Bash/Zsh
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# Fish
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# PowerShell
req read https://api.example.com/search `
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' `
  as=json
```

### Expect Clause with Multiple Checks

```bash
req read https://api.example.com/users \
  expect='status:200, header:Content-Type=application/json, contains:"items"' \
  as=json
```

### Attach Clause with File Paths

```bash
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
  as=json
```

## Curl vs req Mapping

| curl command | req equivalent |
|-------------|----------------|
| `curl https://api.example.com/users` | `req read https://api.example.com/users` |
| `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"` |
| `curl -X POST -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users with='{"name":"Adam"}'` |
| `curl -X POST -F "file=@avatar.png" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png'` |
| `curl -b "session=abc123" https://api.example.com/users` | `req read https://api.example.com/users include='cookie: session=abc123'` |
| `curl -L https://example.com` | `req read https://example.com` (follows redirects by default) |
| `curl -k https://self-signed.example.com` | `req read https://self-signed.example.com insecure=true` |
| `curl --proxy http://proxy:8080 https://api.example.com` | `req read https://api.example.com via=http://proxy:8080` |
| `curl -X POST --data-binary @file.json https://api.example.com` | `req send https://api.example.com with=@file.json` |
| `curl -X POST --data @- https://api.example.com` | `echo '{"data":"value"}' \| req send https://api.example.com with=@-` |

## Tips

1. **Always quote include= values** - They often contain semicolons and spaces
2. **Use single quotes for JSON** - Prevents shell from interpreting special characters
3. **Use double quotes when you need variable expansion** - But be careful with nested quotes
4. **Test with `req explain`** - See how your command is parsed before executing:
   ```bash
   req explain "read https://api.example.com/users include='header: Authorization: Bearer token'"
   ```


----
final-attempt.txt
The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encountered. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
.cursor/rules/grammar.mdc
# .cursor/rules/grammar.mdc

# req grammar - v0.1 specification

This documents the language. It is a DSL that reads like a sentence and runs in a shell.

## Command shape

    req <verb> <url> [clauses...]

Clauses are key=value pairs where keys are semantic words, not config words.

Order of clauses is free.

Unknown clause keys are errors.

## Verbs

- read - GET, print to stdout
- save - GET, write to file via to=
- send - default GET, POST if with= present
- upload - POST when attach= or with= present, else error
- watch - GET with SSE or polling
- inspect - HEAD only
- authenticate - login and store session state
- session show, session clear, session use - session management

## Clauses

| Clause     | Meaning                                     | Repeatable | Example                                                                 |
|-----------|---------------------------------------------|------------|-------------------------------------------------------------------------|
| using=    | HTTP method override                         | no         | using=PUT                                                               |
| include=  | Add headers, params, cookies                 | yes        | include='header: Authorization: Bearer token; param: q=search query'     |
| with=     | Request body                                 | no         | with=@user.json or with='{"name":"Adam"}'                               |
| expect=   | Assertions on response                       | no         | expect=status:200, header:Content-Type=application/json, contains:"ok"  |
| as=       | Output format for stdout                     | no         | as=json                                                                 |
| to=       | Destination path                             | no         | to=out.json                                                             |
| retry=    | Retry attempts for transient errors          | no         | retry=3                                                                 |
| under=    | Timeout or size limit                        | no         | under=30s or under=10MB                                                 |
| via=      | Proxy URL                                    | no         | via=http://proxy:8080                                                   |
| attach=   | Multipart parts for upload or send           | yes        | attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'    |
| follow=   | Redirect policy for write verbs              | no         | follow=smart                                                            |
| insecure= | Disable TLS verification for this request    | no         | insecure=true                                                           |

### include= value grammar

- One include clause may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - header: Name: Value
  - param: key=value
  - cookie: key=value

Merging
- Headers: keep all values for multi valued headers, else last wins.
- Params: repeated keys become repeated pairs in insertion order.
- Cookies: last value wins per cookie name.

Quoting
- If an item payload contains a semicolon, quote the value.
- Backslash escapes allowed inside quoted values for the quote char and backslash.

Errors
- Unknown tag before the first colon.
- Header without Name colon Value.
- Param or cookie missing equals.
- Unquoted semicolon inside an item payload.

Examples

    include='header: Accept: application/json, application/problem+json; q=0.9'
    include='param: q=search query; param: tag=ai; param: tag=ml'
    include='cookie: session=abc; cookie: prefs="a=1; b=2"'

### attach= value grammar

- One attach may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - part: name=..., file=@path  or  part: name=..., value=...
  - Optional filename=...
  - Optional type=media/type
  - boundary: TOKEN optional

Validation
- name is required.
- exactly one of file or value is required.
- for file parts, @path must exist at execution time.

Header behavior
- Any attach= forces multipart Content-Type with a generated boundary.
- If user included a manual Content-Type, override it and print a one line note.

Examples

    attach='part: name=avatar, file=@./me.png, filename=me.png, type=image/png'
    attach='part: name=meta, value={"name":"adam"}'
    attach='part: name=file, file=@./a.png; part: name=meta, value=xyz'

### with= body modes

- Inline text or JSON.
- @file to read from file.
- @- to read from stdin.

Content type
- If Content-Type is not set and inline begins with "{" or "[", infer application/json and note on stderr.
- An explicit Content-Type header always overrides inference.

### expect= assertions

Single clause with comma separated checks. All must pass.

Supported checks
- status:200
- header:Content-Type=application/json
- contains:"text"
- jsonpath:"$.items[0].id"
- matches:"^OK\\b"

Exit codes
- 0 success and expectations passed.
- 3 request ok but an expectation failed.

Failure messages must be concise and specific.

### Redirects

- read and save follow up to 5 redirects by default.
- write verbs do not follow by default.
- follow=smart for writes follows only 307 and 308, up to 5 hops.
- On 301, 302, 303 for writes, do not follow and print an advisory.

### Compression

- If user did not set Accept-Encoding, send "Accept-Encoding: gzip, br".
- Auto decompress gzip or br before as= and expect=.
- Print a one line note when decompression occurs.

### TLS

- insecure=true disables certificate verification for this request only.
- Print one line warning on stderr.

### Sessions

authenticate
- Follows redirects.
- Captures Set-Cookie.
- If response is JSON with a top level access_token, store it as a Bearer token.
- Store per host under user state dir with strict perms.

Auto use
- Any request to a host with a stored session auto applies cookies and Authorization unless caller includes those explicitly.
- Print "Using session for <host>" when applied.

session verbs
- session show <host> prints redacted info. as=json prints machine friendly form.
- session clear <host> deletes state.
- session use <host> prints env stub for shell scoping.

### Method defaults

- read GET
- save GET
- send GET by default, POST if with= present
- upload POST when attach= present, else POST if with= present, else error
- watch GET
- inspect HEAD
- authenticate POST if with= present, else require using=

### Multiplicity and ordering

- Singletons: using, with, expect, as, to, retry, under, via, insecure, follow.
- Repeatable: include, attach.
- Clause order is free.
- Explicit include of Authorization or Cookie overrides session.

### Token and quoting model

- Parser consumes argv tokens as provided by the shell.
- Do not re split on spaces.
- Values containing semicolons must be quoted.
- Backslash escapes allowed inside quotes for the quote char and backslash.
- Environment variables are expanded by the shell before argv.

### Errors that must be loud and specific

- Unknown clause key.
- Duplicate singletons.
- include item with unknown tag or malformed payload.
- header item missing Name colon Value.
- param or cookie missing equals.
- unquoted semicolon in an item payload.
- attach part missing name, or missing both file and value, or providing both.
- URL parse failure.
- file path not found for with or attach.
- timeout or size limit exceeded.
- TLS error when insecure=false.

### Error message examples

Each error class must produce a specific, actionable message. Examples:

Unknown clause key

    $ req read https://example.com invalid=clause
    Error: parse error at position 2 (token: "invalid"): unknown clause

Duplicate singleton

    $ req read https://example.com with=test with=test2
    Error: parse error at position 3 (token: "with"): duplicate singleton clause 'with' (did you mean "remove duplicate 'with=' clause"?)

Unquoted semicolon in include

    $ req read https://example.com include='param: q=test;value'
    Error: parse error at position 2 (token: "include"): unquoted semicolon in include item

Malformed header (missing Name: Value)

    $ req read https://example.com include='header: InvalidHeader'
    Error: parse error at position 2 (token: "include"): header item missing Name: Value format

Missing equals in param or cookie

    $ req read https://example.com include='param: q'
    Error: parse error at position 2 (token: "include"): param missing equals

Attach part missing name

    $ req upload https://example.com attach='part: file=@test.png'
    Error: parse error at position 2 (token: "attach"): attach part missing name

Attach part with both file and value

    $ req upload https://example.com attach='part: name=test, file=@test.png, value=text'
    Error: parse error at position 2 (token: "attach"): attach part cannot have both file and value

File not found for with

    $ req send https://example.com with=@nonexistent.json
    Error: file not found: nonexistent.json

File not found for attach

    $ req upload https://example.com attach='part: name=file, file=@nonexistent.png'
    Error: file not found: nonexistent.png

### Output contracts

stdout
- Response body, formatted per as=.
- For save, write to file and keep stdout empty unless a specific mode says otherwise.

stderr
- Compact meta block: status, url, duration, bytes, content type.
- Notices: session use, decompression, redirect trace, TLS warning, multipart override note.
- Secrets redacted in meta lines.

### End to end examples

Read with params and header

    req read https://api.example.com/search \
      include='param: q=search query; header: X-Trace: 1' \
      as=json

Write JSON with auth and assertion

    req send https://api.example.com/users \
      using=POST \
      include='header: Authorization: Bearer $TOKEN' \
      with='{"name":"Adam"}' \
      expect=status:201, header:Content-Type=application/json \
      as=json

Multipart upload

    req upload https://api.example.com/upload \
      attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
      as=json

Authenticate then use session

    req authenticate https://api.example.com/login \
      using=POST \
      with='{"user":"adam","pass":"xyz"}'

    req read https://api.example.com/me as=json

Write with safe redirects

    req send https://api.example.com/endpoint \
      using=POST \
      with='{"a":1}' \
      follow=smart \
      expect=status:200

----
.cursor/rules/plan.mdc
---
alwaysApply: true
---
# /.cursor/plan.md

# req project plan - v0.1 to 90 percent curl coverage

This is a strict, test-driven plan. Each task has acceptance criteria. No code here. Use these goals as Cursor prompts.

## 1) Lock the surface grammar
- Enforce command shape: `req <verb> <url> [clauses...]`
- Allowed verbs: read, save, send, upload, watch, inspect, authenticate, session (show|clear|use)
- Allowed clauses: using=, include=, with=, expect=, as=, to=, retry=, under=, via=, attach=, follow=smart, insecure=true
- Clause order independent

Acceptance
- Unknown clause keys hard error with nearest suggestion
- Duplicate singletons hard error with fix hint
- Golden tests for valid and invalid examples
- `req help` prints the grammar summary

## 2) include= value grammar
Goal
- Implement semicolon separated items with explicit tags

Do
- Items: `header: Name: Value`, `param: key=value`, `cookie: key=value`
- Values may be quoted
- Multiple include= clauses allowed

Merging rules
- Headers: keep all for multi valued headers, else last wins
- Params: repeated keys become repeated pairs in order
- Cookies: last value wins

Acceptance
- Unit tests for quoting, embedded semicolons, repeated keys, error cases
- Golden tests for combined include payloads

## 3) attach= multipart grammar
Goal
- Repeatable clause for multipart form data

Do
- Items: `part: ...` and `boundary: ...`
- Part kvs: `name=`, one of `file=@path` or `value=`, optional `filename=`, optional `type=media/type`
- Validate name required, exactly one of file or value
- Any attach= forces `Content-Type: multipart/form-data; boundary=...`
- If user set Content-Type manually, override and print a one line note

Acceptance
- Unit tests for file, text, mixed parts, explicit boundary, malformed descriptors
- Integration test uses echo server to assert parts

## 4) follow=smart and insecure=true
Goal
- Add redirect and TLS toggles

Do
- follow accepts only `smart`
- insecure accepts `true` or `false`

Acceptance
- Unit tests parse both correctly and reject bad values

## 5) with= body modes and light inference
Goal
- Support inline, @file, @-

Do
- If Content-Type is not set and inline begins with `{` or `[`, infer `application/json` and log a one line note on stderr
- Explicit header always overrides inference

Acceptance
- Tests for inference, override, and no inference on file

## 6) expect= assertions
Goal
- Single clause with comma separated checks

Checks
- `status:200`
- `header:Content-Type=application/json`
- `contains:"text"`
- `jsonpath:"$.items[0].id"`
- `matches:"^OK\\b"`

Acceptance
- Exit 3 on any failure, with a concise diff-like message
- Tests for pass and fail cases

## 7) Verb defaults and method validation
Goal
- Map verbs to default methods and validate using=

Defaults
- read GET
- save GET
- send GET by default, POST if with= present
- upload POST if attach= or with= present, else error
- watch GET
- inspect HEAD
- authenticate default POST if with= present

Acceptance
- Tests for defaults and invalid combinations

## 8) Redirect policy
Goal
- Implement safe redirect rules

Rules
- read and save follow up to 5 by default
- write verbs do not follow by default
- follow=smart follows only 307 and 308 for writes, up to 5
- On 301, 302, 303 for writes, do not follow, print advisory

Acceptance
- Integration tests for 301, 302, 303, 307, 308 with and without smart
- Stderr shows compact trace

## 9) Transparent compression
Goal
- gzip and br on by default

Do
- Inject Accept-Encoding unless user set it
- Auto decompress before as= and expect=
- One line stderr note when decompressed

Acceptance
- gz and br tests, expect sees decoded text, user header respected

## 10) TLS control
Goal
- Implement insecure=true

Acceptance
- Self signed server fails normally, succeeds with insecure=true
- One line stderr warning: TLS verification disabled

## 11) Query param merging and URL assembly
Goal
- Merge URL params with include param items

Acceptance
- Repeated keys serialize in insertion order
- Proper percent encoding
- Existing URL params preserved and merged

## 12) Output control with as= and to=
Goal
- Finalize sinks and formatting

Do
- as=json, text, raw, csv
- to=PATH writes file. For save, derive filename from URL if needed
- stdout is body, stderr is compact meta with redaction

Acceptance
- Filename extraction, directory handling, percent decoding, meta block content

## 13) Sessions and authenticate
Goal
- Explicit session model

Do
- authenticate captures Set-Cookie and `access_token` from JSON
- Store per host in user state dir with strict perms
- Auto apply for matching host unless caller includes Authorization or Cookie
- Print `Using session for <host>` on use
- session show, session clear, session use implemented

Acceptance
- Integration tests for login, reuse, override, redaction, permission refusal

## 14) Multipart body construction
Goal
- Build body with generated boundary and proper part headers

Acceptance
- Echo server validates Content-Disposition, Content-Type, filenames and order
- Manual Content-Type overridden with a note

## 15) Errors, hints, exit codes
Goal
- Clear, specific failures

Acceptance
- Exit codes: 0 ok, 3 expect fail, 4 network, 5 grammar
- Hints for unquoted semicolons, missing equals, duplicate singletons, unknown clause, bad attach part

## 16) Help and explain
Goal
- Discoverability tools

Do
- `req help` prints grammar table and examples
- `req explain "<command>"` prints parsed plan without executing

Acceptance
- Golden tests for explain output

## 17) Cross shell quoting doc
Goal
- Portability guidance

Do
- Quoting cheat sheet for bash, zsh, fish, PowerShell
- Curl vs req mapping table for common tasks

Acceptance
- Docs included and examples parse in a simple parser smoke test

## 18) CI, golden, fixtures
Goal
- Stable test harness

Do
- Golden tests for parser and explain
- Local HTTP fixture: echo headers, cookies, query, gzip, br, 30x, multipart
- Run under race detector

Acceptance
- CI green across Go versions you support

## 19) Streaming and watch polish
Goal
- Memory efficient downloads and sensible watch output

Do
- Stream to file for save
- Watch prints timestamps on TTY, raw otherwise

Acceptance
- Large download uses low memory
- Watch behaves per TTY detection

## 20) README refresh
Goal
- Align docs with grammar

Do
- Replace stale examples with include, attach, expect forms
- Document redirect defaults and smart policy
- Add warning about insecure=true and shell history

Acceptance
- Doc snippets pass as golden examples

----
.github/ISSUE_TEMPLATE/bug_report.md
---
name: Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Description

A clear and concise description of what the bug is.

## Reproduction

**Command:**
```bash
req <your-command-here>
```

**Expected Output:**
```
<expected-output>
```

**Actual Output:**
```
<actual-output>
```

## Environment

- OS: [e.g., Linux, macOS, Windows]
- Architecture: [e.g., amd64, arm64]
- Version: [e.g., v0.1.0]
- Go version: [e.g., 1.23]

## Additional Context

Add any other context about the problem here, including:
- Error messages
- Stack traces (if applicable)
- Workarounds you've tried


----
.github/ISSUE_TEMPLATE/feature_request.md
---
name: Feature Request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Summary

A clear and concise description of the feature you'd like to see.

## Motivation

Why is this feature needed? What problem does it solve?

## Detailed Description

Describe the feature in detail:
- What should the command syntax look like?
- What should the output look like?
- Are there any edge cases to consider?

## Example Usage

```bash
req <example-command>
```

## Alternatives Considered

Describe any alternative solutions or features you've considered.

## Additional Context

Add any other context, mockups, or examples about the feature request here.


----
.github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Run tests with race detector
        run: make test
      
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          make vulncheck
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m
  
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-${{ matrix.os }}
          path: bin/req
  
  windows:
    name: Windows Build
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-windows
          path: bin/req.exe

  grammar-drift:
    name: Grammar Drift Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build binary
        run: make build
      
      - name: Run grammar drift tests
        run: go test -v ./tests -run 'TestGrammarDrift|TestBinaryHelpDrift'


----
.gitignore
# Binaries
bin/
req
req.exe

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
*.tar.gz
*.zip


----
.golangci.yml
# golangci-lint configuration with lean modern linter set
run:
  timeout: 5m
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  gocritic:
    enabled-tags:
      - diagnostic
  govet:
    check-shadowing: true
  misspell:
    locale: US
  nolintlint:
    allow-leading-space: true
    allow-unused: false
    require-explanation: false
    require-specific: false

linters:
  disable-all: true
  enable:
    - errcheck
    - gocritic
    - goimports
    - gosimple
    - govet
    - ineffassign
    - misspell
    - nolintlint
    - staticcheck

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
  max-issues-per-linter: 0
  max-same-issues: 0

----
.goreleaser.yml
# GoReleaser configuration for cross-platform releases
project_name: req

before:
  hooks:
    - go mod download

builds:
  - id: req
    main: ./cmd/req
    binary: req
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    goarm:
      - 6
      - 7
    ignore:
      - goos: windows
        goarch: arm64
    env:
      - CGO_ENABLED=0
    flags:
      - -trimpath
      - -ldflags=-s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.buildDate={{.Date}}

archives:
  - id: default
    builds:
      - req
    format_overrides:
      - goos: windows
        format: zip
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    files:
      - LICENSE
      - README.md

checksum:
  name_template: "{{ .ProjectName }}_{{ .Version }}_checksums.txt"

snapshot:
  name_template: "{{ .Tag }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"


----
LICENSE
MIT License

Copyright (c) 2025 Adam Perkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


----
Makefile
.PHONY: build test lint package golden clean help

# Variables
BINARY_NAME=req
MAIN_PATH=./cmd/req
VERSION?=dev
BUILD_DIR=./bin
COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build the req binary
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
ifeq ($(GOOS),windows)
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME).exe $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME).exe"
else
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"
endif

test: ## Run tests with race detector
	@echo "Running tests..."
	@go test -race -cover -v ./...

test-golden: ## Run golden file tests
	@echo "Running golden tests..."
	@go test -v ./tests -run TestGolden

golden: ## Regenerate golden test files
	@echo "Regenerating golden files..."
	@go test ./tests -run TestGolden -update

lint: ## Run golangci-lint
	@echo "Running golangci-lint..."
	@golangci-lint run

lint-fix: ## Run golangci-lint with auto-fix
	@golangci-lint run --fix

vulncheck: ## Run govulncheck
	@echo "Running govulncheck..."
	@govulncheck ./...

package: ## Build release artifacts locally (requires goreleaser)
	@echo "Building release artifacts..."
	@goreleaser build --snapshot --clean

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@go clean -cache

install: build ## Install binary to GOPATH/bin
	@go install $(MAIN_PATH)


----
README.md
# req

A semantic HTTP client written in Go that replaces traditional curl syntax with a natural, intent-based grammar.

## Overview

`req` is an HTTP client tool that focuses on:

- **Human-readable commands** (verbs + clauses)
- **Sensible defaults** (follow redirects, TLS verify, retries)
- **JSON/CSV/text awareness** with intelligent output
- **Watch mode** (poll or stream)
- **Session management** (authenticate and auto-apply)
- **Pretty diagnostics** and dry-run transparency

## Quick Start

```bash
# Read JSON from an API
req read https://api.example.com/users as=json

# Send JSON data
req send https://api.example.com/users with='{"name":"Adam"}'

# Send with headers and assertions
req send https://api.example.com/users \
  using=POST \
  include='header: Authorization: Bearer $TOKEN' \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json \
  as=json

# Save a file
req save https://example.com/file.zip to=file.zip

# Upload multipart form data
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png' \
  as=json

# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Use stored session automatically
req read https://api.example.com/me as=json
```

## Installation

```bash
go install github.com/adammpkins/req/cmd/req@latest
```

Or download a pre-built binary from the [Releases](https://github.com/adammpkins/req/releases) page.

## Grammar

The `req` command follows this grammar:

```
req <verb> <target> [clauses...]
```

### Verbs

- `read` - GET, print to stdout
- `save` - GET, write to file via to=
- `send` - default GET, POST if `with=` is present
- `upload` - POST when `attach=` or `with=` present, else error
- `watch` - GET with SSE or polling
- `inspect` - HEAD only
- `authenticate` - login and store session state
- `session` - session management (show, clear, use)

### Clauses

- `using=<method>` - HTTP method override
- `include=<items>` - Add headers, params, cookies (repeatable)
  - Format: `include='header: Name: Value; param: key=value; cookie: key=value'`
- `with=<body>` - Request body
  - Format: `with=@user.json` or `with='{"name":"Adam"}'`
  - JSON inference: Automatically sets Content-Type for JSON when inline starts with `{` or `[`
- `expect=<checks>` - Assertions on response
  - Format: `expect=status:200, header:Content-Type=application/json, contains:"ok"`
- `as=<format>` - Output format for stdout
- `to=<path>` - Destination path
- `retry=<count>` - Retry attempts for transient errors
- `under=<limit>` - Timeout or size limit
  - Format: `under=30s` or `under=10MB`
- `via=<url>` - Proxy URL
- `attach=<parts>` - Multipart parts for upload or send (repeatable)
  - Format: `attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'`
- `follow=<policy>` - Redirect policy for write verbs
  - Format: `follow=smart`
- `insecure=<bool>` - Disable TLS verification for this request
  - Format: `insecure=true`

## Examples

### Read JSON

```bash
req read https://api.example.com/users as=json
```

### Send JSON Data

```bash
req send https://api.example.com/users with='{"name":"Ada","email":"ada@example.com"}'
```

### Save a File

```bash
# Save with explicit filename
req save https://example.com/file.zip to=file.zip

# Save with auto-detected filename (extracts from URL)
req save https://example.com/file.zip

# Save to directory path
req save https://example.com/file.zip to=/tmp/file.zip
```

### With Headers, Params, and Cookies

```bash
# Using include clause
req read https://api.example.com/search \
  include='header: Authorization: Bearer $TOKEN; param: q=search query; cookie: session=abc123' \
  as=json
```

### With Assertions

```bash
req send https://api.example.com/users \
  using=POST \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json, contains:"id" \
  as=json
```

### Sessions

```bash
# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Session is automatically used for subsequent requests
req read https://api.example.com/me as=json

# Show stored session (redacted)
req session show api.example.com

# Show session in JSON format
req session show api.example.com as=json

# Clear session
req session clear api.example.com
```

### Redirects

```bash
# Read and save follow redirects by default (up to 5)
req read https://example.com/redirect

# Write verbs don't follow by default
req send https://api.example.com/create using=POST with='{"data":"value"}'

# Use smart follow for write verbs (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
```

### With Retry and Timeout

```bash
req read https://api.example.com/users retry=3 under=10s as=json
```

### Edge Cases

```bash
# Header with commas and q values (must be quoted)
req read https://api.example.com/search \
  include='header: Accept: application/json, application/problem+json; q=0.9' \
  as=json

# Cookie value containing semicolons (must be quoted)
req read https://api.example.com/search \
  include='cookie: prefs="a=1; b=2; c=3"' \
  as=json

# Multipart upload with file and text parts (Content-Type automatically overridden)
req upload https://api.example.com/upload \
  include='header: Content-Type: application/json' \
  attach='part: name=file, file=@avatar.png; part: name=meta, value={"name":"test"}' \
  as=json
# Note: Content-Type will be overridden to multipart/form-data

# Smart redirect on write verb (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
# Will follow 307/308 redirects, but not 301/302/303

# Write verb with 303 redirect (advisory printed, not followed)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}'
# If server returns 303, advisory message printed but redirect not followed
```

### Method Override

```bash
# Use PUT instead of POST
req send https://api.example.com/users/1 using=PUT with='{"name":"Updated"}'

# Use PATCH for partial updates
req send https://api.example.com/users/1 using=PATCH with='{"email":"new@example.com"}'

# Use HEAD to check headers without body
req read https://api.example.com/users using=HEAD
```

**Note:** The `using=` clause validates method-verb compatibility. For example, `read using=POST` will fail as `read` only allows GET, HEAD, or OPTIONS.

### Comparison with curl

| Task | curl | req |
|------|------|-----|
| **Basic GET with headers** | `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include='header: Authorization: Bearer $TOKEN'` |
| **Multipart upload** | `curl -F "file=@avatar.png" -F "name=test" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png; part: name=name, value=test'` |
| **Authenticated POST** | `curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users using=POST include='header: Authorization: Bearer $TOKEN' with='{"name":"Adam"}'` |

### Dry Run

```bash
req read https://api.example.com/users as=json --dry-run
```

### Interactive TUI Mode

```bash
# Launch interactive TUI mode
req --tui

# Or run without arguments to launch TUI
req
```

The TUI mode provides:
- Interactive command builder with form-based input
- **Syntax-highlighted JSON output** with color-coded keys, values, and punctuation
- **Scrollable viewport** for long responses with keyboard navigation
- Pretty-printed JSON with automatic indentation
- Real-time command execution and response display

**Keyboard Controls:**
- `↑` / `↓` or `k` / `j` - Scroll line by line
- `pgup` / `pgdown` - Page scrolling
- `home` - Jump to top
- `end` - Jump to bottom
- `ctrl+u` / `ctrl+d` - Half-page scrolling
- `esc` - Quit TUI

## Security

### Shell History

**Warning:** Commands containing secrets (tokens, passwords) are stored in your shell history by default. Use environment variables to avoid exposing secrets:

```bash
# Bad: Token appears in shell history
req read https://api.example.com/users include='header: Authorization: Bearer secret-token-123'

# Good: Use environment variable
TOKEN="secret-token-123"
req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"
```

To prevent secrets from being saved to history:
- **Bash/Zsh:** Prefix command with a space (requires `HISTCONTROL=ignorespace` or `setopt HIST_IGNORE_SPACE`)
- **Fish:** Use `history --delete` after running commands with secrets
- **PowerShell:** Use `Set-PSReadlineOption -HistoryNoDuplicates` and manually edit history

### Session Files

Session files are stored in `~/.config/req/session_<host>.json` with permissions `0600` (owner read/write only).

**Security rules:**
- Session files are created with strict permissions (`0600`)
- If a session file has group or world readable permissions, `req` will refuse to load it
- Session files contain sensitive data (cookies, tokens) and should be protected
- Never commit session files to version control

To check session file permissions:
```bash
ls -l ~/.config/req/session_*.json
```

## Current Status

**v0.1** - Core functionality complete

- ✅ Command parsing with full grammar validation
- ✅ All clauses implemented (include, attach, expect, follow, insecure, etc.)
- ✅ Execution plan generation with verb defaults
- ✅ HTTP request execution with redirect handling
- ✅ Transparent compression (gzip, br)
- ✅ Session management (authenticate, session show/clear/use)
- ✅ Auto-apply sessions for matching hosts
- ✅ File downloads with automatic filename extraction
- ✅ Multipart form data support
- ✅ Response assertions (expect clause)
- ✅ Proper exit codes (0 success, 3 expect fail, 4 network, 5 grammar)
- ✅ Helpful error messages with suggestions
- ✅ Help and explain commands
- ✅ Interactive TUI mode
- ✅ JSON output formatting
- ✅ Stderr meta output with redaction

## Roadmap

- **v0.1** ✅ - Core functionality (current)
- **v0.2** - Watch mode with SSE and polling
- **v0.3** - JSONPath selection and filtering
- **v0.4** - Advanced retry and backoff strategies
- **v1.0** - Stability hardening and release candidates

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

MIT License - see [LICENSE](LICENSE) file for details.


----
cmd/req/main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/adammpkins/req/internal/grammar"
	"github.com/adammpkins/req/internal/output"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
	"github.com/adammpkins/req/internal/tui"
	"github.com/adammpkins/req/internal/types"
)

var (
	version   = "dev"
	commit    = "unknown"
	buildDate = "unknown"
)

func main() {
	var (
		showHelp    = flag.Bool("help", false, "Show help message")
		showVersion = flag.Bool("version", false, "Show version information")
		dryRun      = flag.Bool("dry-run", false, "Print execution plan without executing")
		tuiMode     = flag.Bool("tui", false, "Launch interactive TUI mode")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: req <verb> <target> [clauses...]\n\n")
		fmt.Fprintf(os.Stderr, "Verbs: read, save, send, upload, watch, inspect, authenticate, session\n\n")
		fmt.Fprintf(os.Stderr, "Examples:\n")
		fmt.Fprintf(os.Stderr, "  req read https://api.example.com/users as=json\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users using=PUT with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req save https://example.com/file.zip to=file.zip\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showHelp {
		flag.Usage()
		os.Exit(0)
	}

	if *showVersion {
		fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
		os.Exit(0)
	}

	// Launch TUI mode if requested
	if *tuiMode {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Get remaining args after flags
	args := flag.Args()

	// Remove any remaining flags from args (in case they appear after command args)
	filteredArgs := make([]string, 0, len(args))
	for _, arg := range args {
		if arg == "--help" || arg == "-help" || arg == "-h" {
			flag.Usage()
			os.Exit(0)
		}
		if arg == "--version" || arg == "-version" || arg == "-v" {
			fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
			os.Exit(0)
		}
		if arg == "--dry-run" || arg == "-dry-run" {
			*dryRun = true
			continue
		}
		filteredArgs = append(filteredArgs, arg)
	}
	args = filteredArgs

	// If no args provided, launch TUI mode
	if len(args) == 0 {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Handle help command
	if len(args) > 0 && args[0] == "help" {
		printHelp()
		os.Exit(0)
	}

	// Handle explain command
	if len(args) > 0 && args[0] == "explain" {
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Usage: req explain \"<command>\"\n")
			os.Exit(5)
		}
		command := strings.Join(args[1:], " ")
		if err := explainCommand(command); err != nil {
			printError(err)
			os.Exit(5)
		}
		os.Exit(0)
	}

	// Join args into a single command string
	command := strings.Join(args, " ")

	// Parse the command
	cmd, err := parser.Parse(command)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar error
	}

	// Handle session commands specially
	if cmd.Verb == types.VerbSession {
		if err := handleSessionCommand(cmd); err != nil {
			printError(err)
			os.Exit(5)
		}
		return
	}

	// Plan the execution
	plan, err := planner.Plan(cmd)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar/planning error
	}

	// Output the plan (dry-run mode)
	if *dryRun {
		formatted, err := output.FormatPlan(plan)
		if err != nil {
			printError(fmt.Errorf("failed to format plan: %w", err))
			os.Exit(5)
		}
		fmt.Println(string(formatted))
		return
	}

	// Execute the plan
	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		printError(fmt.Errorf("failed to create executor: %w", err))
		os.Exit(5) // Grammar error
	}

	if err := executor.Execute(plan); err != nil {
		printError(err)
		// Check error type for exit code
		if execErr, ok := err.(*runtime.ExecutionError); ok {
			os.Exit(execErr.Code)
		}
		os.Exit(4) // Network error (default)
	}
}

// printError prints an error with helpful diagnostics.
func printError(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v\n", err)

	// Check if it's a ParseError with suggestions
	if parseErr, ok := err.(*parser.ParseError); ok && parseErr.Suggest != "" {
		fmt.Fprintf(os.Stderr, "Hint: Try using '%s' instead\n", parseErr.Suggest)
	}
}

// printHelp prints the grammar summary.
func printHelp() {
	fmt.Print(grammar.FormatHelp())
}

// explainCommand prints the parsed plan for a command without executing it.
func explainCommand(command string) error {
	cmd, err := parser.Parse(command)
	if err != nil {
		return err
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		return err
	}

	formatted, err := output.FormatPlan(plan)
	if err != nil {
		return fmt.Errorf("failed to format plan: %w", err)
	}

	fmt.Println(string(formatted))
	return nil
}

// handleSessionCommand handles session management commands.
func handleSessionCommand(cmd *types.Command) error {
	host, err := session.ExtractHost(cmd.Target.URL)
	if err != nil {
		return fmt.Errorf("invalid host: %w", err)
	}

	switch cmd.SessionSubcommand {
	case "show":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			fmt.Printf("No session found for %s\n", host)
			return nil
		}

		// Check if JSON output requested
		asJSON := false
		for _, clause := range cmd.Clauses {
			if asClause, ok := clause.(types.AsClause); ok && asClause.Format == "json" {
				asJSON = true
				break
			}
		}

		if asJSON {
			// Machine-friendly JSON output
			data, err := json.MarshalIndent(sess, "", "  ")
			if err != nil {
				return fmt.Errorf("failed to marshal session: %w", err)
			}
			fmt.Println(string(data))
		} else {
			// Human-readable redacted output
			redacted := session.RedactSession(sess)
			fmt.Printf("Session for %s:\n", redacted.Host)
			if len(redacted.Cookies) > 0 {
				fmt.Println("Cookies:")
				for name := range redacted.Cookies {
					fmt.Printf("  %s: ***\n", name)
				}
			}
			if redacted.Authorization != "" {
				fmt.Printf("Authorization: %s\n", redacted.Authorization)
			}
		}
		return nil

	case "clear":
		if err := session.DeleteSession(host); err != nil {
			return fmt.Errorf("failed to delete session: %w", err)
		}
		fmt.Printf("Session cleared for %s\n", host)
		return nil

	case "use":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			return fmt.Errorf("no session found for %s", host)
		}
		// Print environment variable stub for shell scoping
		fmt.Printf("export REQ_SESSION_HOST=%s\n", host)
		return nil

	default:
		return fmt.Errorf("unknown session subcommand: %s", cmd.SessionSubcommand)
	}
}

----
docs/QUOTING.md
# Cross Shell Quoting Guide

This guide provides examples of how to properly quote `req` commands in different shells.

## General Rules

- Values containing semicolons (`;`) must be quoted
- Values containing spaces should be quoted
- Values containing special characters should be quoted
- Environment variables are expanded by the shell before being passed to `req`

## Bash / Zsh

### Single Quotes (Recommended)
Single quotes preserve everything literally:

```bash
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

### Double Quotes
Double quotes allow variable expansion:

```bash
TOKEN="abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

### Escaping
Use backslash to escape special characters:

```bash
req read https://api.example.com/search include='param: q=test\;value' as=json
```

## Fish Shell

Fish uses different quoting rules:

```fish
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in fish:

```fish
set TOKEN "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## PowerShell

PowerShell uses backticks for escaping:

```powershell
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in PowerShell:

```powershell
$TOKEN = "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## Common Patterns

### Include Clause with Multiple Items

```bash
# Bash/Zsh
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# Fish
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# PowerShell
req read https://api.example.com/search `
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' `
  as=json
```

### Expect Clause with Multiple Checks

```bash
req read https://api.example.com/users \
  expect='status:200, header:Content-Type=application/json, contains:"items"' \
  as=json
```

### Attach Clause with File Paths

```bash
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
  as=json
```

## Curl vs req Mapping

| curl command | req equivalent |
|-------------|----------------|
| `curl https://api.example.com/users` | `req read https://api.example.com/users` |
| `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"` |
| `curl -X POST -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users with='{"name":"Adam"}'` |
| `curl -X POST -F "file=@avatar.png" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png'` |
| `curl -b "session=abc123" https://api.example.com/users` | `req read https://api.example.com/users include='cookie: session=abc123'` |
| `curl -L https://example.com` | `req read https://example.com` (follows redirects by default) |
| `curl -k https://self-signed.example.com` | `req read https://self-signed.example.com insecure=true` |
| `curl --proxy http://proxy:8080 https://api.example.com` | `req read https://api.example.com via=http://proxy:8080` |
| `curl -X POST --data-binary @file.json https://api.example.com` | `req send https://api.example.com with=@file.json` |
| `curl -X POST --data @- https://api.example.com` | `echo '{"data":"value"}' \| req send https://api.example.com with=@-` |

## Tips

1. **Always quote include= values** - They often contain semicolons and spaces
2. **Use single quotes for JSON** - Prevents shell from interpreting special characters
3. **Use double quotes when you need variable expansion** - But be careful with nested quotes
4. **Test with `req explain`** - See how your command is parsed before executing:
   ```bash
   req explain "read https://api.example.com/users include='header: Authorization: Bearer token'"
   ```


----
go.mod
module github.com/adammpkins/req

go 1.24.0

toolchain go1.24.10

require (
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
)

require (
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

----
go.sum
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=

----
internal/grammar/grammar.go
// Package grammar defines the structured grammar data for req commands.
package grammar

import "fmt"

// Verb represents a req command verb.
type Verb struct {
	Name        string
	Description string
}

// Clause represents a req command clause.
type Clause struct {
	Name        string
	Description string
	Repeatable  bool
	Example     string
}

// Grammar contains the complete grammar definition.
type Grammar struct {
	Verbs   []Verb
	Clauses []Clause
}

// GetGrammar returns the canonical grammar definition.
func GetGrammar() Grammar {
	return Grammar{
		Verbs: []Verb{
			{Name: "read", Description: "GET, print to stdout"},
			{Name: "save", Description: "GET, write to file via to="},
			{Name: "send", Description: "default GET, POST if with= present"},
			{Name: "upload", Description: "POST when attach= or with= present, else error"},
			{Name: "watch", Description: "GET with SSE or polling"},
			{Name: "inspect", Description: "HEAD only"},
			{Name: "authenticate", Description: "login and store session state"},
			{Name: "session", Description: "session management (show, clear, use)"},
		},
		Clauses: []Clause{
			{Name: "using=", Description: "HTTP method override", Repeatable: false, Example: "using=PUT"},
			{Name: "include=", Description: "Add headers, params, cookies", Repeatable: true, Example: "include='header: Authorization: Bearer token; param: q=search query'"},
			{Name: "with=", Description: "Request body", Repeatable: false, Example: "with=@user.json or with='{\"name\":\"Adam\"}'"},
			{Name: "expect=", Description: "Assertions on response", Repeatable: false, Example: "expect=status:200, header:Content-Type=application/json, contains:\"ok\""},
			{Name: "as=", Description: "Output format for stdout", Repeatable: false, Example: "as=json"},
			{Name: "to=", Description: "Destination path", Repeatable: false, Example: "to=out.json"},
			{Name: "retry=", Description: "Retry attempts for transient errors", Repeatable: false, Example: "retry=3"},
			{Name: "under=", Description: "Timeout or size limit", Repeatable: false, Example: "under=30s or under=10MB"},
			{Name: "via=", Description: "Proxy URL", Repeatable: false, Example: "via=http://proxy:8080"},
			{Name: "attach=", Description: "Multipart parts for upload or send", Repeatable: true, Example: "attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'"},
			{Name: "follow=", Description: "Redirect policy for write verbs", Repeatable: false, Example: "follow=smart"},
			{Name: "insecure=", Description: "Disable TLS verification for this request", Repeatable: false, Example: "insecure=true"},
		},
	}
}

// FormatHelp formats the grammar as help text.
func FormatHelp() string {
	g := GetGrammar()
	
	var help string
	help += "req - HTTP client DSL\n\n"
	help += "Usage: req <verb> <url> [clauses...]\n\n"
	help += "Verbs:\n"
	
	for _, verb := range g.Verbs {
		help += fmt.Sprintf("  %-13s - %s\n", verb.Name, verb.Description)
	}
	
	help += "\nClauses:\n"
	for _, clause := range g.Clauses {
		help += fmt.Sprintf("  %-13s - %s", clause.Name, clause.Description)
		if clause.Repeatable {
			help += " (repeatable)"
		}
		help += "\n"
		if clause.Example != "" {
			help += fmt.Sprintf("                 Example: %s\n", clause.Example)
		}
	}
	
	help += "\nExamples:\n"
	help += "  req read https://api.example.com/search include='param: q=search query' as=json\n"
	help += "  \n"
	help += "  req send https://api.example.com/users \\\n"
	help += "    using=POST \\\n"
	help += "    include='header: Authorization: Bearer $TOKEN' \\\n"
	help += "    with='{\"name\":\"Adam\"}' \\\n"
	help += "    expect=status:201, header:Content-Type=application/json \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req upload https://api.example.com/upload \\\n"
	help += "    attach='part: name=file, file=@./avatar.png, type=image/png' \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req authenticate https://api.example.com/login \\\n"
	help += "    using=POST \\\n"
	help += "    with='{\"user\":\"adam\",\"pass\":\"xyz\"}'\n"
	help += "  \n"
	help += "  req read https://api.example.com/me as=json\n\n"
	help += "For more information, see the grammar documentation.\n"
	
	return help
}


----
internal/grammar/snapshot.go
package grammar

import "encoding/json"

// Snapshot represents a snapshot of the grammar for drift detection.
type Snapshot struct {
	Verbs   []string `json:"verbs"`
	Clauses []ClauseSnapshot `json:"clauses"`
}

// ClauseSnapshot represents a clause in the snapshot.
type ClauseSnapshot struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Repeatable  bool   `json:"repeatable"`
}

// GetSnapshot returns a JSON-serializable snapshot of the grammar.
func GetSnapshot() Snapshot {
	g := GetGrammar()
	
	verbs := make([]string, len(g.Verbs))
	for i, v := range g.Verbs {
		verbs[i] = v.Name
	}
	
	clauses := make([]ClauseSnapshot, len(g.Clauses))
	for i, c := range g.Clauses {
		clauses[i] = ClauseSnapshot{
			Name:        c.Name,
			Description: c.Description,
			Repeatable:  c.Repeatable,
		}
	}
	
	return Snapshot{
		Verbs:   verbs,
		Clauses: clauses,
	}
}

// GetSnapshotJSON returns the snapshot as JSON bytes.
func GetSnapshotJSON() ([]byte, error) {
	snapshot := GetSnapshot()
	return json.MarshalIndent(snapshot, "", "  ")
}


----
internal/output/format.go
// Package output provides formatting and pretty-printing for execution plans.
package output

import (
	"encoding/json"
	"os"

	"github.com/adammpkins/req/internal/planner"
	"github.com/mattn/go-isatty"
)

// FormatPlan formats an ExecutionPlan as JSON for output.
func FormatPlan(plan *planner.ExecutionPlan) ([]byte, error) {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		// Pretty print when outputting to terminal
		return json.MarshalIndent(plan, "", "  ")
	}
	// Compact JSON when piped
	return json.Marshal(plan)
}


----
internal/parser/parser.go
// Package parser implements a lexer and parser for the req command grammar.
//
// Grammar (EBNF):
//
//	command = verb target [clauses]
//	verb = "read" | "save" | "send" | "upload" | "watch" | "inspect" | "authenticate" | "session"
//	target = url
//	clauses = clause { clause }
//	clause = with_clause | include_clause | attach_clause | expect_clause | as_clause | to_clause |
//	         using_clause | retry_clause | under_clause | via_clause | follow_clause | insecure_clause
//	with_clause = "with=" ( string | "@file" | "@-" )
//	include_clause = "include=" items
//	attach_clause = "attach=" parts
//	expect_clause = "expect=" checks
//	as_clause = "as=" ( "json" | "csv" | "text" | "raw" )
//	to_clause = "to=" path
//	using_clause = "using=" ( "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS" )
//	retry_clause = "retry=" number
//	under_clause = "under=" ( duration | size )
//	via_clause = "via=" url
//	follow_clause = "follow=smart"
//	insecure_clause = "insecure=" ( "true" | "false" )
package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// isValidHTTPMethod checks if a method is a valid HTTP method.
func isValidHTTPMethod(method string) bool {
	validMethods := []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	methodUpper := strings.ToUpper(method)
	for _, valid := range validMethods {
		if methodUpper == valid {
			return true
		}
	}
	return false
}

// ParseError represents a parse error with position information.
type ParseError struct {
	Position int
	Token    string
	Message  string
	Suggest  string
}

func (e *ParseError) Error() string {
	if e.Suggest != "" {
		return fmt.Sprintf("parse error at position %d (token: %q): %s (did you mean %q?)", e.Position, e.Token, e.Message, e.Suggest)
	}
	return fmt.Sprintf("parse error at position %d (token: %q): %s", e.Position, e.Token, e.Message)
}

// Parser parses req commands into AST.
type Parser struct {
	tokens []token
	pos    int
}

// token represents a lexical token.
type token struct {
	typ   tokenType
	value string
	pos   int
}

type tokenType int

const (
	tokenEOF tokenType = iota
	tokenWord
	tokenURL
	tokenEquals
	tokenColon
	tokenDotDot
	tokenString
	tokenNumber
	tokenDuration
	tokenFlag
)

// Parse parses a command string into a Command AST.
func Parse(input string) (*types.Command, error) {
	p := &Parser{}
	p.tokenize(input)
	return p.parseCommand()
}

// tokenize tokenizes the input string.
func (p *Parser) tokenize(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		p.tokens = []token{{typ: tokenEOF, pos: 0}}
		return
	}

	parts := strings.Fields(input)
	tokens := make([]token, 0, len(parts))

	for i, part := range parts {
		pos := i
		// Check if this is a URL first (URLs with query params contain = but are not clauses)
		if looksLikeURL(part) {
			tokens = append(tokens, token{typ: tokenURL, value: part, pos: pos})
		} else if strings.Contains(part, "=") {
			// Handle clauses with equals
			// Split on = but keep the = as a token
			eqIdx := strings.Index(part, "=")
			key := part[:eqIdx]
			value := part[eqIdx+1:]

			tokens = append(tokens, token{typ: tokenWord, value: key, pos: pos})
			tokens = append(tokens, token{typ: tokenEquals, value: "=", pos: pos})
			// Handle typed values like json:...
			if strings.Contains(value, ":") {
				colonIdx := strings.Index(value, ":")
				typeName := value[:colonIdx]
				typeValue := value[colonIdx+1:]
				tokens = append(tokens, token{typ: tokenWord, value: typeName, pos: pos})
				tokens = append(tokens, token{typ: tokenColon, value: ":", pos: pos})
				tokens = append(tokens, token{typ: tokenString, value: typeValue, pos: pos})
			} else if looksLikeURL(value) {
				tokens = append(tokens, token{typ: tokenURL, value: value, pos: pos})
			} else if looksLikeDuration(value) {
				tokens = append(tokens, token{typ: tokenDuration, value: value, pos: pos})
			} else {
				tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
			}
		} else if isFlag(part) {
			tokens = append(tokens, token{typ: tokenFlag, value: part, pos: pos})
		} else {
			tokens = append(tokens, token{typ: tokenWord, value: part, pos: pos})
		}
	}

	tokens = append(tokens, token{typ: tokenEOF, pos: len(parts)})
	p.tokens = tokens
}

// looksLikeURL checks if a string looks like a URL.
func looksLikeURL(s string) bool {
	return strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://")
}

// looksLikeDuration checks if a string looks like a duration.
func looksLikeDuration(s string) bool {
	_, err := parseDuration(s)
	return err == nil
}

// isFlag checks if a string is a flag.
func isFlag(s string) bool {
	return s == "verbose" || s == "resume"
}

// parseCommand parses a command.
func (p *Parser) parseCommand() (*types.Command, error) {
	cmd := &types.Command{}

	// Parse verb
	verb, err := p.parseVerb()
	if err != nil {
		return nil, err
	}
	cmd.Verb = verb

	// Handle session subcommands (show, clear, use)
	if verb == types.VerbSession {
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected session subcommand (show, clear, use)"}
		}
		tok := p.tokens[p.pos]
		if tok.typ == tokenWord {
			subcmd := tok.value
			if subcmd == "show" || subcmd == "clear" || subcmd == "use" {
				cmd.SessionSubcommand = subcmd
				p.pos++
			} else {
				return nil, &ParseError{Position: tok.pos, Token: subcmd, Message: "unknown session subcommand (expected show, clear, or use)"}
			}
		}
	}

	// Parse target
	target, err := p.parseTarget()
	if err != nil {
		return nil, err
	}
	cmd.Target = target

	// Parse clauses
	clauses, err := p.parseClauses()
	if err != nil {
		return nil, err
	}
	cmd.Clauses = clauses

	return cmd, nil
}

// parseVerb parses a verb.
func (p *Parser) parseVerb() (types.Verb, error) {
	if p.pos >= len(p.tokens) {
		return "", &ParseError{Position: p.pos, Token: "", Message: "expected verb"}
	}

	tok := p.tokens[p.pos]
	if tok.typ != tokenWord {
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "expected verb"}
	}

	verb := types.Verb(tok.value)
	switch verb {
	case types.VerbRead, types.VerbSave, types.VerbSend, types.VerbUpload,
		types.VerbWatch, types.VerbInspect, types.VerbAuthenticate, types.VerbSession:
		p.pos++
		return verb, nil
	default:
		suggest := suggestVerb(tok.value)
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "unknown verb", Suggest: suggest}
	}
}

// suggestVerb suggests a similar verb.
func suggestVerb(input string) string {
	verbs := []string{"read", "save", "send", "upload", "watch", "inspect", "authenticate", "session"}
	best := ""
	minDist := 999
	for _, v := range verbs {
		dist := levenshteinDistance(input, v)
		if dist < minDist {
			minDist = dist
			best = v
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// levenshteinDistance calculates the Levenshtein distance between two strings.
func levenshteinDistance(a, b string) int {
	if len(a) == 0 {
		return len(b)
	}
	if len(b) == 0 {
		return len(a)
	}

	matrix := make([][]int, len(a)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(b)+1)
	}

	for i := 0; i <= len(a); i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len(b); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {
			cost := 0
			if a[i-1] != b[j-1] {
				cost = 1
			}
			matrix[i][j] = min(
				matrix[i-1][j]+1,
				matrix[i][j-1]+1,
				matrix[i-1][j-1]+cost,
			)
		}
	}

	return matrix[len(a)][len(b)]
}

func min(a, b, c int) int {
	if a < b && a < c {
		return a
	}
	if b < c {
		return b
	}
	return c
}

// parseTarget parses a target URL.
func (p *Parser) parseTarget() (types.Target, error) {
	if p.pos >= len(p.tokens) {
		return types.Target{}, &ParseError{Position: p.pos, Token: "", Message: "expected target URL or host"}
	}

	tok := p.tokens[p.pos]
	// For session commands, target might be a host instead of full URL
	if tok.typ == tokenURL {
		p.pos++
		return types.Target{URL: tok.value}, nil
	} else if tok.typ == tokenWord {
		// Might be a host name for session commands
		// Try to parse as URL, if it fails, treat as host
		if strings.Contains(tok.value, ".") || strings.Contains(tok.value, ":") {
			// Looks like a host, construct URL
			urlStr := "https://" + tok.value
			p.pos++
			return types.Target{URL: urlStr}, nil
		}
	}

	return types.Target{}, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected URL or host"}
}

// parseClauses parses zero or more clauses.
func (p *Parser) parseClauses() ([]types.Clause, error) {
	var clauses []types.Clause
	singletonSeen := make(map[string]bool)

	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}

		clause, err := p.parseClause()
		if err != nil {
			return nil, err
		}

		// Check for duplicate singletons
		if singletonKey := getSingletonKey(clause); singletonKey != "" {
			if singletonSeen[singletonKey] {
				return nil, &ParseError{
					Position: tok.pos,
					Token:    tok.value,
					Message:  fmt.Sprintf("duplicate singleton clause '%s'", singletonKey),
					Suggest:  fmt.Sprintf("remove duplicate '%s=' clause", singletonKey),
				}
			}
			singletonSeen[singletonKey] = true
		}

		clauses = append(clauses, clause)
	}

	return clauses, nil
}

// getSingletonKey returns the key name for singleton clauses, or empty string for repeatable clauses.
func getSingletonKey(clause types.Clause) string {
	switch clause.(type) {
	case types.UsingClause:
		return "using"
	case types.WithClause:
		return "with"
	case types.ExpectClause:
		return "expect"
	case types.AsClause:
		return "as"
	case types.ToClause:
		return "to"
	case types.RetryClause:
		return "retry"
	case types.UnderClause:
		return "under"
	case types.ViaClause:
		return "via"
	case types.InsecureClause:
		return "insecure"
	case types.FollowClause:
		return "follow"
	case types.TimeoutClause:
		return "timeout"
	case types.BackoffClause:
		return "backoff"
	case types.PickClause:
		return "pick"
	case types.EveryClause:
		return "every"
	case types.UntilClause:
		return "until"
	case types.ProxyClause:
		return "proxy"
	case types.FieldClause:
		return "field"
	case types.VerboseClause:
		return "verbose"
	case types.ResumeClause:
		return "resume"
	// Repeatable clauses return empty string
	case types.IncludeClause, types.AttachClause:
		return ""
	default:
		return ""
	}
}

// parseClause parses a single clause.
func (p *Parser) parseClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected clause"}
	}

	tok := p.tokens[p.pos]

	// Handle flags (insecure is now a clause with =, but keep verbose and resume as flags)
	if tok.typ == tokenFlag {
		p.pos++
		switch tok.value {
		case "verbose":
			return types.VerboseClause{}, nil
		case "resume":
			return types.ResumeClause{}, nil
		}
	}

	// Handle clauses with equals
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
		key := tok.value
		p.pos += 2 // skip key and =

		switch key {
		case "with":
			return p.parseWithClause()
		case "include":
			return p.parseIncludeClause()
		case "attach":
			return p.parseAttachClause()
		case "expect":
			return p.parseExpectClause()
		case "headers":
			return p.parseHeadersClause()
		case "params":
			return p.parseParamsClause()
		case "as":
			return p.parseAsClause()
		case "to":
			return p.parseToClause()
		case "using":
			return p.parseUsingClause()
		case "retry":
			return p.parseRetryClause()
		case "backoff":
			return p.parseBackoffClause()
		case "timeout":
			return p.parseTimeoutClause()
		case "under":
			return p.parseUnderClause()
		case "proxy":
			return p.parseProxyClause()
		case "via":
			return p.parseViaClause()
		case "follow":
			return p.parseFollowClause()
		case "insecure":
			return p.parseInsecureClause()
		case "pick":
			return p.parsePickClause()
		case "every":
			return p.parseEveryClause()
		case "until":
			return p.parseUntilClause()
		case "field":
			return p.parseFieldClause()
		default:
			suggest := suggestClause(key)
			return nil, &ParseError{Position: tok.pos, Token: key, Message: "unknown clause", Suggest: suggest}
		}
	}

	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected clause"}
}

// suggestClause suggests a similar clause name.
func suggestClause(input string) string {
	clauses := []string{"with", "include", "attach", "expect", "headers", "params", "as", "to", "using", "retry", "backoff", "timeout", "under", "proxy", "via", "follow", "insecure", "pick", "every", "until", "field"}
	best := ""
	minDist := 999
	for _, c := range clauses {
		dist := levenshteinDistance(input, c)
		if dist < minDist {
			minDist = dist
			best = c
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// parseWithClause parses a "with=" clause.
func (p *Parser) parseWithClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	tok := p.tokens[p.pos]
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenColon {
		// typed value like json:...
		typeName := tok.value
		p.pos += 2 // skip type and :
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
		}
		valueTok := p.tokens[p.pos]
		p.pos++
		value := valueTok.value
		isFile := strings.HasPrefix(value, "@") && value != "@-"
		isStdin := value == "@-"
		if isFile {
			value = value[1:] // Remove @ prefix
		}
		return types.WithClause{Type: typeName, Value: value, IsFile: isFile, IsStdin: isStdin}, nil
	}

	// plain value - check for @file or @-
	valueTok := p.tokens[p.pos]
	p.pos++
	value := valueTok.value
	isFile := strings.HasPrefix(value, "@") && value != "@-"
	isStdin := value == "@-"
	if isFile {
		value = value[1:] // Remove @ prefix
	}
	
	// Infer JSON type if value starts with { or [
	typeInferred := ""
	if !isFile && !isStdin {
		trimmed := strings.TrimSpace(value)
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			typeInferred = "json"
		}
	}
	
	return types.WithClause{Value: value, Type: typeInferred, IsFile: isFile, IsStdin: isStdin}, nil
}

// parseHeadersClause parses a "headers=" clause (simplified for v0.1.0).
func (p *Parser) parseHeadersClause() (types.Clause, error) {
	// Simplified: just parse a single key:value pair for now
	// Full object parsing will come later
	return types.HeadersClause{Headers: make(map[string]string)}, nil
}

// parseParamsClause parses a "params=" clause (simplified for v0.1.0).
func (p *Parser) parseParamsClause() (types.Clause, error) {
	// Simplified: just parse a single key=value pair for now
	return types.ParamsClause{Params: make(map[string]string)}, nil
}

// parseAsClause parses an "as=" clause.
func (p *Parser) parseAsClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected format"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.AsClause{Format: tok.value}, nil
}

// parseToClause parses a "to=" clause.
func (p *Parser) parseToClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected destination"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ToClause{Destination: tok.value}, nil
}

// parseUsingClause parses a "using=" clause.
func (p *Parser) parseUsingClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected HTTP method"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	method := strings.ToUpper(tok.value)
	
	if !isValidHTTPMethod(method) {
		return nil, &ParseError{
			Position: tok.pos,
			Token:    tok.value,
			Message:  fmt.Sprintf("invalid HTTP method: %s (valid methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS)", tok.value),
		}
	}
	
	return types.UsingClause{Method: method}, nil
}

// parseRetryClause parses a "retry=" clause.
func (p *Parser) parseRetryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected retry count"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	// Parse number (simplified)
	count := 3 // default
	if tok.typ == tokenNumber {
		// In a real implementation, parse the number
		// For now, just use default
	}
	return types.RetryClause{Count: count}, nil
}

// parseBackoffClause parses a "backoff=" clause.
func (p *Parser) parseBackoffClause() (types.Clause, error) {
	// Format: backoff=200ms..5s
	if p.pos+2 >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected backoff range"}
	}

	minTok := p.tokens[p.pos]
	p.pos++
	if p.tokens[p.pos].typ != tokenDotDot {
		return nil, &ParseError{Position: p.pos, Token: p.tokens[p.pos].value, Message: "expected .."}
	}
	p.pos++
	maxTok := p.tokens[p.pos]
	p.pos++

	minDur, err := parseDuration(minTok.value)
	if err != nil {
		return nil, &ParseError{Position: minTok.pos, Token: minTok.value, Message: "invalid duration"}
	}
	maxDur, err := parseDuration(maxTok.value)
	if err != nil {
		return nil, &ParseError{Position: maxTok.pos, Token: maxTok.value, Message: "invalid duration"}
	}

	return types.BackoffClause{Min: minDur, Max: maxDur}, nil
}

// parseDuration parses a duration string.
func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

// parseTimeoutClause parses a "timeout=" clause.
func (p *Parser) parseTimeoutClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected timeout duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.TimeoutClause{Duration: dur}, nil
}

// parseProxyClause parses a "proxy=" clause.
func (p *Parser) parseProxyClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected proxy URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ProxyClause{URL: tok.value}, nil
}

// parsePickClause parses a "pick=" clause.
func (p *Parser) parsePickClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected JSONPath expression"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.PickClause{Path: tok.value}, nil
}

// parseEveryClause parses an "every=" clause.
func (p *Parser) parseEveryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected interval duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.EveryClause{Interval: dur}, nil
}

// parseUntilClause parses an "until=" clause.
func (p *Parser) parseUntilClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected predicate"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.UntilClause{Predicate: tok.value}, nil
}

// parseFieldClause parses a "field=" clause.
func (p *Parser) parseFieldClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field name"}
	}

	nameTok := p.tokens[p.pos]
	p.pos++
	if p.pos >= len(p.tokens) || p.tokens[p.pos].typ != tokenEquals {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected ="}
	}
	p.pos++
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field value"}
	}
	valueTok := p.tokens[p.pos]
	p.pos++

	return types.FieldClause{Name: nameTok.value, Value: valueTok.value}, nil
}

// parseIncludeClause parses an "include=" clause.
// Format: include='header: Name: Value; param: key=value; cookie: key=value'
func (p *Parser) parseIncludeClause() (types.Clause, error) {
	// Collect tokens until we have a complete include value
	// The value may contain colons, semicolons, and spaces
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected include value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}

	items, err := parseIncludeItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.IncludeClause{Items: items}, nil
}

// parseIncludeItems parses semicolon-separated include items.
func parseIncludeItems(value string) ([]types.IncludeItem, error) {
	var items []types.IncludeItem
	
	// Split by semicolons, but respect quoted strings
	parts := splitRespectingQuotes(value, ';')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		item, err := parseIncludeItem(part)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	
	return items, nil
}

// parseIncludeItem parses a single include item (header:, param:, cookie:).
func parseIncludeItem(part string) (types.IncludeItem, error) {
	// Find the first colon to determine the type
	colonIdx := strings.Index(part, ":")
	if colonIdx == -1 {
		return types.IncludeItem{}, fmt.Errorf("missing colon in include item: %s", part)
	}
	
	typeTag := strings.TrimSpace(part[:colonIdx])
	rest := strings.TrimSpace(part[colonIdx+1:])
	
	switch typeTag {
	case "header":
		// Format: header: Name: Value
		headerColonIdx := strings.Index(rest, ":")
		if headerColonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("header item missing Name colon Value: %s", part)
		}
		name := strings.TrimSpace(rest[:headerColonIdx])
		value := strings.TrimSpace(rest[headerColonIdx+1:])
		// Unquote if needed
		name = unquoteString(name)
		value = unquoteString(value)
		return types.IncludeItem{Type: "header", Name: name, Value: value}, nil
		
	case "param":
		// Format: param: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("param item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "param", Name: key, Value: value}, nil
		
	case "cookie":
		// Format: cookie: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("cookie item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "cookie", Name: key, Value: value}, nil
		
	default:
		return types.IncludeItem{}, fmt.Errorf("unknown include item tag: %s (expected header, param, or cookie)", typeTag)
	}
}

// splitRespectingQuotes splits a string by a delimiter while respecting quoted strings.
func splitRespectingQuotes(s string, delim rune) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	escape := false
	
	for _, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}
		
		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}
		
		if r == '\'' || r == '"' {
			inQuotes = !inQuotes
			current.WriteRune(r)
			continue
		}
		
		if r == delim && !inQuotes {
			parts = append(parts, current.String())
			current.Reset()
			continue
		}
		
		current.WriteRune(r)
	}
	
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	
	return parts
}

// unquoteString removes surrounding quotes if present and handles escapes.
func unquoteString(s string) string {
	if len(s) >= 2 && ((s[0] == '\'' && s[len(s)-1] == '\'') || (s[0] == '"' && s[len(s)-1] == '"')) {
		s = s[1 : len(s)-1]
		// Handle escapes
		var result strings.Builder
		escape := false
		for _, r := range s {
			if escape {
				if r == '\\' || r == '\'' || r == '"' {
					result.WriteRune(r)
				} else {
					result.WriteRune('\\')
					result.WriteRune(r)
				}
				escape = false
			} else if r == '\\' {
				escape = true
			} else {
				result.WriteRune(r)
			}
		}
		if escape {
			result.WriteRune('\\')
		}
		return result.String()
	}
	return s
}

// parseAttachClause parses an "attach=" clause.
// Format: attach='part: name=..., file=@path; part: name=..., value=...'
func (p *Parser) parseAttachClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected attach value"}
	}

	tok := p.tokens[p.pos]
	p.pos++

	value := tok.value
	parts, boundary, err := parseAttachItems(value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: err.Error()}
	}

	return types.AttachClause{Parts: parts, Boundary: boundary}, nil
}

// parseAttachItems parses semicolon-separated attach items.
func parseAttachItems(value string) ([]types.AttachPart, string, error) {
	var parts []types.AttachPart
	var boundary string
	
	// Split by semicolons, respecting quotes
	items := splitRespectingQuotes(value, ';')
	
	for _, item := range items {
		item = strings.TrimSpace(item)
		if item == "" {
			continue
		}
		
		// Check if it's a boundary specification
		if strings.HasPrefix(item, "boundary:") {
			boundary = strings.TrimSpace(strings.TrimPrefix(item, "boundary:"))
			boundary = unquoteString(boundary)
			continue
		}
		
		// Parse part: specification
		if !strings.HasPrefix(item, "part:") {
			return nil, "", fmt.Errorf("expected 'part:' or 'boundary:', got: %s", item)
		}
		
		partSpec := strings.TrimSpace(strings.TrimPrefix(item, "part:"))
		part, err := parseAttachPart(partSpec)
		if err != nil {
			return nil, "", err
		}
		parts = append(parts, part)
	}
	
	return parts, boundary, nil
}

// parseAttachPart parses a single attach part specification.
// Format: name=..., file=@path or value=..., optional filename=..., optional type=...
func parseAttachPart(spec string) (types.AttachPart, error) {
	var part types.AttachPart
	
	// Parse comma-separated key=value pairs
	pairs := splitRespectingQuotes(spec, ',')
	
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		eqIdx := strings.Index(pair, "=")
		if eqIdx == -1 {
			return types.AttachPart{}, fmt.Errorf("missing equals in attach part: %s", pair)
		}
		
		key := strings.TrimSpace(pair[:eqIdx])
		value := strings.TrimSpace(pair[eqIdx+1:])
		value = unquoteString(value)
		
		switch key {
		case "name":
			part.Name = value
		case "file":
			if strings.HasPrefix(value, "@") {
				part.FilePath = value[1:] // Remove @
			} else {
				part.FilePath = value
			}
		case "value":
			part.Value = value
		case "filename":
			part.Filename = value
		case "type":
			part.Type = value
		default:
			return types.AttachPart{}, fmt.Errorf("unknown attach part key: %s", key)
		}
	}
	
	// Validate: name is required
	if part.Name == "" {
		return types.AttachPart{}, fmt.Errorf("attach part missing required 'name='")
	}
	
	// Validate: exactly one of file or value
	hasFile := part.FilePath != ""
	hasValue := part.Value != ""
	if hasFile && hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part cannot have both 'file=' and 'value='")
	}
	if !hasFile && !hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part must have either 'file=' or 'value='")
	}
	
	return part, nil
}

// parseExpectClause parses an "expect=" clause.
// Format: expect=status:200, header:Content-Type=application/json, contains:"text"
func (p *Parser) parseExpectClause() (types.Clause, error) {
	// Collect tokens until we have a complete expect value
	// The value may contain colons and commas, so we need to collect multiple tokens
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected expect value"}
	}

	// Join tokens, but handle colons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon and current isn't a colon
			if valueParts[i-1] != ":" && part != ":" {
				value += " "
			}
		}
		value += part
	}
	
	checks, err := parseExpectChecks(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.ExpectClause{Checks: checks}, nil
}

// parseExpectChecks parses comma-separated expect checks.
func parseExpectChecks(value string) ([]types.ExpectCheck, error) {
	var checks []types.ExpectCheck
	
	// Split by commas, respecting quotes
	parts := splitRespectingQuotes(value, ',')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		check, err := parseExpectCheck(part)
		if err != nil {
			return nil, err
		}
		checks = append(checks, check)
	}
	
	return checks, nil
}

// parseExpectCheck parses a single expect check.
func parseExpectCheck(part string) (types.ExpectCheck, error) {
	// Unquote if needed first
	unquoted := unquoteString(part)
	
	// Check types: status:, header:, contains:, jsonpath:, matches:
	if strings.HasPrefix(unquoted, "status:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "status:"))
		return types.ExpectCheck{Type: "status", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "header:") {
		rest := strings.TrimSpace(strings.TrimPrefix(unquoted, "header:"))
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.ExpectCheck{}, fmt.Errorf("header check missing equals: %s", part)
		}
		name := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		value = unquoteString(value)
		return types.ExpectCheck{Type: "header", Name: name, Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "contains:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "contains:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "contains", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "jsonpath:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "jsonpath:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "jsonpath", Path: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "matches:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "matches:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "matches", Regex: value}, nil
	}
	
	return types.ExpectCheck{}, fmt.Errorf("unknown expect check type: %s", part)
}

// parseFollowClause parses a "follow=" clause.
func (p *Parser) parseFollowClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected follow value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "smart" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "follow accepts only 'smart'"}
	}
	
	return types.FollowClause{Policy: "smart"}, nil
}

// parseUnderClause parses an "under=" clause (duration or size).
func (p *Parser) parseUnderClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected under value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.TrimSpace(tok.value)
	
	// Try parsing as duration first
	if dur, err := parseDuration(value); err == nil {
		return types.UnderClause{Duration: dur, IsSize: false}, nil
	}
	
	// Try parsing as size (e.g., "10MB", "1GB")
	if size, err := parseSize(value); err == nil {
		return types.UnderClause{Size: size, IsSize: true}, nil
	}
	
	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "under value must be a duration (e.g., 30s) or size (e.g., 10MB)"}
}

// parseSize parses a size string like "10MB", "1GB", etc.
func parseSize(s string) (int64, error) {
	s = strings.TrimSpace(s)
	s = strings.ToUpper(s)
	
	multipliers := map[string]int64{
		"B":  1,
		"KB": 1024,
		"MB": 1024 * 1024,
		"GB": 1024 * 1024 * 1024,
		"TB": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, mult := range multipliers {
		if strings.HasSuffix(s, suffix) {
			numStr := strings.TrimSuffix(s, suffix)
			var num float64
			if _, err := fmt.Sscanf(numStr, "%f", &num); err != nil {
				return 0, err
			}
			return int64(num * float64(mult)), nil
		}
	}
	
	return 0, fmt.Errorf("unknown size suffix")
}

// parseViaClause parses a "via=" clause.
func (p *Parser) parseViaClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected via URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ViaClause{URL: tok.value}, nil
}

// parseInsecureClause parses an "insecure=" clause.
func (p *Parser) parseInsecureClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected insecure value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "true" && value != "false" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "insecure accepts only 'true' or 'false'"}
	}
	
	return types.InsecureClause{Value: value == "true"}, nil
}

----
internal/planner/plan.go
// Package planner applies defaults, validates commands, and produces execution plans.
package planner

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// ExecutionPlan represents a fully resolved execution plan ready for HTTP runtime.
type ExecutionPlan struct {
	Verb        types.Verb         `json:"verb"`
	Method      string             `json:"method"`
	URL         string             `json:"url"`
	Headers     map[string]string  `json:"headers,omitempty"`
	QueryParams map[string]string  `json:"query_params,omitempty"`
	Cookies     map[string]string  `json:"cookies,omitempty"`
	Body        *BodyPlan          `json:"body,omitempty"`
	Output      *OutputPlan        `json:"output,omitempty"`
	Retry       *RetryPlan         `json:"retry,omitempty"`
	Timeout     *time.Duration    `json:"timeout,omitempty"`
	SizeLimit   *int64            `json:"size_limit,omitempty"`
	Proxy       string             `json:"proxy,omitempty"`
	Insecure    bool               `json:"insecure,omitempty"`
	Verbose     bool               `json:"verbose,omitempty"`
	Resume      bool               `json:"resume,omitempty"`
	Follow      string             `json:"follow,omitempty"` // "smart" or empty
	Expect      []types.ExpectCheck `json:"expect,omitempty"`
}

// BodyPlan represents the request body configuration.
type BodyPlan struct {
	Type     string                `json:"type"` // json, form, multipart, raw
	Content  string                `json:"content,omitempty"`
	FilePath string                `json:"file_path,omitempty"`
	Field    string                `json:"field,omitempty"` // for multipart
	AttachParts []types.AttachPart `json:"attach_parts,omitempty"` // for multipart
	Boundary string                `json:"boundary,omitempty"` // for multipart
}

// OutputPlan represents the output configuration.
type OutputPlan struct {
	Format      string `json:"format"` // json, csv, text, raw
	Destination string `json:"destination,omitempty"`
	Pick        string `json:"pick,omitempty"` // JSONPath expression
}

// RetryPlan represents retry configuration.
type RetryPlan struct {
	Count  int           `json:"count"`
	Backoff BackoffRange `json:"backoff"`
}

// BackoffRange represents a backoff range with min and max durations.
type BackoffRange struct {
	Min time.Duration `json:"min"`
	Max time.Duration `json:"max"`
}

// Plan creates an ExecutionPlan from a parsed Command.
func Plan(cmd *types.Command) (*ExecutionPlan, error) {
	plan := &ExecutionPlan{
		Verb:        cmd.Verb,
		URL:         cmd.Target.URL,
		Headers:     make(map[string]string),
		QueryParams: make(map[string]string),
		Cookies:     make(map[string]string),
	}

	// Apply verb-specific defaults
	if err := applyVerbDefaults(cmd.Verb, plan); err != nil {
		return nil, err
	}

	// Process clauses
	for _, clause := range cmd.Clauses {
		if err := applyClause(clause, plan, cmd.Verb); err != nil {
			return nil, err
		}
	}

	// Post-process: extract filename for save verb if destination not provided or is a directory
	if cmd.Verb == types.VerbSave && plan.Output != nil {
		if plan.Output.Destination == "" {
			// No destination provided, extract from URL
			filename := extractFilenameFromURL(plan.URL)
			if filename != "" {
				plan.Output.Destination = filename
			}
		} else {
			// Destination provided - check if it's a directory
			if isDirectory(plan.Output.Destination) {
				// It's a directory, append filename from URL
				filename := extractFilenameFromURL(plan.URL)
				if filename != "" {
					plan.Output.Destination = filepath.Join(plan.Output.Destination, filename)
				}
			}
			// If it's a file path (like /tmp/file.zip), use it as-is
		}
	}

	// Validate plan
	if err := validatePlan(plan); err != nil {
		return nil, err
	}

	return plan, nil
}

// applyVerbDefaults applies default settings based on the verb.
func applyVerbDefaults(verb types.Verb, plan *ExecutionPlan) error {
	switch verb {
	case types.VerbRead:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSave:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "raw"}
	case types.VerbSend:
		// Default to GET, will be changed to POST if with= is present
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbUpload:
		// Default to POST, but will error if no attach= or with= present
		plan.Method = http.MethodPost
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbWatch:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbInspect:
		plan.Method = http.MethodHead
		plan.Output = &OutputPlan{Format: "json"}
	case types.VerbAuthenticate:
		// Default to POST if with= is present, otherwise require using=
		// We'll check this in validatePlan
		plan.Method = http.MethodPost // tentative, may be overridden
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSession:
		// Session verbs are handled separately in main
		plan.Method = http.MethodGet // placeholder
		plan.Output = &OutputPlan{Format: "auto"}
	default:
		return fmt.Errorf("unsupported verb: %s", verb)
	}
	return nil
}

// validateUsingClause validates that the HTTP method is compatible with the verb.
func validateUsingClause(verb types.Verb, method string) error {
	allowedMethods := map[types.Verb][]string{
		types.VerbRead:    {"GET", "HEAD", "OPTIONS"},
		types.VerbSave:    {"GET", "POST"},
		types.VerbSend:   {"POST", "PUT", "PATCH"},
		types.VerbUpload: {"POST", "PUT"},
		types.VerbWatch:  {"GET"},
		types.VerbInspect: {"HEAD", "GET", "OPTIONS"},
	}
	
	allowed, ok := allowedMethods[verb]
	if !ok {
		// If verb not in map, allow any method (for future verbs like delete)
		return nil
	}
	
	for _, allowedMethod := range allowed {
		if method == allowedMethod {
			return nil
		}
	}
	
	return fmt.Errorf("verb '%s' is incompatible with method '%s'", verb, method)
}

// applyClause applies a clause to the execution plan.
func applyClause(clause types.Clause, plan *ExecutionPlan, verb types.Verb) error {
	switch c := clause.(type) {
	case types.UsingClause:
		// Validate compatibility before applying
		if err := validateUsingClause(verb, c.Method); err != nil {
			return err
		}
		// Normalize to uppercase (defensive, should already be normalized in parser)
		plan.Method = strings.ToUpper(c.Method)
	case types.HeadersClause:
		for k, v := range c.Headers {
			plan.Headers[k] = v
		}
	case types.ParamsClause:
		for k, v := range c.Params {
			plan.QueryParams[k] = v
		}
	case types.WithClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		
		// Handle file or stdin
		if c.IsFile {
			plan.Body.FilePath = c.Value
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for files
			}
		} else if c.IsStdin {
			plan.Body.FilePath = "-" // Special marker for stdin
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for stdin
			}
		} else {
			plan.Body.Content = c.Value
			plan.Body.Type = c.Type
			// If type was inferred as JSON, we'll note it in runtime
			if plan.Body.Type == "json" {
				// JSON inference will be logged in runtime
			}
		}
		
		// If method is still GET and we have a body, default to POST
		if plan.Method == http.MethodGet {
			plan.Method = http.MethodPost
		}
	case types.AsClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Format = c.Format
	case types.ToClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Destination = c.Destination
	case types.RetryClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{
				Backoff: BackoffRange{
					Min: 200 * time.Millisecond,
					Max: 5 * time.Second,
				},
			}
		}
		plan.Retry.Count = c.Count
	case types.BackoffClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{Count: 3}
		}
		plan.Retry.Backoff = BackoffRange{
			Min: c.Min,
			Max: c.Max,
		}
	case types.TimeoutClause:
		plan.Timeout = &c.Duration
	case types.ProxyClause:
		plan.Proxy = c.URL
	case types.PickClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Pick = c.Path
	case types.InsecureClause:
		plan.Insecure = c.Value
	case types.ViaClause:
		plan.Proxy = c.URL
	case types.IncludeClause:
		// Merge include items into headers, params, or cookies
		for _, item := range c.Items {
			switch item.Type {
			case "header":
				// For multi-valued headers, we'd need to track arrays, but for now last wins
				// TODO: Support multi-valued headers properly
				plan.Headers[item.Name] = item.Value
			case "param":
				// Params can be repeated, so we append to query params
				// The runtime will handle serialization
				plan.QueryParams[item.Name] = item.Value
			case "cookie":
				// Cookies: last value wins
				plan.Cookies[item.Name] = item.Value
			}
		}
	case types.AttachClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		plan.Body.Type = "multipart"
		plan.Body.AttachParts = c.Parts
		if c.Boundary != "" {
			plan.Body.Boundary = c.Boundary
		}
	case types.ExpectClause:
		plan.Expect = c.Checks
	case types.FollowClause:
		plan.Follow = c.Policy
	case types.UnderClause:
		if c.IsSize {
			plan.SizeLimit = &c.Size
		} else {
			plan.Timeout = &c.Duration
		}
	case types.VerboseClause:
		plan.Verbose = true
	case types.ResumeClause:
		plan.Resume = true
	default:
		return fmt.Errorf("unsupported clause type: %T", clause)
	}
	return nil
}

// validatePlan validates the execution plan.
func validatePlan(plan *ExecutionPlan) error {
	if plan.Method == "" {
		return fmt.Errorf("method is required")
	}
	if plan.URL == "" {
		return fmt.Errorf("URL is required")
	}
	
	// Validate upload verb: must have attach= or with=
	// This check will be done after clauses are processed, so we check here
	// Actually, we need to check this in Plan() after processing clauses
	// For now, we'll do basic validation
	
	return nil
}

// extractFilenameFromURL extracts a filename from a URL.
func extractFilenameFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Get the path
	path := u.Path
	if path == "" || path == "/" {
		// Try to get from query or fragment
		return "download"
	}

	// Remove leading slash
	path = strings.TrimPrefix(path, "/")

	// Get the last segment
	parts := strings.Split(path, "/")
	if len(parts) == 0 {
		return "download"
	}

	filename := parts[len(parts)-1]

	// URL decode the filename (handle both path and query encoding)
	filename, err = url.PathUnescape(filename)
	if err != nil {
		// If PathUnescape fails, try QueryUnescape
		filename, err = url.QueryUnescape(filename)
		if err != nil {
			// If decoding fails, use the original
			filename = parts[len(parts)-1]
		}
	}

	// If filename is empty or doesn't have an extension, use a default
	if filename == "" || !strings.Contains(filename, ".") {
		filename = "download"
	}

	// Clean the filename (remove any path separators)
	filename = filepath.Base(filename)

	return filename
}

// isDirectory checks if a path is a directory.
func isDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}


----
internal/runtime/executor.go
// Package runtime executes HTTP requests based on execution plans.
package runtime

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
	"github.com/adammpkins/req/internal/session"
)

// Executor executes HTTP requests.
type Executor struct {
	client *http.Client
}

// NewExecutor creates a new executor.
func NewExecutor(plan *planner.ExecutionPlan) (*Executor, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create cookie jar: %w", err)
	}

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{},
	}

	// Configure TLS if insecure
	if plan.Insecure {
		transport.TLSClientConfig = getInsecureTLSConfig()
		fmt.Fprintf(os.Stderr, "Warning: TLS verification disabled\n")
	}

	// Configure proxy if specified
	if plan.Proxy != "" {
		proxyURL, err := url.Parse(plan.Proxy)
		if err != nil {
			return nil, fmt.Errorf("invalid proxy URL: %w", err)
		}
		transport.Proxy = http.ProxyURL(proxyURL)
	}

	client := &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
		Jar:       jar,
	}

	if plan.Timeout != nil {
		client.Timeout = *plan.Timeout
	}

	return &Executor{client: client}, nil
}

// Execute executes an HTTP request based on the plan.
func (e *Executor) Execute(plan *planner.ExecutionPlan) error {
	// Build request URL with query parameters (preserving order)
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("invalid URL: %v", err)}
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to build body: %v", err)}
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to create request: %v", err)}
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Auto-apply session if available and not explicitly set
	e.autoApplySession(req, plan)

	// Add Accept-Encoding if not set by user
	if req.Header.Get("Accept-Encoding") == "" {
		req.Header.Set("Accept-Encoding", "gzip, br")
	}

	// Execute request with redirect handling
	resp, redirectTrace, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
	}
	defer resp.Body.Close()

	// Print redirect trace to stderr
	if len(redirectTrace) > 0 {
		for _, trace := range redirectTrace {
			fmt.Fprintf(os.Stderr, "%s\n", trace)
		}
	}

	// Read and decompress response body
	bodyBytes, decompressed, err := e.readAndDecompress(resp)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("failed to read response: %v", err)}
	}

	if decompressed {
		fmt.Fprintf(os.Stderr, "Decompressed response\n")
	}

	// Print meta to stderr
	e.printMeta(resp, reqURL, len(bodyBytes), decompressed)

	// Capture session for authenticate verb
	if plan.Verb == types.VerbAuthenticate {
		host, err := session.ExtractHost(plan.URL)
		if err == nil {
			setCookies := resp.Header.Values("Set-Cookie")
			updatedSession, err := session.UpdateSessionFromResponse(host, setCookies, bodyBytes)
			if err == nil && updatedSession != nil {
				if err := session.SaveSession(updatedSession); err == nil {
					fmt.Fprintf(os.Stderr, "Session saved for %s\n", host)
				}
			}
		}
	}

	// Run expect checks
	if len(plan.Expect) > 0 {
		if err := e.runExpectChecks(resp, bodyBytes, plan.Expect); err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			return &ExecutionError{Code: 3, Message: "expectation failed"}
		}
	} else {
		// If no expect checks, fail on non-2xx status codes
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("HTTP %d %s", resp.StatusCode, resp.Status)}
		}
	}

	// Handle output based on plan
	if plan.Output != nil && plan.Output.Destination != "" {
		// Save to file - uses io.Copy for efficient writing
		// TODO: Optimize to stream directly from resp.Body when no expect checks
		return e.saveToFile(bytes.NewReader(bodyBytes), plan.Output.Destination)
	}

	// Handle watch verb with TTY detection
	if plan.Verb == types.VerbWatch {
		// TODO: Implement TTY detection
		// TTY: timestamped lines
		// Non-TTY: raw lines
		return e.writeOutput(bodyBytes, plan.Output)
	}

	// Format and write output
	return e.writeOutput(bodyBytes, plan.Output)
}

// ExecutionError represents an execution error with exit code.
type ExecutionError struct {
	Code    int
	Message string
}

func (e *ExecutionError) Error() string {
	return e.Message
}

// buildURL builds the request URL with query parameters, preserving order.
func (e *Executor) buildURL(plan *planner.ExecutionPlan) (string, error) {
	u, err := url.Parse(plan.URL)
	if err != nil {
		return "", err
	}

	// Merge existing query params with new ones
	existingParams := u.Query()
	for k, v := range plan.QueryParams {
		// Append to preserve order for repeated keys
		existingParams.Add(k, v)
	}
	u.RawQuery = existingParams.Encode()

	return u.String(), nil
}

// buildBody builds the request body.
func (e *Executor) buildBody(plan *planner.ExecutionPlan) (io.Reader, string, error) {
	if plan.Body == nil {
		return nil, "", nil
	}

	// Handle multipart
	if plan.Body.Type == "multipart" {
		return e.buildMultipartBody(plan.Body)
	}

	// Handle file or stdin
	if plan.Body.FilePath != "" {
		if plan.Body.FilePath == "-" {
			// Read from stdin
			data, err := io.ReadAll(os.Stdin)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read stdin: %w", err)
			}
			plan.Body.Content = string(data)
		} else {
			// Read from file
			data, err := os.ReadFile(plan.Body.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", plan.Body.FilePath, err)
			}
			plan.Body.Content = string(data)
		}
	}

	// Determine content type
	contentType := ""
	if plan.Body.Type == "json" {
		contentType = "application/json"
		// Log JSON inference if it was inferred
		if strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "{") || strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "[") {
			fmt.Fprintf(os.Stderr, "Inferred Content-Type: application/json\n")
		}
	} else if plan.Body.Type == "form" {
		contentType = "application/x-www-form-urlencoded"
	}

	return strings.NewReader(plan.Body.Content), contentType, nil
}

// buildMultipartBody builds a multipart/form-data body.
func (e *Executor) buildMultipartBody(bodyPlan *planner.BodyPlan) (io.Reader, string, error) {
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	boundary := bodyPlan.Boundary
	if boundary == "" {
		boundary = writer.Boundary()
	} else {
		writer.SetBoundary(boundary)
	}

	for _, part := range bodyPlan.AttachParts {
		var partWriter io.Writer
		var err error

		// Create form field
		if part.Filename != "" {
			partWriter, err = writer.CreateFormFile(part.Name, part.Filename)
		} else {
			partWriter, err = writer.CreateFormField(part.Name)
		}
		if err != nil {
			return nil, "", fmt.Errorf("failed to create form field: %w", err)
		}

		// Write part content
		if part.FilePath != "" {
			// Read file
			data, err := os.ReadFile(part.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", part.FilePath, err)
			}
			if _, err := partWriter.Write(data); err != nil {
				return nil, "", fmt.Errorf("failed to write file data: %w", err)
			}
		} else {
			// Write value
			if _, err := partWriter.Write([]byte(part.Value)); err != nil {
				return nil, "", fmt.Errorf("failed to write value: %w", err)
			}
		}
	}

	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
	return &buf, contentType, nil
}

// setHeaders sets request headers.
func (e *Executor) setHeaders(req *http.Request, plan *planner.ExecutionPlan, contentType string) {
	// Set user headers first
	for k, v := range plan.Headers {
		req.Header.Set(k, v)
	}

	// Override Content-Type if multipart (user may have set it manually)
	if plan.Body != nil && plan.Body.Type == "multipart" {
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
			// Check if user had set Content-Type manually
			if _, wasSet := plan.Headers["Content-Type"]; wasSet {
				fmt.Fprintf(os.Stderr, "Note: Content-Type overridden for multipart\n")
			}
		}
	} else if contentType != "" && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", contentType)
	}
}

// setCookies sets request cookies.
func (e *Executor) setCookies(req *http.Request, plan *planner.ExecutionPlan) {
	for name, value := range plan.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}
}

// autoApplySession automatically applies a stored session if available.
func (e *Executor) autoApplySession(req *http.Request, plan *planner.ExecutionPlan) {
	// Don't auto-apply if Authorization or Cookie headers are explicitly set
	hasAuth := req.Header.Get("Authorization") != ""
	hasCookie := false
	for name := range plan.Cookies {
		if name != "" {
			hasCookie = true
			break
		}
	}
	if hasAuth || hasCookie {
		return
	}

	// Extract host from URL
	host, err := session.ExtractHost(plan.URL)
	if err != nil {
		return
	}

	// Load session
	sess, err := session.LoadSession(host)
	if err != nil || sess == nil {
		return
	}

	// Apply authorization if available
	if sess.Authorization != "" {
		req.Header.Set("Authorization", sess.Authorization)
	}

	// Apply cookies
	for name, value := range sess.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}

	fmt.Fprintf(os.Stderr, "Using session for %s\n", host)
}

// executeWithRedirects executes the request with redirect handling.
func (e *Executor) executeWithRedirects(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, error) {
	maxRedirects := 5
	var redirectTrace []string

	// Determine redirect policy based on verb
	shouldFollow := false
	isWriteVerb := plan.Method == "POST" || plan.Method == "PUT" || plan.Method == "PATCH" || plan.Method == "DELETE"

	if plan.Follow == "smart" {
		// Smart follow: only follow 307/308 for write verbs
		shouldFollow = true
	} else {
		// Default: read and save follow, write verbs don't
		if plan.Verb == types.VerbRead || plan.Verb == types.VerbSave {
			shouldFollow = true
		} else if isWriteVerb {
			shouldFollow = false
		} else {
			// Other verbs (watch, inspect) don't follow by default
			shouldFollow = false
		}
	}

	if !shouldFollow {
		resp, err := e.client.Do(req)
		if err == nil && isWriteVerb && (resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303) {
			redirectTrace = append(redirectTrace, fmt.Sprintf("Advisory: %d redirect for write verb, not following", resp.StatusCode))
		}
		return resp, redirectTrace, err
	}

	// Follow redirects
	redirects := 0
	client := *e.client
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if redirects >= maxRedirects {
			return fmt.Errorf("stopped after %d redirects", maxRedirects)
		}

		// For smart follow with write verbs, only follow 307/308
		if plan.Follow == "smart" && isWriteVerb {
			statusCode := via[len(via)-1].Response.StatusCode
			if statusCode != 307 && statusCode != 308 {
				return fmt.Errorf("write verb: not following %d redirect (use 307/308)", statusCode)
			}
		}

		redirects++
		statusCode := via[len(via)-1].Response.StatusCode
		redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", statusCode, req.Method, req.URL.String()))
		return nil
	}

	resp, err := client.Do(req)
	return resp, redirectTrace, err
}

// readAndDecompress reads and decompresses the response body.
func (e *Executor) readAndDecompress(resp *http.Response) ([]byte, bool, error) {
	body := resp.Body
	decompressed := false

	// Check if compressed
	encoding := resp.Header.Get("Content-Encoding")
	if encoding == "gzip" {
		reader, err := gzip.NewReader(body)
		if err != nil {
			return nil, false, fmt.Errorf("failed to create gzip reader: %w", err)
		}
		defer reader.Close()
		body = reader
		decompressed = true
	} else if encoding == "br" {
		// Brotli decompression would require a library
		// For now, just read as-is
		// TODO: Add brotli support
	}

	data, err := io.ReadAll(body)
	return data, decompressed, err
}

// runExpectChecks runs expectation checks on the response.
func (e *Executor) runExpectChecks(resp *http.Response, body []byte, checks []types.ExpectCheck) error {
	for _, check := range checks {
		if err := e.runExpectCheck(resp, body, check); err != nil {
			return err
		}
	}
	return nil
}

// runExpectCheck runs a single expectation check.
func (e *Executor) runExpectCheck(resp *http.Response, body []byte, check types.ExpectCheck) error {
	switch check.Type {
	case "status":
		expected := check.Value
		actual := fmt.Sprintf("%d", resp.StatusCode)
		if actual != expected {
			return fmt.Errorf("expected status %s, got %s", expected, actual)
		}

	case "header":
		actual := resp.Header.Get(check.Name)
		if actual != check.Value {
			return fmt.Errorf("expected header %s=%s, got %s", check.Name, check.Value, actual)
		}

	case "contains":
		if !strings.Contains(string(body), check.Value) {
			return fmt.Errorf("expected body to contain %q", check.Value)
		}

	case "jsonpath":
		// Simple JSON path extraction (basic implementation)
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			return fmt.Errorf("failed to parse JSON: %w", err)
		}
		// TODO: Implement proper JSONPath evaluation
		// For now, just check if JSON is valid
		_ = data

	case "matches":
		matched, err := regexp.MatchString(check.Regex, string(body))
		if err != nil {
			return fmt.Errorf("invalid regex: %w", err)
		}
		if !matched {
			return fmt.Errorf("body does not match regex %q", check.Regex)
		}

	default:
		return fmt.Errorf("unknown expect check type: %s", check.Type)
	}

	return nil
}

// printMeta prints metadata to stderr.
func (e *Executor) printMeta(resp *http.Response, url string, bodySize int, decompressed bool) {
	fmt.Fprintf(os.Stderr, "HTTP %d\n", resp.StatusCode)
	fmt.Fprintf(os.Stderr, "URL: %s\n", url)
	fmt.Fprintf(os.Stderr, "Size: %d bytes\n", bodySize)
	if ct := resp.Header.Get("Content-Type"); ct != "" {
		fmt.Fprintf(os.Stderr, "Content-Type: %s\n", ct)
	}
}

// writeOutput formats and writes output to stdout.
func (e *Executor) writeOutput(body []byte, output *planner.OutputPlan) error {
	if output == nil {
		// Default: raw output
		_, err := os.Stdout.Write(body)
		return err
	}

	switch output.Format {
	case "json":
		// Pretty print JSON
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			// Not JSON, output as-is
			_, err := os.Stdout.Write(body)
			return err
		}
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)

	case "text":
		// Output as text
		_, err := os.Stdout.Write(body)
		return err

	case "raw":
		// Raw output
		_, err := os.Stdout.Write(body)
		return err

	case "csv":
		// CSV output (basic - would need proper CSV parsing)
		_, err := os.Stdout.Write(body)
		return err

	default:
		// Default: raw
		_, err := os.Stdout.Write(body)
		return err
	}
}

// saveToFile saves the response body to a file.
func (e *Executor) saveToFile(body io.Reader, destination string) error {
	// Create directory if needed
	dir := filepath.Dir(destination)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Create file
	file, err := os.Create(destination)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Copy response body to file
	_, err = io.Copy(file, body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// getInsecureTLSConfig returns an insecure TLS config.
func getInsecureTLSConfig() *tls.Config {
	return &tls.Config{
		InsecureSkipVerify: true,
	}
}

// ExecuteWithResponse executes an HTTP request and returns the response body as a string.
// This is useful for TUI mode where we need to capture and format the response.
func (e *Executor) ExecuteWithResponse(plan *planner.ExecutionPlan) (string, error) {
	// Build request URL with query parameters
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return "", fmt.Errorf("failed to build body: %w", err)
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Execute request
	resp, _, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and decompress response body
	bodyBytes, _, err := e.readAndDecompress(resp)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(bodyBytes), nil
}

----
internal/session/session.go
// Package session manages HTTP sessions (cookies and tokens) per host.
package session

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Session represents a stored session for a host.
type Session struct {
	Host          string            `json:"host"`
	Cookies       map[string]string `json:"cookies,omitempty"`
	Authorization string            `json:"authorization,omitempty"` // Bearer token
}

var (
	stateDir     string
	stateDirOnce sync.Once
)

// getStateDir returns the user state directory for storing sessions.
func getStateDir() string {
	stateDirOnce.Do(func() {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to current directory
			stateDir = ".req"
			return
		}
		stateDir = filepath.Join(homeDir, ".config", "req")
	})
	return stateDir
}

// ensureStateDir ensures the state directory exists with proper permissions.
func ensureStateDir() error {
	dir := getStateDir()
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}
	return nil
}

// getSessionPath returns the file path for a host's session.
func getSessionPath(host string) (string, error) {
	if err := ensureStateDir(); err != nil {
		return "", err
	}
	// Sanitize host name for filename
	safeHost := strings.ReplaceAll(host, ":", "_")
	safeHost = strings.ReplaceAll(safeHost, "/", "_")
	return filepath.Join(getStateDir(), fmt.Sprintf("session_%s.json", safeHost)), nil
}

// LoadSession loads a session for the given host.
func LoadSession(host string) (*Session, error) {
	path, err := getSessionPath(host)
	if err != nil {
		return nil, err
	}

	// Check file permissions - refuse to load if group or world readable
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // No session exists
		}
		return nil, fmt.Errorf("failed to stat session file: %w", err)
	}

	mode := info.Mode().Perm()
	// Check if group or others have read permission (044, 004, or any combination)
	if mode&0044 != 0 {
		return nil, fmt.Errorf("session file %s has insecure permissions (%s): group or world readable, refusing to load", path, mode.String())
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read session: %w", err)
	}

	var session Session
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, fmt.Errorf("failed to parse session: %w", err)
	}

	return &session, nil
}

// SaveSession saves a session for the given host.
func SaveSession(session *Session) error {
	path, err := getSessionPath(session.Host)
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal session: %w", err)
	}

	// Write with strict permissions (0600)
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write session: %w", err)
	}

	return nil
}

// DeleteSession deletes a session for the given host.
func DeleteSession(host string) error {
	path, err := getSessionPath(host)
	if err != nil {
		return err
	}

	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil // Already deleted
		}
		return fmt.Errorf("failed to delete session: %w", err)
	}

	return nil
}

// ExtractHost extracts the host from a URL.
func ExtractHost(urlStr string) (string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}
	return u.Host, nil
}

// UpdateSessionFromResponse updates a session from an HTTP response.
// Captures Set-Cookie headers and access_token from JSON body.
func UpdateSessionFromResponse(host string, setCookies []string, body []byte) (*Session, error) {
	session, err := LoadSession(host)
	if err != nil {
		return nil, err
	}

	if session == nil {
		session = &Session{
			Host:    host,
			Cookies: make(map[string]string),
		}
	}

	// Parse Set-Cookie headers
	for _, cookieHeader := range setCookies {
		// Simple cookie parsing (just get name=value part)
		parts := strings.Split(cookieHeader, ";")
		if len(parts) > 0 {
			cookiePart := strings.TrimSpace(parts[0])
			eqIdx := strings.Index(cookiePart, "=")
			if eqIdx > 0 {
				name := cookiePart[:eqIdx]
				value := cookiePart[eqIdx+1:]
				session.Cookies[name] = value
			}
		}
	}

	// Try to extract access_token from JSON body
	if len(body) > 0 {
		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err == nil {
			if token, ok := jsonData["access_token"].(string); ok && token != "" {
				session.Authorization = "Bearer " + token
			}
		}
	}

	return session, nil
}

// ListSessions lists all stored sessions.
func ListSessions() ([]string, error) {
	dir := getStateDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read state directory: %w", err)
	}

	var hosts []string
	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "session_") && strings.HasSuffix(entry.Name(), ".json") {
			// Extract host from filename
			host := strings.TrimPrefix(entry.Name(), "session_")
			host = strings.TrimSuffix(host, ".json")
			host = strings.ReplaceAll(host, "_", ":")
			hosts = append(hosts, host)
		}
	}

	return hosts, nil
}

// RedactSession creates a redacted version of a session for display.
func RedactSession(session *Session) *Session {
	redacted := &Session{
		Host:          session.Host,
		Cookies:       make(map[string]string),
		Authorization: "",
	}

	// Redact cookies (show only names)
	for name := range session.Cookies {
		redacted.Cookies[name] = "***"
	}

	// Redact authorization
	if session.Authorization != "" {
		redacted.Authorization = "Bearer ***"
	}

	return redacted
}


----
internal/tui/app.go
// Package tui provides an interactive terminal user interface for req.
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/adammpkins/req/internal/tui/views"
)

// Launch starts the TUI application.
func Launch() error {
	p := tea.NewProgram(NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run TUI: %w", err)
	}
	return nil
}

// Model represents the application state.
type Model struct {
	view View
}

// NewModel creates a new TUI model.
func NewModel() Model {
	return Model{
		view: views.NewBuilderView(),
	}
}

// Init initializes the model.
func (m Model) Init() tea.Cmd {
	// WindowSizeMsg will be sent automatically by bubbletea
	return m.view.Init()
}

// Update handles messages and updates the model.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		// Pass window size to view
		var cmd tea.Cmd
		m.view, cmd = m.view.Update(msg)
		return m, cmd
	}

	var cmd tea.Cmd
	m.view, cmd = m.view.Update(msg)
	return m, cmd
}

// View renders the current view.
func (m Model) View() string {
	return m.view.View()
}

// View represents a TUI view (exported from views package).
type View = views.View


----
internal/tui/views/builder.go
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("62")).
			Padding(1, 2)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Padding(1, 2).
			Width(80)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46")).
			Padding(1, 2).
			Width(80)

	commandStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252")).
			Padding(1, 2).
			Width(80)

	// JSON syntax highlighting styles
	jsonKeyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true)

	jsonStringStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46"))

	jsonNumberStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("220"))

	jsonBoolStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("213"))

	jsonNullStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			Italic(true)

	jsonPunctStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252"))

	outputStyle = lipgloss.NewStyle().
			Padding(1, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("62"))
)

// View represents a TUI view interface.
type View interface {
	Init() tea.Cmd
	Update(msg tea.Msg) (View, tea.Cmd)
	View() string
}

// BuilderView is an interactive command builder.
type BuilderView struct {
	form         *huh.Form
	executed     bool
	response     string
	responseBody string
	formattedBody string
	err          error
	verb         string
	url          string
	execute      bool
	width        int
	height       int
	viewport     viewport.Model
}

// NewBuilderView creates a new builder view.
func NewBuilderView() View {
	vp := viewport.New(80, 20) // default width and height
	b := &BuilderView{
		width:    80, // default width
		height:   20, // default height
		viewport: vp,
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Verb").
				Description("Select the action to perform").
				Options(
					huh.NewOption("read - Read a resource (GET)", "read"),
					huh.NewOption("save - Save a resource to file (GET)", "save"),
					huh.NewOption("send - Send data (POST)", "send"),
				).
				Value(&b.verb).
				Key("verb"),

			huh.NewInput().
				Title("URL").
				Description("Enter the target URL").
				Placeholder("https://api.example.com/users").
				Value(&b.url).
				Key("url"),

			huh.NewConfirm().
				Title("Execute immediately?").
				Description("Execute the command when form is complete").
				Value(&b.execute).
				Key("execute"),
		),
	)

	b.form = form
	return b
}

// Init initializes the view.
func (b *BuilderView) Init() tea.Cmd {
	return b.form.Init()
}

// Update handles messages.
func (b *BuilderView) Update(msg tea.Msg) (View, tea.Cmd) {
	var cmds []tea.Cmd

	// Handle window size messages first
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		b.width = msg.Width
		b.height = msg.Height
		if b.width == 0 {
			b.width = 80 // default width
		}
		if b.height == 0 {
			b.height = 20 // default height
		}
		// Update viewport size
		b.updateViewportSize()
	}

	// Handle keyboard input
	switch msg := msg.(type) {
	case tea.KeyMsg:
		key := msg.String()
		
		// If we have output to scroll, handle scrolling keys first
		if b.formattedBody != "" {
			// Check if it's a scrolling key
			switch key {
			case "up", "k", "pgup":
				b.viewport.LineUp(1)
				return b, nil
			case "down", "j", "pgdown":
				b.viewport.LineDown(1)
				return b, nil
			case "home":
				b.viewport.GotoTop()
				return b, nil
			case "end":
				b.viewport.GotoBottom()
				return b, nil
			case "ctrl+u":
				b.viewport.LineUp(b.viewport.Height / 2)
				return b, nil
			case "ctrl+d":
				b.viewport.LineDown(b.viewport.Height / 2)
				return b, nil
			case "esc":
				return b, tea.Quit
			}
		} else {
			// No output, just handle quit
			switch key {
			case "esc":
				return b, tea.Quit
			}
		}
	}

	// Update form (only if not a scrolling key when we have output)
	form, cmd := b.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		b.form = f
		cmds = append(cmds, cmd)
	}

	// Handle messages from command execution
	switch msg := msg.(type) {
	case ErrorMsg:
		b.err = msg.Err
		b.executed = false
		b.responseBody = ""
		b.formattedBody = ""
		b.viewport.SetContent("")
	case SuccessMsg:
		b.response = msg.Message
		b.responseBody = msg.ResponseBody
		b.err = nil
		// Format the response body
		b.updateFormattedBody()
	}
	
	// Handle viewport updates for other messages (like mouse wheel, etc.)
	if b.formattedBody != "" {
		vp, cmd := b.viewport.Update(msg)
		b.viewport = vp
		if cmd != nil {
			cmds = append(cmds, cmd)
		}
	}

	// Check if form is complete and should execute
	if b.form.State == huh.StateCompleted {
		if !b.executed && b.verb != "" && b.url != "" {
			// Values are already bound to b.verb, b.url, and b.execute via Value() in form creation
			// The bound variables are updated automatically when form fields change
			if b.execute {
				b.executed = true
				cmds = append(cmds, b.executeCommand())
			} else {
				// Form completed but execute was false - show message
				b.response = "Command built but not executed. Press 'esc' to exit."
			}
		}
	}

	return b, tea.Batch(cmds...)
}

// executeCommand executes the built command.
func (b *BuilderView) executeCommand() tea.Cmd {
	return func() tea.Msg {
		// Build command string
		cmdStr := fmt.Sprintf("%s %s", b.verb, b.url)
		
		// Parse command
		cmd, err := parser.Parse(cmdStr)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Plan execution
		plan, err := planner.Plan(cmd)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Execute
		executor, err := runtime.NewExecutor(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Capture response body for TUI display
		responseBody, err := executor.ExecuteWithResponse(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		return SuccessMsg{
			Message:      "Command executed successfully",
			ResponseBody: responseBody,
		}
	}
}

// View renders the view.
func (b *BuilderView) View() string {
	var s strings.Builder

	s.WriteString(titleStyle.Render("req - Interactive Command Builder"))
	s.WriteString("\n\n")

	if b.err != nil {
		s.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", b.err)))
		s.WriteString("\n\n")
	}

	if b.response != "" {
		s.WriteString(successStyle.Render(b.response))
		s.WriteString("\n\n")
	}

	// Display response body with formatting (using viewport for scrolling)
	if b.formattedBody != "" {
		// Calculate available width and height for viewport
		contentWidth := b.width - 6 // Account for border and padding
		if contentWidth < 20 {
			contentWidth = 20 // Minimum width
		}
		
		// Calculate available height (account for header, success message, form, command line, instructions)
		// Rough estimate: title ~3, success ~2, form ~varies, command ~2, instructions ~1 = ~8-10 lines
		// Reserve some space for the form and other UI elements
		availableHeight := b.height - 15 // Reserve space for other UI elements
		if availableHeight < 5 {
			availableHeight = 5 // Minimum height
		}
		
		// Update viewport dimensions if needed
		b.updateViewportSize()
		
		// Render viewport with border
		// The viewport handles its own height, so we just need to wrap it with the border style
		viewportContent := b.viewport.View()
		// Use the viewport's actual dimensions for the border
		s.WriteString(outputStyle.Width(contentWidth + 4).Render(viewportContent))
		s.WriteString("\n\n")
	}

	s.WriteString(b.form.View())
	
	// Show current values when form is completed
	if b.form.State == huh.StateCompleted {
		s.WriteString("\n\n")
		if b.verb != "" && b.url != "" {
			cmdText := fmt.Sprintf("Command: %s %s", b.verb, b.url)
			// Wrap the command text to fit terminal width
			width := b.width
			if width == 0 {
				width = 80 // default width
			}
			wrapped := wrapText(cmdText, width)
			s.WriteString(commandStyle.Render(wrapped))
			s.WriteString("\n")
			if b.response != "" {
				s.WriteString("\n")
			}
		}
	}
	
	s.WriteString("\n")
	if b.formattedBody != "" {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit, ↑/↓ to scroll, pgup/pgdn for page scroll\n")
	} else {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit\n")
	}

	return s.String()
}

// ErrorMsg represents an error message.
type ErrorMsg struct {
	Err error
}

// SuccessMsg represents a success message.
type SuccessMsg struct {
	Message      string
	ResponseBody string
}

// wrapText wraps text to the specified width, breaking at word boundaries.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}
	
	var result strings.Builder
	words := strings.Fields(text)
	currentLine := ""
	
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		if len(testLine) > width {
			if currentLine != "" {
				result.WriteString(currentLine)
				result.WriteString("\n")
				currentLine = word
			} else {
				// Word is longer than width, just add it
				result.WriteString(word)
				result.WriteString("\n")
				currentLine = ""
			}
		} else {
			currentLine = testLine
		}
	}
	
	if currentLine != "" {
		result.WriteString(currentLine)
	}
	
	return result.String()
}

// updateFormattedBody formats the response body and updates the viewport content.
func (b *BuilderView) updateFormattedBody() {
	if b.responseBody == "" {
		b.formattedBody = ""
		b.viewport.SetContent("")
		return
	}
	
	// Calculate available width for content
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	// Format the response
	formatted := formatResponse(b.responseBody, contentWidth)
	b.formattedBody = formatted
	
	// Update viewport content
	b.viewport.SetContent(formatted)
	b.viewport.GotoTop() // Start at the top
}

// updateViewportSize updates the viewport dimensions based on available space.
func (b *BuilderView) updateViewportSize() {
	if b.responseBody == "" {
		return
	}
	
	// Calculate available width and height
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	availableHeight := b.height - 15 // Reserve space for other UI elements
	if availableHeight < 5 {
		availableHeight = 5 // Minimum height
	}
	
	// Update viewport dimensions
	b.viewport.Width = contentWidth
	b.viewport.Height = availableHeight
	
	// If content is already set, ensure it's properly sized
	if b.formattedBody != "" {
		b.viewport.SetContent(b.formattedBody)
	}
}

// formatResponse formats the response body with syntax highlighting for JSON.
func formatResponse(body string, width int) string {
	// Try to parse as JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(body), &jsonData); err == nil {
		// It's valid JSON, format it with syntax highlighting
		return formatJSON(body, width)
	}

	// Not JSON, return as-is with word wrapping
	return wrapText(body, width)
}

// formatJSON formats JSON with syntax highlighting using lipgloss.
func formatJSON(jsonStr string, width int) string {
	// First, pretty-print the JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(jsonStr), &jsonData); err != nil {
		return jsonStr // Return original if parsing fails
	}

	prettyJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return jsonStr // Return original if formatting fails
	}

	// Now apply syntax highlighting
	lines := strings.Split(string(prettyJSON), "\n")
	var formattedLines []string

	for _, line := range lines {
		formattedLine := highlightJSONLine(line)
		formattedLines = append(formattedLines, formattedLine)
	}

	return strings.Join(formattedLines, "\n")
}

// highlightJSONLine applies syntax highlighting to a single line of JSON.
func highlightJSONLine(line string) string {
	// This is a simple JSON highlighter that handles common cases
	// For a more robust solution, consider using a proper JSON tokenizer
	
	result := ""
	i := 0
	
	for i < len(line) {
		char := line[i]
		
		// Skip whitespace
		if char == ' ' || char == '\t' {
			result += string(char)
			i++
			continue
		}
		
		// Handle string literals
		if char == '"' {
			end := i + 1
			escaped := false
			for end < len(line) {
				if line[end] == '\\' && !escaped {
					escaped = true
					end++
				} else if line[end] == '"' && !escaped {
					end++
					// Check if this is a key (followed by :)
					isKey := end < len(line) && line[end] == ':'
					str := line[i:end]
					if isKey {
						result += jsonKeyStyle.Render(str)
					} else {
						result += jsonStringStyle.Render(str)
					}
					i = end
					break
				} else {
					escaped = false
					end++
				}
			}
			if end >= len(line) {
				// Unterminated string, just add it
				result += jsonStringStyle.Render(line[i:])
				break
			}
			continue
		}
		
		// Handle numbers
		if (char >= '0' && char <= '9') || char == '-' {
			start := i
			for i < len(line) && ((line[i] >= '0' && line[i] <= '9') || 
				line[i] == '.' || line[i] == 'e' || line[i] == 'E' || 
				line[i] == '+' || line[i] == '-' || line[i] == 'i' || 
				line[i] == 'n' || line[i] == 'f') {
				i++
			}
			result += jsonNumberStyle.Render(line[start:i])
			continue
		}
		
		// Handle boolean and null
		if strings.HasPrefix(line[i:], "true") {
			result += jsonBoolStyle.Render("true")
			i += 4
			continue
		}
		if strings.HasPrefix(line[i:], "false") {
			result += jsonBoolStyle.Render("false")
			i += 5
			continue
		}
		if strings.HasPrefix(line[i:], "null") {
			result += jsonNullStyle.Render("null")
			i += 4
			continue
		}
		
		// Handle punctuation
		if char == '{' || char == '}' || char == '[' || char == ']' || 
		   char == ',' || char == ':' {
			result += jsonPunctStyle.Render(string(char))
			i++
			continue
		}
		
		// Default: just add the character
		result += string(char)
		i++
	}
	
	return result
}

----
internal/types/command.go
// Package types provides shared types and enums used across the req package.
package types

import "time"

// Verb represents the action verb in a req command.
type Verb string

const (
	VerbRead         Verb = "read"
	VerbSave         Verb = "save"
	VerbSend         Verb = "send"
	VerbUpload       Verb = "upload"
	VerbWatch        Verb = "watch"
	VerbInspect      Verb = "inspect"
	VerbAuthenticate Verb = "authenticate"
	VerbSession      Verb = "session"
)

// Command represents a parsed req command AST.
type Command struct {
	Verb    Verb
	Target  Target
	Clauses []Clause
	// For session verb, subcommand (show, clear, use)
	SessionSubcommand string
}

// Target represents the URL or resource being acted upon.
type Target struct {
	URL string
}

// Clause represents a modifier clause in the command.
// This is a sum type that will be expanded as we add more clause types.
type Clause interface {
	clause()
}

// WithClause represents a "with=" clause for request body.
type WithClause struct {
	Value    string // inline value, file path, or "-" for stdin
	Type     string // json, form, etc. (inferred if empty)
	IsFile   bool   // true if value starts with @
	IsStdin  bool   // true if value is @-
}

func (WithClause) clause() {}

// HeadersClause represents a "headers=" clause.
type HeadersClause struct {
	Headers map[string]string
}

func (HeadersClause) clause() {}

// ParamsClause represents a "params=" clause for query parameters.
type ParamsClause struct {
	Params map[string]string
}

func (ParamsClause) clause() {}

// AsClause represents an "as=" clause for output format.
type AsClause struct {
	Format string // json, csv, text, raw
}

func (AsClause) clause() {}

// ToClause represents a "to=" clause for destination.
type ToClause struct {
	Destination string
}

func (ToClause) clause() {}

// UsingClause represents a "using=" clause for HTTP method override.
type UsingClause struct {
	Method string // GET, POST, PUT, PATCH, DELETE, etc.
}

func (UsingClause) clause() {}

// RetryClause represents a "retry=" clause.
type RetryClause struct {
	Count int
}

func (RetryClause) clause() {}

// BackoffClause represents a "backoff=" clause.
type BackoffClause struct {
	Min time.Duration
	Max time.Duration
}

func (BackoffClause) clause() {}

// TimeoutClause represents a "timeout=" clause.
type TimeoutClause struct {
	Duration time.Duration
}

func (TimeoutClause) clause() {}

// ProxyClause represents a "proxy=" clause.
type ProxyClause struct {
	URL string
}

func (ProxyClause) clause() {}

// PickClause represents a "pick=" clause for JSON path selection.
type PickClause struct {
	Path string // JSONPath expression
}

func (PickClause) clause() {}

// EveryClause represents an "every=" clause for polling.
type EveryClause struct {
	Interval time.Duration
}

func (EveryClause) clause() {}

// UntilClause represents an "until=" clause for conditional polling.
type UntilClause struct {
	Predicate string
}

func (UntilClause) clause() {}

// FieldClause represents a "field=" clause for multipart uploads.
type FieldClause struct {
	Name  string
	Value string
}

func (FieldClause) clause() {}

// VerboseClause represents the "verbose" flag.
type VerboseClause struct{}

func (VerboseClause) clause() {}

// ResumeClause represents the "resume" flag for resumable downloads.
type ResumeClause struct{}

func (ResumeClause) clause() {}

// IncludeClause represents an "include=" clause for headers, params, and cookies.
type IncludeClause struct {
	Items []IncludeItem
}

func (IncludeClause) clause() {}

// IncludeItem represents a single item in an include clause.
type IncludeItem struct {
	Type  string // "header", "param", "cookie"
	Name  string // header name, param key, or cookie key
	Value string // header value, param value, or cookie value
}

// AttachClause represents an "attach=" clause for multipart form data.
type AttachClause struct {
	Parts    []AttachPart
	Boundary string // optional explicit boundary
}

func (AttachClause) clause() {}

// AttachPart represents a single part in an attach clause.
type AttachPart struct {
	Name     string // required
	FilePath string // file=@path (mutually exclusive with Value)
	Value    string // value=... (mutually exclusive with FilePath)
	Filename string // optional filename
	Type     string // optional Content-Type
}

// ExpectClause represents an "expect=" clause for response assertions.
type ExpectClause struct {
	Checks []ExpectCheck
}

func (ExpectClause) clause() {}

// ExpectCheck represents a single assertion check.
type ExpectCheck struct {
	Type  string // "status", "header", "contains", "jsonpath", "matches"
	Name  string // for header checks, the header name
	Value string // the value to check against
	Path  string // for jsonpath, the JSONPath expression
	Regex string // for matches, the regex pattern
}

// FollowClause represents a "follow=" clause for redirect policy.
type FollowClause struct {
	Policy string // "smart" or empty for default
}

func (FollowClause) clause() {}

// UnderClause represents an "under=" clause for timeout or size limit.
type UnderClause struct {
	Duration time.Duration // if it's a duration
	Size     int64         // if it's a size (in bytes)
	IsSize   bool          // true if it's a size limit, false if duration
}

func (UnderClause) clause() {}

// ViaClause represents a "via=" clause for proxy URL.
type ViaClause struct {
	URL string
}

func (ViaClause) clause() {}

// InsecureClause represents an "insecure=" clause (updated to support true/false).
type InsecureClause struct {
	Value bool // true or false
}

func (InsecureClause) clause() {}


----
output.txt
The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encountered. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
.cursor/rules/grammar.mdc
# .cursor/rules/grammar.mdc

# req grammar - v0.1 specification

This documents the language. It is a DSL that reads like a sentence and runs in a shell.

## Command shape

    req <verb> <url> [clauses...]

Clauses are key=value pairs where keys are semantic words, not config words.

Order of clauses is free.

Unknown clause keys are errors.

## Verbs

- read - GET, print to stdout
- save - GET, write to file via to=
- send - default GET, POST if with= present
- upload - POST when attach= or with= present, else error
- watch - GET with SSE or polling
- inspect - HEAD only
- authenticate - login and store session state
- session show, session clear, session use - session management

## Clauses

| Clause     | Meaning                                     | Repeatable | Example                                                                 |
|-----------|---------------------------------------------|------------|-------------------------------------------------------------------------|
| using=    | HTTP method override                         | no         | using=PUT                                                               |
| include=  | Add headers, params, cookies                 | yes        | include='header: Authorization: Bearer token; param: q=search query'     |
| with=     | Request body                                 | no         | with=@user.json or with='{"name":"Adam"}'                               |
| expect=   | Assertions on response                       | no         | expect=status:200, header:Content-Type=application/json, contains:"ok"  |
| as=       | Output format for stdout                     | no         | as=json                                                                 |
| to=       | Destination path                             | no         | to=out.json                                                             |
| retry=    | Retry attempts for transient errors          | no         | retry=3                                                                 |
| under=    | Timeout or size limit                        | no         | under=30s or under=10MB                                                 |
| via=      | Proxy URL                                    | no         | via=http://proxy:8080                                                   |
| attach=   | Multipart parts for upload or send           | yes        | attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'    |
| follow=   | Redirect policy for write verbs              | no         | follow=smart                                                            |
| insecure= | Disable TLS verification for this request    | no         | insecure=true                                                           |

### include= value grammar

- One include clause may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - header: Name: Value
  - param: key=value
  - cookie: key=value

Merging
- Headers: keep all values for multi valued headers, else last wins.
- Params: repeated keys become repeated pairs in insertion order.
- Cookies: last value wins per cookie name.

Quoting
- If an item payload contains a semicolon, quote the value.
- Backslash escapes allowed inside quoted values for the quote char and backslash.

Errors
- Unknown tag before the first colon.
- Header without Name colon Value.
- Param or cookie missing equals.
- Unquoted semicolon inside an item payload.

Examples

    include='header: Accept: application/json, application/problem+json; q=0.9'
    include='param: q=search query; param: tag=ai; param: tag=ml'
    include='cookie: session=abc; cookie: prefs="a=1; b=2"'

### attach= value grammar

- One attach may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - part: name=..., file=@path  or  part: name=..., value=...
  - Optional filename=...
  - Optional type=media/type
  - boundary: TOKEN optional

Validation
- name is required.
- exactly one of file or value is required.
- for file parts, @path must exist at execution time.

Header behavior
- Any attach= forces multipart Content-Type with a generated boundary.
- If user included a manual Content-Type, override it and print a one line note.

Examples

    attach='part: name=avatar, file=@./me.png, filename=me.png, type=image/png'
    attach='part: name=meta, value={"name":"adam"}'
    attach='part: name=file, file=@./a.png; part: name=meta, value=xyz'

### with= body modes

- Inline text or JSON.
- @file to read from file.
- @- to read from stdin.

Content type
- If Content-Type is not set and inline begins with "{" or "[", infer application/json and note on stderr.
- An explicit Content-Type header always overrides inference.

### expect= assertions

Single clause with comma separated checks. All must pass.

Supported checks
- status:200
- header:Content-Type=application/json
- contains:"text"
- jsonpath:"$.items[0].id"
- matches:"^OK\\b"

Exit codes
- 0 success and expectations passed.
- 3 request ok but an expectation failed.

Failure messages must be concise and specific.

### Redirects

- read and save follow up to 5 redirects by default.
- write verbs do not follow by default.
- follow=smart for writes follows only 307 and 308, up to 5 hops.
- On 301, 302, 303 for writes, do not follow and print an advisory.

### Compression

- If user did not set Accept-Encoding, send "Accept-Encoding: gzip, br".
- Auto decompress gzip or br before as= and expect=.
- Print a one line note when decompression occurs.

### TLS

- insecure=true disables certificate verification for this request only.
- Print one line warning on stderr.

### Sessions

authenticate
- Follows redirects.
- Captures Set-Cookie.
- If response is JSON with a top level access_token, store it as a Bearer token.
- Store per host under user state dir with strict perms.

Auto use
- Any request to a host with a stored session auto applies cookies and Authorization unless caller includes those explicitly.
- Print "Using session for <host>" when applied.

session verbs
- session show <host> prints redacted info. as=json prints machine friendly form.
- session clear <host> deletes state.
- session use <host> prints env stub for shell scoping.

### Method defaults

- read GET
- save GET
- send GET by default, POST if with= present
- upload POST when attach= present, else POST if with= present, else error
- watch GET
- inspect HEAD
- authenticate POST if with= present, else require using=

### Multiplicity and ordering

- Singletons: using, with, expect, as, to, retry, under, via, insecure, follow.
- Repeatable: include, attach.
- Clause order is free.
- Explicit include of Authorization or Cookie overrides session.

### Token and quoting model

- Parser consumes argv tokens as provided by the shell.
- Do not re split on spaces.
- Values containing semicolons must be quoted.
- Backslash escapes allowed inside quotes for the quote char and backslash.
- Environment variables are expanded by the shell before argv.

### Errors that must be loud and specific

- Unknown clause key.
- Duplicate singletons.
- include item with unknown tag or malformed payload.
- header item missing Name colon Value.
- param or cookie missing equals.
- unquoted semicolon in an item payload.
- attach part missing name, or missing both file and value, or providing both.
- URL parse failure.
- file path not found for with or attach.
- timeout or size limit exceeded.
- TLS error when insecure=false.

### Error message examples

Each error class must produce a specific, actionable message. Examples:

Unknown clause key

    $ req read https://example.com invalid=clause
    Error: parse error at position 2 (token: "invalid"): unknown clause

Duplicate singleton

    $ req read https://example.com with=test with=test2
    Error: parse error at position 3 (token: "with"): duplicate singleton clause 'with' (did you mean "remove duplicate 'with=' clause"?)

Unquoted semicolon in include

    $ req read https://example.com include='param: q=test;value'
    Error: parse error at position 2 (token: "include"): unquoted semicolon in include item

Malformed header (missing Name: Value)

    $ req read https://example.com include='header: InvalidHeader'
    Error: parse error at position 2 (token: "include"): header item missing Name: Value format

Missing equals in param or cookie

    $ req read https://example.com include='param: q'
    Error: parse error at position 2 (token: "include"): param missing equals

Attach part missing name

    $ req upload https://example.com attach='part: file=@test.png'
    Error: parse error at position 2 (token: "attach"): attach part missing name

Attach part with both file and value

    $ req upload https://example.com attach='part: name=test, file=@test.png, value=text'
    Error: parse error at position 2 (token: "attach"): attach part cannot have both file and value

File not found for with

    $ req send https://example.com with=@nonexistent.json
    Error: file not found: nonexistent.json

File not found for attach

    $ req upload https://example.com attach='part: name=file, file=@nonexistent.png'
    Error: file not found: nonexistent.png

### Output contracts

stdout
- Response body, formatted per as=.
- For save, write to file and keep stdout empty unless a specific mode says otherwise.

stderr
- Compact meta block: status, url, duration, bytes, content type.
- Notices: session use, decompression, redirect trace, TLS warning, multipart override note.
- Secrets redacted in meta lines.

### End to end examples

Read with params and header

    req read https://api.example.com/search \
      include='param: q=search query; header: X-Trace: 1' \
      as=json

Write JSON with auth and assertion

    req send https://api.example.com/users \
      using=POST \
      include='header: Authorization: Bearer $TOKEN' \
      with='{"name":"Adam"}' \
      expect=status:201, header:Content-Type=application/json \
      as=json

Multipart upload

    req upload https://api.example.com/upload \
      attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
      as=json

Authenticate then use session

    req authenticate https://api.example.com/login \
      using=POST \
      with='{"user":"adam","pass":"xyz"}'

    req read https://api.example.com/me as=json

Write with safe redirects

    req send https://api.example.com/endpoint \
      using=POST \
      with='{"a":1}' \
      follow=smart \
      expect=status:200

----
.cursor/rules/plan.mdc
---
alwaysApply: true
---
# /.cursor/plan.md

# req project plan - v0.1 to 90 percent curl coverage

This is a strict, test-driven plan. Each task has acceptance criteria. No code here. Use these goals as Cursor prompts.

## 1) Lock the surface grammar
- Enforce command shape: `req <verb> <url> [clauses...]`
- Allowed verbs: read, save, send, upload, watch, inspect, authenticate, session (show|clear|use)
- Allowed clauses: using=, include=, with=, expect=, as=, to=, retry=, under=, via=, attach=, follow=smart, insecure=true
- Clause order independent

Acceptance
- Unknown clause keys hard error with nearest suggestion
- Duplicate singletons hard error with fix hint
- Golden tests for valid and invalid examples
- `req help` prints the grammar summary

## 2) include= value grammar
Goal
- Implement semicolon separated items with explicit tags

Do
- Items: `header: Name: Value`, `param: key=value`, `cookie: key=value`
- Values may be quoted
- Multiple include= clauses allowed

Merging rules
- Headers: keep all for multi valued headers, else last wins
- Params: repeated keys become repeated pairs in order
- Cookies: last value wins

Acceptance
- Unit tests for quoting, embedded semicolons, repeated keys, error cases
- Golden tests for combined include payloads

## 3) attach= multipart grammar
Goal
- Repeatable clause for multipart form data

Do
- Items: `part: ...` and `boundary: ...`
- Part kvs: `name=`, one of `file=@path` or `value=`, optional `filename=`, optional `type=media/type`
- Validate name required, exactly one of file or value
- Any attach= forces `Content-Type: multipart/form-data; boundary=...`
- If user set Content-Type manually, override and print a one line note

Acceptance
- Unit tests for file, text, mixed parts, explicit boundary, malformed descriptors
- Integration test uses echo server to assert parts

## 4) follow=smart and insecure=true
Goal
- Add redirect and TLS toggles

Do
- follow accepts only `smart`
- insecure accepts `true` or `false`

Acceptance
- Unit tests parse both correctly and reject bad values

## 5) with= body modes and light inference
Goal
- Support inline, @file, @-

Do
- If Content-Type is not set and inline begins with `{` or `[`, infer `application/json` and log a one line note on stderr
- Explicit header always overrides inference

Acceptance
- Tests for inference, override, and no inference on file

## 6) expect= assertions
Goal
- Single clause with comma separated checks

Checks
- `status:200`
- `header:Content-Type=application/json`
- `contains:"text"`
- `jsonpath:"$.items[0].id"`
- `matches:"^OK\\b"`

Acceptance
- Exit 3 on any failure, with a concise diff-like message
- Tests for pass and fail cases

## 7) Verb defaults and method validation
Goal
- Map verbs to default methods and validate using=

Defaults
- read GET
- save GET
- send GET by default, POST if with= present
- upload POST if attach= or with= present, else error
- watch GET
- inspect HEAD
- authenticate default POST if with= present

Acceptance
- Tests for defaults and invalid combinations

## 8) Redirect policy
Goal
- Implement safe redirect rules

Rules
- read and save follow up to 5 by default
- write verbs do not follow by default
- follow=smart follows only 307 and 308 for writes, up to 5
- On 301, 302, 303 for writes, do not follow, print advisory

Acceptance
- Integration tests for 301, 302, 303, 307, 308 with and without smart
- Stderr shows compact trace

## 9) Transparent compression
Goal
- gzip and br on by default

Do
- Inject Accept-Encoding unless user set it
- Auto decompress before as= and expect=
- One line stderr note when decompressed

Acceptance
- gz and br tests, expect sees decoded text, user header respected

## 10) TLS control
Goal
- Implement insecure=true

Acceptance
- Self signed server fails normally, succeeds with insecure=true
- One line stderr warning: TLS verification disabled

## 11) Query param merging and URL assembly
Goal
- Merge URL params with include param items

Acceptance
- Repeated keys serialize in insertion order
- Proper percent encoding
- Existing URL params preserved and merged

## 12) Output control with as= and to=
Goal
- Finalize sinks and formatting

Do
- as=json, text, raw, csv
- to=PATH writes file. For save, derive filename from URL if needed
- stdout is body, stderr is compact meta with redaction

Acceptance
- Filename extraction, directory handling, percent decoding, meta block content

## 13) Sessions and authenticate
Goal
- Explicit session model

Do
- authenticate captures Set-Cookie and `access_token` from JSON
- Store per host in user state dir with strict perms
- Auto apply for matching host unless caller includes Authorization or Cookie
- Print `Using session for <host>` on use
- session show, session clear, session use implemented

Acceptance
- Integration tests for login, reuse, override, redaction, permission refusal

## 14) Multipart body construction
Goal
- Build body with generated boundary and proper part headers

Acceptance
- Echo server validates Content-Disposition, Content-Type, filenames and order
- Manual Content-Type overridden with a note

## 15) Errors, hints, exit codes
Goal
- Clear, specific failures

Acceptance
- Exit codes: 0 ok, 3 expect fail, 4 network, 5 grammar
- Hints for unquoted semicolons, missing equals, duplicate singletons, unknown clause, bad attach part

## 16) Help and explain
Goal
- Discoverability tools

Do
- `req help` prints grammar table and examples
- `req explain "<command>"` prints parsed plan without executing

Acceptance
- Golden tests for explain output

## 17) Cross shell quoting doc
Goal
- Portability guidance

Do
- Quoting cheat sheet for bash, zsh, fish, PowerShell
- Curl vs req mapping table for common tasks

Acceptance
- Docs included and examples parse in a simple parser smoke test

## 18) CI, golden, fixtures
Goal
- Stable test harness

Do
- Golden tests for parser and explain
- Local HTTP fixture: echo headers, cookies, query, gzip, br, 30x, multipart
- Run under race detector

Acceptance
- CI green across Go versions you support

## 19) Streaming and watch polish
Goal
- Memory efficient downloads and sensible watch output

Do
- Stream to file for save
- Watch prints timestamps on TTY, raw otherwise

Acceptance
- Large download uses low memory
- Watch behaves per TTY detection

## 20) README refresh
Goal
- Align docs with grammar

Do
- Replace stale examples with include, attach, expect forms
- Document redirect defaults and smart policy
- Add warning about insecure=true and shell history

Acceptance
- Doc snippets pass as golden examples

----
.github/ISSUE_TEMPLATE/bug_report.md
---
name: Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Description

A clear and concise description of what the bug is.

## Reproduction

**Command:**
```bash
req <your-command-here>
```

**Expected Output:**
```
<expected-output>
```

**Actual Output:**
```
<actual-output>
```

## Environment

- OS: [e.g., Linux, macOS, Windows]
- Architecture: [e.g., amd64, arm64]
- Version: [e.g., v0.1.0]
- Go version: [e.g., 1.23]

## Additional Context

Add any other context about the problem here, including:
- Error messages
- Stack traces (if applicable)
- Workarounds you've tried


----
.github/ISSUE_TEMPLATE/feature_request.md
---
name: Feature Request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Summary

A clear and concise description of the feature you'd like to see.

## Motivation

Why is this feature needed? What problem does it solve?

## Detailed Description

Describe the feature in detail:
- What should the command syntax look like?
- What should the output look like?
- Are there any edge cases to consider?

## Example Usage

```bash
req <example-command>
```

## Alternatives Considered

Describe any alternative solutions or features you've considered.

## Additional Context

Add any other context, mockups, or examples about the feature request here.


----
.github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Run tests with race detector
        run: make test
      
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          make vulncheck
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m
  
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-${{ matrix.os }}
          path: bin/req
  
  windows:
    name: Windows Build
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-windows
          path: bin/req.exe

  grammar-drift:
    name: Grammar Drift Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build binary
        run: make build
      
      - name: Run grammar drift tests
        run: go test -v ./tests -run 'TestGrammarDrift|TestBinaryHelpDrift'


----
.gitignore
# Binaries
bin/
req
req.exe

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
*.tar.gz
*.zip


----
.golangci.yml
# golangci-lint configuration with lean modern linter set
run:
  timeout: 5m
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  gocritic:
    enabled-tags:
      - diagnostic
  govet:
    check-shadowing: true
  misspell:
    locale: US
  nolintlint:
    allow-leading-space: true
    allow-unused: false
    require-explanation: false
    require-specific: false

linters:
  disable-all: true
  enable:
    - errcheck
    - gocritic
    - goimports
    - gosimple
    - govet
    - ineffassign
    - misspell
    - nolintlint
    - staticcheck

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
  max-issues-per-linter: 0
  max-same-issues: 0

----
.goreleaser.yml
# GoReleaser configuration for cross-platform releases
project_name: req

before:
  hooks:
    - go mod download

builds:
  - id: req
    main: ./cmd/req
    binary: req
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    goarm:
      - 6
      - 7
    ignore:
      - goos: windows
        goarch: arm64
    env:
      - CGO_ENABLED=0
    flags:
      - -trimpath
      - -ldflags=-s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.buildDate={{.Date}}

archives:
  - id: default
    builds:
      - req
    format_overrides:
      - goos: windows
        format: zip
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    files:
      - LICENSE
      - README.md

checksum:
  name_template: "{{ .ProjectName }}_{{ .Version }}_checksums.txt"

snapshot:
  name_template: "{{ .Tag }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"


----
LICENSE
MIT License

Copyright (c) 2025 Adam Perkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


----
Makefile
.PHONY: build test lint package golden clean help

# Variables
BINARY_NAME=req
MAIN_PATH=./cmd/req
VERSION?=dev
BUILD_DIR=./bin
COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build the req binary
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
ifeq ($(GOOS),windows)
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME).exe $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME).exe"
else
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"
endif

test: ## Run tests with race detector
	@echo "Running tests..."
	@go test -race -cover -v ./...

test-golden: ## Run golden file tests
	@echo "Running golden tests..."
	@go test -v ./tests -run TestGolden

golden: ## Regenerate golden test files
	@echo "Regenerating golden files..."
	@go test ./tests -run TestGolden -update

lint: ## Run golangci-lint
	@echo "Running golangci-lint..."
	@golangci-lint run

lint-fix: ## Run golangci-lint with auto-fix
	@golangci-lint run --fix

vulncheck: ## Run govulncheck
	@echo "Running govulncheck..."
	@govulncheck ./...

package: ## Build release artifacts locally (requires goreleaser)
	@echo "Building release artifacts..."
	@goreleaser build --snapshot --clean

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@go clean -cache

install: build ## Install binary to GOPATH/bin
	@go install $(MAIN_PATH)


----
README.md
# req

A semantic HTTP client written in Go that replaces traditional curl syntax with a natural, intent-based grammar.

## Overview

`req` is an HTTP client tool that focuses on:

- **Human-readable commands** (verbs + clauses)
- **Sensible defaults** (follow redirects, TLS verify, retries)
- **JSON/CSV/text awareness** with intelligent output
- **Watch mode** (poll or stream)
- **Session management** (authenticate and auto-apply)
- **Pretty diagnostics** and dry-run transparency

## Quick Start

```bash
# Read JSON from an API
req read https://api.example.com/users as=json

# Send JSON data
req send https://api.example.com/users with='{"name":"Adam"}'

# Send with headers and assertions
req send https://api.example.com/users \
  using=POST \
  include='header: Authorization: Bearer $TOKEN' \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json \
  as=json

# Save a file
req save https://example.com/file.zip to=file.zip

# Upload multipart form data
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png' \
  as=json

# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Use stored session automatically
req read https://api.example.com/me as=json
```

## Installation

```bash
go install github.com/adammpkins/req/cmd/req@latest
```

Or download a pre-built binary from the [Releases](https://github.com/adammpkins/req/releases) page.

## Grammar

The `req` command follows this grammar:

```
req <verb> <target> [clauses...]
```

### Verbs

- `read` - GET, print to stdout
- `save` - GET, write to file via to=
- `send` - default GET, POST if `with=` is present
- `upload` - POST when `attach=` or `with=` present, else error
- `watch` - GET with SSE or polling
- `inspect` - HEAD only
- `authenticate` - login and store session state
- `session` - session management (show, clear, use)

### Clauses

- `using=<method>` - HTTP method override
- `include=<items>` - Add headers, params, cookies (repeatable)
  - Format: `include='header: Name: Value; param: key=value; cookie: key=value'`
- `with=<body>` - Request body
  - Format: `with=@user.json` or `with='{"name":"Adam"}'`
  - JSON inference: Automatically sets Content-Type for JSON when inline starts with `{` or `[`
- `expect=<checks>` - Assertions on response
  - Format: `expect=status:200, header:Content-Type=application/json, contains:"ok"`
- `as=<format>` - Output format for stdout
- `to=<path>` - Destination path
- `retry=<count>` - Retry attempts for transient errors
- `under=<limit>` - Timeout or size limit
  - Format: `under=30s` or `under=10MB`
- `via=<url>` - Proxy URL
- `attach=<parts>` - Multipart parts for upload or send (repeatable)
  - Format: `attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'`
- `follow=<policy>` - Redirect policy for write verbs
  - Format: `follow=smart`
- `insecure=<bool>` - Disable TLS verification for this request
  - Format: `insecure=true`

## Examples

### Read JSON

```bash
req read https://api.example.com/users as=json
```

### Send JSON Data

```bash
req send https://api.example.com/users with='{"name":"Ada","email":"ada@example.com"}'
```

### Save a File

```bash
# Save with explicit filename
req save https://example.com/file.zip to=file.zip

# Save with auto-detected filename (extracts from URL)
req save https://example.com/file.zip

# Save to directory path
req save https://example.com/file.zip to=/tmp/file.zip
```

### With Headers, Params, and Cookies

```bash
# Using include clause
req read https://api.example.com/search \
  include='header: Authorization: Bearer $TOKEN; param: q=search query; cookie: session=abc123' \
  as=json
```

### With Assertions

```bash
req send https://api.example.com/users \
  using=POST \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json, contains:"id" \
  as=json
```

### Sessions

```bash
# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Session is automatically used for subsequent requests
req read https://api.example.com/me as=json

# Show stored session (redacted)
req session show api.example.com

# Show session in JSON format
req session show api.example.com as=json

# Clear session
req session clear api.example.com
```

### Redirects

```bash
# Read and save follow redirects by default (up to 5)
req read https://example.com/redirect

# Write verbs don't follow by default
req send https://api.example.com/create using=POST with='{"data":"value"}'

# Use smart follow for write verbs (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
```

### With Retry and Timeout

```bash
req read https://api.example.com/users retry=3 under=10s as=json
```

### Edge Cases

```bash
# Header with commas and q values (must be quoted)
req read https://api.example.com/search \
  include='header: Accept: application/json, application/problem+json; q=0.9' \
  as=json

# Cookie value containing semicolons (must be quoted)
req read https://api.example.com/search \
  include='cookie: prefs="a=1; b=2; c=3"' \
  as=json

# Multipart upload with file and text parts (Content-Type automatically overridden)
req upload https://api.example.com/upload \
  include='header: Content-Type: application/json' \
  attach='part: name=file, file=@avatar.png; part: name=meta, value={"name":"test"}' \
  as=json
# Note: Content-Type will be overridden to multipart/form-data

# Smart redirect on write verb (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
# Will follow 307/308 redirects, but not 301/302/303

# Write verb with 303 redirect (advisory printed, not followed)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}'
# If server returns 303, advisory message printed but redirect not followed
```

### Method Override

```bash
# Use PUT instead of POST
req send https://api.example.com/users/1 using=PUT with='{"name":"Updated"}'

# Use PATCH for partial updates
req send https://api.example.com/users/1 using=PATCH with='{"email":"new@example.com"}'

# Use HEAD to check headers without body
req read https://api.example.com/users using=HEAD
```

**Note:** The `using=` clause validates method-verb compatibility. For example, `read using=POST` will fail as `read` only allows GET, HEAD, or OPTIONS.

### Comparison with curl

| Task | curl | req |
|------|------|-----|
| **Basic GET with headers** | `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include='header: Authorization: Bearer $TOKEN'` |
| **Multipart upload** | `curl -F "file=@avatar.png" -F "name=test" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png; part: name=name, value=test'` |
| **Authenticated POST** | `curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users using=POST include='header: Authorization: Bearer $TOKEN' with='{"name":"Adam"}'` |

### Dry Run

```bash
req read https://api.example.com/users as=json --dry-run
```

### Interactive TUI Mode

```bash
# Launch interactive TUI mode
req --tui

# Or run without arguments to launch TUI
req
```

The TUI mode provides:
- Interactive command builder with form-based input
- **Syntax-highlighted JSON output** with color-coded keys, values, and punctuation
- **Scrollable viewport** for long responses with keyboard navigation
- Pretty-printed JSON with automatic indentation
- Real-time command execution and response display

**Keyboard Controls:**
- `↑` / `↓` or `k` / `j` - Scroll line by line
- `pgup` / `pgdown` - Page scrolling
- `home` - Jump to top
- `end` - Jump to bottom
- `ctrl+u` / `ctrl+d` - Half-page scrolling
- `esc` - Quit TUI

## Security

### Shell History

**Warning:** Commands containing secrets (tokens, passwords) are stored in your shell history by default. Use environment variables to avoid exposing secrets:

```bash
# Bad: Token appears in shell history
req read https://api.example.com/users include='header: Authorization: Bearer secret-token-123'

# Good: Use environment variable
TOKEN="secret-token-123"
req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"
```

To prevent secrets from being saved to history:
- **Bash/Zsh:** Prefix command with a space (requires `HISTCONTROL=ignorespace` or `setopt HIST_IGNORE_SPACE`)
- **Fish:** Use `history --delete` after running commands with secrets
- **PowerShell:** Use `Set-PSReadlineOption -HistoryNoDuplicates` and manually edit history

### Session Files

Session files are stored in `~/.config/req/session_<host>.json` with permissions `0600` (owner read/write only).

**Security rules:**
- Session files are created with strict permissions (`0600`)
- If a session file has group or world readable permissions, `req` will refuse to load it
- Session files contain sensitive data (cookies, tokens) and should be protected
- Never commit session files to version control

To check session file permissions:
```bash
ls -l ~/.config/req/session_*.json
```

## Current Status

**v0.1** - Core functionality complete

- ✅ Command parsing with full grammar validation
- ✅ All clauses implemented (include, attach, expect, follow, insecure, etc.)
- ✅ Execution plan generation with verb defaults
- ✅ HTTP request execution with redirect handling
- ✅ Transparent compression (gzip, br)
- ✅ Session management (authenticate, session show/clear/use)
- ✅ Auto-apply sessions for matching hosts
- ✅ File downloads with automatic filename extraction
- ✅ Multipart form data support
- ✅ Response assertions (expect clause)
- ✅ Proper exit codes (0 success, 3 expect fail, 4 network, 5 grammar)
- ✅ Helpful error messages with suggestions
- ✅ Help and explain commands
- ✅ Interactive TUI mode
- ✅ JSON output formatting
- ✅ Stderr meta output with redaction

## Roadmap

- **v0.1** ✅ - Core functionality (current)
- **v0.2** - Watch mode with SSE and polling
- **v0.3** - JSONPath selection and filtering
- **v0.4** - Advanced retry and backoff strategies
- **v1.0** - Stability hardening and release candidates

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

MIT License - see [LICENSE](LICENSE) file for details.


----
cmd/req/main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/adammpkins/req/internal/grammar"
	"github.com/adammpkins/req/internal/output"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
	"github.com/adammpkins/req/internal/tui"
	"github.com/adammpkins/req/internal/types"
)

var (
	version   = "dev"
	commit    = "unknown"
	buildDate = "unknown"
)

func main() {
	var (
		showHelp    = flag.Bool("help", false, "Show help message")
		showVersion = flag.Bool("version", false, "Show version information")
		dryRun      = flag.Bool("dry-run", false, "Print execution plan without executing")
		tuiMode     = flag.Bool("tui", false, "Launch interactive TUI mode")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: req <verb> <target> [clauses...]\n\n")
		fmt.Fprintf(os.Stderr, "Verbs: read, save, send, upload, watch, inspect, authenticate, session\n\n")
		fmt.Fprintf(os.Stderr, "Examples:\n")
		fmt.Fprintf(os.Stderr, "  req read https://api.example.com/users as=json\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users using=PUT with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req save https://example.com/file.zip to=file.zip\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showHelp {
		flag.Usage()
		os.Exit(0)
	}

	if *showVersion {
		fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
		os.Exit(0)
	}

	// Launch TUI mode if requested
	if *tuiMode {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Get remaining args after flags
	args := flag.Args()

	// Remove any remaining flags from args (in case they appear after command args)
	filteredArgs := make([]string, 0, len(args))
	for _, arg := range args {
		if arg == "--help" || arg == "-help" || arg == "-h" {
			flag.Usage()
			os.Exit(0)
		}
		if arg == "--version" || arg == "-version" || arg == "-v" {
			fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
			os.Exit(0)
		}
		if arg == "--dry-run" || arg == "-dry-run" {
			*dryRun = true
			continue
		}
		filteredArgs = append(filteredArgs, arg)
	}
	args = filteredArgs

	// If no args provided, launch TUI mode
	if len(args) == 0 {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Handle help command
	if len(args) > 0 && args[0] == "help" {
		printHelp()
		os.Exit(0)
	}

	// Handle explain command
	if len(args) > 0 && args[0] == "explain" {
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Usage: req explain \"<command>\"\n")
			os.Exit(5)
		}
		command := strings.Join(args[1:], " ")
		if err := explainCommand(command); err != nil {
			printError(err)
			os.Exit(5)
		}
		os.Exit(0)
	}

	// Join args into a single command string
	command := strings.Join(args, " ")

	// Parse the command
	cmd, err := parser.Parse(command)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar error
	}

	// Handle session commands specially
	if cmd.Verb == types.VerbSession {
		if err := handleSessionCommand(cmd); err != nil {
			printError(err)
			os.Exit(5)
		}
		return
	}

	// Plan the execution
	plan, err := planner.Plan(cmd)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar/planning error
	}

	// Output the plan (dry-run mode)
	if *dryRun {
		formatted, err := output.FormatPlan(plan)
		if err != nil {
			printError(fmt.Errorf("failed to format plan: %w", err))
			os.Exit(5)
		}
		fmt.Println(string(formatted))
		return
	}

	// Execute the plan
	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		printError(fmt.Errorf("failed to create executor: %w", err))
		os.Exit(5) // Grammar error
	}

	if err := executor.Execute(plan); err != nil {
		printError(err)
		// Check error type for exit code
		if execErr, ok := err.(*runtime.ExecutionError); ok {
			os.Exit(execErr.Code)
		}
		os.Exit(4) // Network error (default)
	}
}

// printError prints an error with helpful diagnostics.
func printError(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v\n", err)

	// Check if it's a ParseError with suggestions
	if parseErr, ok := err.(*parser.ParseError); ok && parseErr.Suggest != "" {
		fmt.Fprintf(os.Stderr, "Hint: Try using '%s' instead\n", parseErr.Suggest)
	}
}

// printHelp prints the grammar summary.
func printHelp() {
	fmt.Print(grammar.FormatHelp())
}

// explainCommand prints the parsed plan for a command without executing it.
func explainCommand(command string) error {
	cmd, err := parser.Parse(command)
	if err != nil {
		return err
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		return err
	}

	formatted, err := output.FormatPlan(plan)
	if err != nil {
		return fmt.Errorf("failed to format plan: %w", err)
	}

	fmt.Println(string(formatted))
	return nil
}

// handleSessionCommand handles session management commands.
func handleSessionCommand(cmd *types.Command) error {
	host, err := session.ExtractHost(cmd.Target.URL)
	if err != nil {
		return fmt.Errorf("invalid host: %w", err)
	}

	switch cmd.SessionSubcommand {
	case "show":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			fmt.Printf("No session found for %s\n", host)
			return nil
		}

		// Check if JSON output requested
		asJSON := false
		for _, clause := range cmd.Clauses {
			if asClause, ok := clause.(types.AsClause); ok && asClause.Format == "json" {
				asJSON = true
				break
			}
		}

		if asJSON {
			// Machine-friendly JSON output
			data, err := json.MarshalIndent(sess, "", "  ")
			if err != nil {
				return fmt.Errorf("failed to marshal session: %w", err)
			}
			fmt.Println(string(data))
		} else {
			// Human-readable redacted output
			redacted := session.RedactSession(sess)
			fmt.Printf("Session for %s:\n", redacted.Host)
			if len(redacted.Cookies) > 0 {
				fmt.Println("Cookies:")
				for name := range redacted.Cookies {
					fmt.Printf("  %s: ***\n", name)
				}
			}
			if redacted.Authorization != "" {
				fmt.Printf("Authorization: %s\n", redacted.Authorization)
			}
		}
		return nil

	case "clear":
		if err := session.DeleteSession(host); err != nil {
			return fmt.Errorf("failed to delete session: %w", err)
		}
		fmt.Printf("Session cleared for %s\n", host)
		return nil

	case "use":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			return fmt.Errorf("no session found for %s", host)
		}
		// Print environment variable stub for shell scoping
		fmt.Printf("export REQ_SESSION_HOST=%s\n", host)
		return nil

	default:
		return fmt.Errorf("unknown session subcommand: %s", cmd.SessionSubcommand)
	}
}

----
docs/QUOTING.md
# Cross Shell Quoting Guide

This guide provides examples of how to properly quote `req` commands in different shells.

## General Rules

- Values containing semicolons (`;`) must be quoted
- Values containing spaces should be quoted
- Values containing special characters should be quoted
- Environment variables are expanded by the shell before being passed to `req`

## Bash / Zsh

### Single Quotes (Recommended)
Single quotes preserve everything literally:

```bash
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

### Double Quotes
Double quotes allow variable expansion:

```bash
TOKEN="abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

### Escaping
Use backslash to escape special characters:

```bash
req read https://api.example.com/search include='param: q=test\;value' as=json
```

## Fish Shell

Fish uses different quoting rules:

```fish
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in fish:

```fish
set TOKEN "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## PowerShell

PowerShell uses backticks for escaping:

```powershell
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in PowerShell:

```powershell
$TOKEN = "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## Common Patterns

### Include Clause with Multiple Items

```bash
# Bash/Zsh
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# Fish
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# PowerShell
req read https://api.example.com/search `
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' `
  as=json
```

### Expect Clause with Multiple Checks

```bash
req read https://api.example.com/users \
  expect='status:200, header:Content-Type=application/json, contains:"items"' \
  as=json
```

### Attach Clause with File Paths

```bash
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
  as=json
```

## Curl vs req Mapping

| curl command | req equivalent |
|-------------|----------------|
| `curl https://api.example.com/users` | `req read https://api.example.com/users` |
| `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"` |
| `curl -X POST -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users with='{"name":"Adam"}'` |
| `curl -X POST -F "file=@avatar.png" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png'` |
| `curl -b "session=abc123" https://api.example.com/users` | `req read https://api.example.com/users include='cookie: session=abc123'` |
| `curl -L https://example.com` | `req read https://example.com` (follows redirects by default) |
| `curl -k https://self-signed.example.com` | `req read https://self-signed.example.com insecure=true` |
| `curl --proxy http://proxy:8080 https://api.example.com` | `req read https://api.example.com via=http://proxy:8080` |
| `curl -X POST --data-binary @file.json https://api.example.com` | `req send https://api.example.com with=@file.json` |
| `curl -X POST --data @- https://api.example.com` | `echo '{"data":"value"}' \| req send https://api.example.com with=@-` |

## Tips

1. **Always quote include= values** - They often contain semicolons and spaces
2. **Use single quotes for JSON** - Prevents shell from interpreting special characters
3. **Use double quotes when you need variable expansion** - But be careful with nested quotes
4. **Test with `req explain`** - See how your command is parsed before executing:
   ```bash
   req explain "read https://api.example.com/users include='header: Authorization: Bearer token'"
   ```


----
go.mod
module github.com/adammpkins/req

go 1.24.0

toolchain go1.24.10

require (
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
)

require (
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

----
go.sum
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=

----
internal/grammar/grammar.go
// Package grammar defines the structured grammar data for req commands.
package grammar

import "fmt"

// Verb represents a req command verb.
type Verb struct {
	Name        string
	Description string
}

// Clause represents a req command clause.
type Clause struct {
	Name        string
	Description string
	Repeatable  bool
	Example     string
}

// Grammar contains the complete grammar definition.
type Grammar struct {
	Verbs   []Verb
	Clauses []Clause
}

// GetGrammar returns the canonical grammar definition.
func GetGrammar() Grammar {
	return Grammar{
		Verbs: []Verb{
			{Name: "read", Description: "GET, print to stdout"},
			{Name: "save", Description: "GET, write to file via to="},
			{Name: "send", Description: "default GET, POST if with= present"},
			{Name: "upload", Description: "POST when attach= or with= present, else error"},
			{Name: "watch", Description: "GET with SSE or polling"},
			{Name: "inspect", Description: "HEAD only"},
			{Name: "authenticate", Description: "login and store session state"},
			{Name: "session", Description: "session management (show, clear, use)"},
		},
		Clauses: []Clause{
			{Name: "using=", Description: "HTTP method override", Repeatable: false, Example: "using=PUT"},
			{Name: "include=", Description: "Add headers, params, cookies", Repeatable: true, Example: "include='header: Authorization: Bearer token; param: q=search query'"},
			{Name: "with=", Description: "Request body", Repeatable: false, Example: "with=@user.json or with='{\"name\":\"Adam\"}'"},
			{Name: "expect=", Description: "Assertions on response", Repeatable: false, Example: "expect=status:200, header:Content-Type=application/json, contains:\"ok\""},
			{Name: "as=", Description: "Output format for stdout", Repeatable: false, Example: "as=json"},
			{Name: "to=", Description: "Destination path", Repeatable: false, Example: "to=out.json"},
			{Name: "retry=", Description: "Retry attempts for transient errors", Repeatable: false, Example: "retry=3"},
			{Name: "under=", Description: "Timeout or size limit", Repeatable: false, Example: "under=30s or under=10MB"},
			{Name: "via=", Description: "Proxy URL", Repeatable: false, Example: "via=http://proxy:8080"},
			{Name: "attach=", Description: "Multipart parts for upload or send", Repeatable: true, Example: "attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'"},
			{Name: "follow=", Description: "Redirect policy for write verbs", Repeatable: false, Example: "follow=smart"},
			{Name: "insecure=", Description: "Disable TLS verification for this request", Repeatable: false, Example: "insecure=true"},
		},
	}
}

// FormatHelp formats the grammar as help text.
func FormatHelp() string {
	g := GetGrammar()
	
	var help string
	help += "req - HTTP client DSL\n\n"
	help += "Usage: req <verb> <url> [clauses...]\n\n"
	help += "Verbs:\n"
	
	for _, verb := range g.Verbs {
		help += fmt.Sprintf("  %-13s - %s\n", verb.Name, verb.Description)
	}
	
	help += "\nClauses:\n"
	for _, clause := range g.Clauses {
		help += fmt.Sprintf("  %-13s - %s", clause.Name, clause.Description)
		if clause.Repeatable {
			help += " (repeatable)"
		}
		help += "\n"
		if clause.Example != "" {
			help += fmt.Sprintf("                 Example: %s\n", clause.Example)
		}
	}
	
	help += "\nExamples:\n"
	help += "  req read https://api.example.com/search include='param: q=search query' as=json\n"
	help += "  \n"
	help += "  req send https://api.example.com/users \\\n"
	help += "    using=POST \\\n"
	help += "    include='header: Authorization: Bearer $TOKEN' \\\n"
	help += "    with='{\"name\":\"Adam\"}' \\\n"
	help += "    expect=status:201, header:Content-Type=application/json \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req upload https://api.example.com/upload \\\n"
	help += "    attach='part: name=file, file=@./avatar.png, type=image/png' \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req authenticate https://api.example.com/login \\\n"
	help += "    using=POST \\\n"
	help += "    with='{\"user\":\"adam\",\"pass\":\"xyz\"}'\n"
	help += "  \n"
	help += "  req read https://api.example.com/me as=json\n\n"
	help += "For more information, see the grammar documentation.\n"
	
	return help
}


----
internal/grammar/snapshot.go
package grammar

import "encoding/json"

// Snapshot represents a snapshot of the grammar for drift detection.
type Snapshot struct {
	Verbs   []string `json:"verbs"`
	Clauses []ClauseSnapshot `json:"clauses"`
}

// ClauseSnapshot represents a clause in the snapshot.
type ClauseSnapshot struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Repeatable  bool   `json:"repeatable"`
}

// GetSnapshot returns a JSON-serializable snapshot of the grammar.
func GetSnapshot() Snapshot {
	g := GetGrammar()
	
	verbs := make([]string, len(g.Verbs))
	for i, v := range g.Verbs {
		verbs[i] = v.Name
	}
	
	clauses := make([]ClauseSnapshot, len(g.Clauses))
	for i, c := range g.Clauses {
		clauses[i] = ClauseSnapshot{
			Name:        c.Name,
			Description: c.Description,
			Repeatable:  c.Repeatable,
		}
	}
	
	return Snapshot{
		Verbs:   verbs,
		Clauses: clauses,
	}
}

// GetSnapshotJSON returns the snapshot as JSON bytes.
func GetSnapshotJSON() ([]byte, error) {
	snapshot := GetSnapshot()
	return json.MarshalIndent(snapshot, "", "  ")
}


----
internal/output/format.go
// Package output provides formatting and pretty-printing for execution plans.
package output

import (
	"encoding/json"
	"os"

	"github.com/adammpkins/req/internal/planner"
	"github.com/mattn/go-isatty"
)

// FormatPlan formats an ExecutionPlan as JSON for output.
func FormatPlan(plan *planner.ExecutionPlan) ([]byte, error) {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		// Pretty print when outputting to terminal
		return json.MarshalIndent(plan, "", "  ")
	}
	// Compact JSON when piped
	return json.Marshal(plan)
}


----
internal/parser/parser.go
// Package parser implements a lexer and parser for the req command grammar.
//
// Grammar (EBNF):
//
//	command = verb target [clauses]
//	verb = "read" | "save" | "send" | "upload" | "watch" | "inspect" | "authenticate" | "session"
//	target = url
//	clauses = clause { clause }
//	clause = with_clause | include_clause | attach_clause | expect_clause | as_clause | to_clause |
//	         using_clause | retry_clause | under_clause | via_clause | follow_clause | insecure_clause
//	with_clause = "with=" ( string | "@file" | "@-" )
//	include_clause = "include=" items
//	attach_clause = "attach=" parts
//	expect_clause = "expect=" checks
//	as_clause = "as=" ( "json" | "csv" | "text" | "raw" )
//	to_clause = "to=" path
//	using_clause = "using=" ( "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS" )
//	retry_clause = "retry=" number
//	under_clause = "under=" ( duration | size )
//	via_clause = "via=" url
//	follow_clause = "follow=smart"
//	insecure_clause = "insecure=" ( "true" | "false" )
package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// isValidHTTPMethod checks if a method is a valid HTTP method.
func isValidHTTPMethod(method string) bool {
	validMethods := []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	methodUpper := strings.ToUpper(method)
	for _, valid := range validMethods {
		if methodUpper == valid {
			return true
		}
	}
	return false
}

// ParseError represents a parse error with position information.
type ParseError struct {
	Position int
	Token    string
	Message  string
	Suggest  string
}

func (e *ParseError) Error() string {
	if e.Suggest != "" {
		return fmt.Sprintf("parse error at position %d (token: %q): %s (did you mean %q?)", e.Position, e.Token, e.Message, e.Suggest)
	}
	return fmt.Sprintf("parse error at position %d (token: %q): %s", e.Position, e.Token, e.Message)
}

// Parser parses req commands into AST.
type Parser struct {
	tokens []token
	pos    int
}

// token represents a lexical token.
type token struct {
	typ   tokenType
	value string
	pos   int
}

type tokenType int

const (
	tokenEOF tokenType = iota
	tokenWord
	tokenURL
	tokenEquals
	tokenColon
	tokenDotDot
	tokenString
	tokenNumber
	tokenDuration
	tokenFlag
)

// Parse parses a command string into a Command AST.
func Parse(input string) (*types.Command, error) {
	p := &Parser{}
	p.tokenize(input)
	return p.parseCommand()
}

// tokenize tokenizes the input string.
func (p *Parser) tokenize(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		p.tokens = []token{{typ: tokenEOF, pos: 0}}
		return
	}

	parts := strings.Fields(input)
	tokens := make([]token, 0, len(parts))

	for i, part := range parts {
		pos := i
		// Check if this is a URL first (URLs with query params contain = but are not clauses)
		if looksLikeURL(part) {
			tokens = append(tokens, token{typ: tokenURL, value: part, pos: pos})
		} else if strings.Contains(part, "=") {
			// Handle clauses with equals
			// Split on = but keep the = as a token
			eqIdx := strings.Index(part, "=")
			key := part[:eqIdx]
			value := part[eqIdx+1:]

			tokens = append(tokens, token{typ: tokenWord, value: key, pos: pos})
			tokens = append(tokens, token{typ: tokenEquals, value: "=", pos: pos})
			// Handle typed values like json:...
			if strings.Contains(value, ":") {
				colonIdx := strings.Index(value, ":")
				typeName := value[:colonIdx]
				typeValue := value[colonIdx+1:]
				tokens = append(tokens, token{typ: tokenWord, value: typeName, pos: pos})
				tokens = append(tokens, token{typ: tokenColon, value: ":", pos: pos})
				tokens = append(tokens, token{typ: tokenString, value: typeValue, pos: pos})
			} else if looksLikeURL(value) {
				tokens = append(tokens, token{typ: tokenURL, value: value, pos: pos})
			} else if looksLikeDuration(value) {
				tokens = append(tokens, token{typ: tokenDuration, value: value, pos: pos})
			} else {
				tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
			}
		} else if isFlag(part) {
			tokens = append(tokens, token{typ: tokenFlag, value: part, pos: pos})
		} else {
			tokens = append(tokens, token{typ: tokenWord, value: part, pos: pos})
		}
	}

	tokens = append(tokens, token{typ: tokenEOF, pos: len(parts)})
	p.tokens = tokens
}

// looksLikeURL checks if a string looks like a URL.
func looksLikeURL(s string) bool {
	return strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://")
}

// looksLikeDuration checks if a string looks like a duration.
func looksLikeDuration(s string) bool {
	_, err := parseDuration(s)
	return err == nil
}

// isFlag checks if a string is a flag.
func isFlag(s string) bool {
	return s == "verbose" || s == "resume"
}

// parseCommand parses a command.
func (p *Parser) parseCommand() (*types.Command, error) {
	cmd := &types.Command{}

	// Parse verb
	verb, err := p.parseVerb()
	if err != nil {
		return nil, err
	}
	cmd.Verb = verb

	// Handle session subcommands (show, clear, use)
	if verb == types.VerbSession {
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected session subcommand (show, clear, use)"}
		}
		tok := p.tokens[p.pos]
		if tok.typ == tokenWord {
			subcmd := tok.value
			if subcmd == "show" || subcmd == "clear" || subcmd == "use" {
				cmd.SessionSubcommand = subcmd
				p.pos++
			} else {
				return nil, &ParseError{Position: tok.pos, Token: subcmd, Message: "unknown session subcommand (expected show, clear, or use)"}
			}
		}
	}

	// Parse target
	target, err := p.parseTarget()
	if err != nil {
		return nil, err
	}
	cmd.Target = target

	// Parse clauses
	clauses, err := p.parseClauses()
	if err != nil {
		return nil, err
	}
	cmd.Clauses = clauses

	return cmd, nil
}

// parseVerb parses a verb.
func (p *Parser) parseVerb() (types.Verb, error) {
	if p.pos >= len(p.tokens) {
		return "", &ParseError{Position: p.pos, Token: "", Message: "expected verb"}
	}

	tok := p.tokens[p.pos]
	if tok.typ != tokenWord {
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "expected verb"}
	}

	verb := types.Verb(tok.value)
	switch verb {
	case types.VerbRead, types.VerbSave, types.VerbSend, types.VerbUpload,
		types.VerbWatch, types.VerbInspect, types.VerbAuthenticate, types.VerbSession:
		p.pos++
		return verb, nil
	default:
		suggest := suggestVerb(tok.value)
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "unknown verb", Suggest: suggest}
	}
}

// suggestVerb suggests a similar verb.
func suggestVerb(input string) string {
	verbs := []string{"read", "save", "send", "upload", "watch", "inspect", "authenticate", "session"}
	best := ""
	minDist := 999
	for _, v := range verbs {
		dist := levenshteinDistance(input, v)
		if dist < minDist {
			minDist = dist
			best = v
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// levenshteinDistance calculates the Levenshtein distance between two strings.
func levenshteinDistance(a, b string) int {
	if len(a) == 0 {
		return len(b)
	}
	if len(b) == 0 {
		return len(a)
	}

	matrix := make([][]int, len(a)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(b)+1)
	}

	for i := 0; i <= len(a); i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len(b); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {
			cost := 0
			if a[i-1] != b[j-1] {
				cost = 1
			}
			matrix[i][j] = min(
				matrix[i-1][j]+1,
				matrix[i][j-1]+1,
				matrix[i-1][j-1]+cost,
			)
		}
	}

	return matrix[len(a)][len(b)]
}

func min(a, b, c int) int {
	if a < b && a < c {
		return a
	}
	if b < c {
		return b
	}
	return c
}

// parseTarget parses a target URL.
func (p *Parser) parseTarget() (types.Target, error) {
	if p.pos >= len(p.tokens) {
		return types.Target{}, &ParseError{Position: p.pos, Token: "", Message: "expected target URL or host"}
	}

	tok := p.tokens[p.pos]
	// For session commands, target might be a host instead of full URL
	if tok.typ == tokenURL {
		p.pos++
		return types.Target{URL: tok.value}, nil
	} else if tok.typ == tokenWord {
		// Might be a host name for session commands
		// Try to parse as URL, if it fails, treat as host
		if strings.Contains(tok.value, ".") || strings.Contains(tok.value, ":") {
			// Looks like a host, construct URL
			urlStr := "https://" + tok.value
			p.pos++
			return types.Target{URL: urlStr}, nil
		}
	}

	return types.Target{}, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected URL or host"}
}

// parseClauses parses zero or more clauses.
func (p *Parser) parseClauses() ([]types.Clause, error) {
	var clauses []types.Clause
	singletonSeen := make(map[string]bool)

	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}

		clause, err := p.parseClause()
		if err != nil {
			return nil, err
		}

		// Check for duplicate singletons
		if singletonKey := getSingletonKey(clause); singletonKey != "" {
			if singletonSeen[singletonKey] {
				return nil, &ParseError{
					Position: tok.pos,
					Token:    tok.value,
					Message:  fmt.Sprintf("duplicate singleton clause '%s'", singletonKey),
					Suggest:  fmt.Sprintf("remove duplicate '%s=' clause", singletonKey),
				}
			}
			singletonSeen[singletonKey] = true
		}

		clauses = append(clauses, clause)
	}

	return clauses, nil
}

// getSingletonKey returns the key name for singleton clauses, or empty string for repeatable clauses.
func getSingletonKey(clause types.Clause) string {
	switch clause.(type) {
	case types.UsingClause:
		return "using"
	case types.WithClause:
		return "with"
	case types.ExpectClause:
		return "expect"
	case types.AsClause:
		return "as"
	case types.ToClause:
		return "to"
	case types.RetryClause:
		return "retry"
	case types.UnderClause:
		return "under"
	case types.ViaClause:
		return "via"
	case types.InsecureClause:
		return "insecure"
	case types.FollowClause:
		return "follow"
	case types.TimeoutClause:
		return "timeout"
	case types.BackoffClause:
		return "backoff"
	case types.PickClause:
		return "pick"
	case types.EveryClause:
		return "every"
	case types.UntilClause:
		return "until"
	case types.ProxyClause:
		return "proxy"
	case types.FieldClause:
		return "field"
	case types.VerboseClause:
		return "verbose"
	case types.ResumeClause:
		return "resume"
	// Repeatable clauses return empty string
	case types.IncludeClause, types.AttachClause:
		return ""
	default:
		return ""
	}
}

// parseClause parses a single clause.
func (p *Parser) parseClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected clause"}
	}

	tok := p.tokens[p.pos]

	// Handle flags (insecure is now a clause with =, but keep verbose and resume as flags)
	if tok.typ == tokenFlag {
		p.pos++
		switch tok.value {
		case "verbose":
			return types.VerboseClause{}, nil
		case "resume":
			return types.ResumeClause{}, nil
		}
	}

	// Handle clauses with equals
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
		key := tok.value
		p.pos += 2 // skip key and =

		switch key {
		case "with":
			return p.parseWithClause()
		case "include":
			return p.parseIncludeClause()
		case "attach":
			return p.parseAttachClause()
		case "expect":
			return p.parseExpectClause()
		case "headers":
			return p.parseHeadersClause()
		case "params":
			return p.parseParamsClause()
		case "as":
			return p.parseAsClause()
		case "to":
			return p.parseToClause()
		case "using":
			return p.parseUsingClause()
		case "retry":
			return p.parseRetryClause()
		case "backoff":
			return p.parseBackoffClause()
		case "timeout":
			return p.parseTimeoutClause()
		case "under":
			return p.parseUnderClause()
		case "proxy":
			return p.parseProxyClause()
		case "via":
			return p.parseViaClause()
		case "follow":
			return p.parseFollowClause()
		case "insecure":
			return p.parseInsecureClause()
		case "pick":
			return p.parsePickClause()
		case "every":
			return p.parseEveryClause()
		case "until":
			return p.parseUntilClause()
		case "field":
			return p.parseFieldClause()
		default:
			suggest := suggestClause(key)
			return nil, &ParseError{Position: tok.pos, Token: key, Message: "unknown clause", Suggest: suggest}
		}
	}

	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected clause"}
}

// suggestClause suggests a similar clause name.
func suggestClause(input string) string {
	clauses := []string{"with", "include", "attach", "expect", "headers", "params", "as", "to", "using", "retry", "backoff", "timeout", "under", "proxy", "via", "follow", "insecure", "pick", "every", "until", "field"}
	best := ""
	minDist := 999
	for _, c := range clauses {
		dist := levenshteinDistance(input, c)
		if dist < minDist {
			minDist = dist
			best = c
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// parseWithClause parses a "with=" clause.
func (p *Parser) parseWithClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	tok := p.tokens[p.pos]
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenColon {
		// typed value like json:...
		typeName := tok.value
		p.pos += 2 // skip type and :
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
		}
		valueTok := p.tokens[p.pos]
		p.pos++
		value := valueTok.value
		isFile := strings.HasPrefix(value, "@") && value != "@-"
		isStdin := value == "@-"
		if isFile {
			value = value[1:] // Remove @ prefix
		}
		return types.WithClause{Type: typeName, Value: value, IsFile: isFile, IsStdin: isStdin}, nil
	}

	// plain value - check for @file or @-
	valueTok := p.tokens[p.pos]
	p.pos++
	value := valueTok.value
	isFile := strings.HasPrefix(value, "@") && value != "@-"
	isStdin := value == "@-"
	if isFile {
		value = value[1:] // Remove @ prefix
	}
	
	// Infer JSON type if value starts with { or [
	typeInferred := ""
	if !isFile && !isStdin {
		trimmed := strings.TrimSpace(value)
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			typeInferred = "json"
		}
	}
	
	return types.WithClause{Value: value, Type: typeInferred, IsFile: isFile, IsStdin: isStdin}, nil
}

// parseHeadersClause parses a "headers=" clause (simplified for v0.1.0).
func (p *Parser) parseHeadersClause() (types.Clause, error) {
	// Simplified: just parse a single key:value pair for now
	// Full object parsing will come later
	return types.HeadersClause{Headers: make(map[string]string)}, nil
}

// parseParamsClause parses a "params=" clause (simplified for v0.1.0).
func (p *Parser) parseParamsClause() (types.Clause, error) {
	// Simplified: just parse a single key=value pair for now
	return types.ParamsClause{Params: make(map[string]string)}, nil
}

// parseAsClause parses an "as=" clause.
func (p *Parser) parseAsClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected format"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.AsClause{Format: tok.value}, nil
}

// parseToClause parses a "to=" clause.
func (p *Parser) parseToClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected destination"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ToClause{Destination: tok.value}, nil
}

// parseUsingClause parses a "using=" clause.
func (p *Parser) parseUsingClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected HTTP method"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	method := strings.ToUpper(tok.value)
	
	if !isValidHTTPMethod(method) {
		return nil, &ParseError{
			Position: tok.pos,
			Token:    tok.value,
			Message:  fmt.Sprintf("invalid HTTP method: %s (valid methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS)", tok.value),
		}
	}
	
	return types.UsingClause{Method: method}, nil
}

// parseRetryClause parses a "retry=" clause.
func (p *Parser) parseRetryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected retry count"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	// Parse number (simplified)
	count := 3 // default
	if tok.typ == tokenNumber {
		// In a real implementation, parse the number
		// For now, just use default
	}
	return types.RetryClause{Count: count}, nil
}

// parseBackoffClause parses a "backoff=" clause.
func (p *Parser) parseBackoffClause() (types.Clause, error) {
	// Format: backoff=200ms..5s
	if p.pos+2 >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected backoff range"}
	}

	minTok := p.tokens[p.pos]
	p.pos++
	if p.tokens[p.pos].typ != tokenDotDot {
		return nil, &ParseError{Position: p.pos, Token: p.tokens[p.pos].value, Message: "expected .."}
	}
	p.pos++
	maxTok := p.tokens[p.pos]
	p.pos++

	minDur, err := parseDuration(minTok.value)
	if err != nil {
		return nil, &ParseError{Position: minTok.pos, Token: minTok.value, Message: "invalid duration"}
	}
	maxDur, err := parseDuration(maxTok.value)
	if err != nil {
		return nil, &ParseError{Position: maxTok.pos, Token: maxTok.value, Message: "invalid duration"}
	}

	return types.BackoffClause{Min: minDur, Max: maxDur}, nil
}

// parseDuration parses a duration string.
func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

// parseTimeoutClause parses a "timeout=" clause.
func (p *Parser) parseTimeoutClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected timeout duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.TimeoutClause{Duration: dur}, nil
}

// parseProxyClause parses a "proxy=" clause.
func (p *Parser) parseProxyClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected proxy URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ProxyClause{URL: tok.value}, nil
}

// parsePickClause parses a "pick=" clause.
func (p *Parser) parsePickClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected JSONPath expression"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.PickClause{Path: tok.value}, nil
}

// parseEveryClause parses an "every=" clause.
func (p *Parser) parseEveryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected interval duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.EveryClause{Interval: dur}, nil
}

// parseUntilClause parses an "until=" clause.
func (p *Parser) parseUntilClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected predicate"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.UntilClause{Predicate: tok.value}, nil
}

// parseFieldClause parses a "field=" clause.
func (p *Parser) parseFieldClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field name"}
	}

	nameTok := p.tokens[p.pos]
	p.pos++
	if p.pos >= len(p.tokens) || p.tokens[p.pos].typ != tokenEquals {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected ="}
	}
	p.pos++
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field value"}
	}
	valueTok := p.tokens[p.pos]
	p.pos++

	return types.FieldClause{Name: nameTok.value, Value: valueTok.value}, nil
}

// parseIncludeClause parses an "include=" clause.
// Format: include='header: Name: Value; param: key=value; cookie: key=value'
func (p *Parser) parseIncludeClause() (types.Clause, error) {
	// Collect tokens until we have a complete include value
	// The value may contain colons, semicolons, and spaces
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected include value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}

	items, err := parseIncludeItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.IncludeClause{Items: items}, nil
}

// parseIncludeItems parses semicolon-separated include items.
func parseIncludeItems(value string) ([]types.IncludeItem, error) {
	var items []types.IncludeItem
	
	// Split by semicolons, but respect quoted strings
	parts := splitRespectingQuotes(value, ';')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		item, err := parseIncludeItem(part)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	
	return items, nil
}

// parseIncludeItem parses a single include item (header:, param:, cookie:).
func parseIncludeItem(part string) (types.IncludeItem, error) {
	// Find the first colon to determine the type
	colonIdx := strings.Index(part, ":")
	if colonIdx == -1 {
		return types.IncludeItem{}, fmt.Errorf("missing colon in include item: %s", part)
	}
	
	typeTag := strings.TrimSpace(part[:colonIdx])
	rest := strings.TrimSpace(part[colonIdx+1:])
	
	switch typeTag {
	case "header":
		// Format: header: Name: Value
		headerColonIdx := strings.Index(rest, ":")
		if headerColonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("header item missing Name colon Value: %s", part)
		}
		name := strings.TrimSpace(rest[:headerColonIdx])
		value := strings.TrimSpace(rest[headerColonIdx+1:])
		// Unquote if needed
		name = unquoteString(name)
		value = unquoteString(value)
		return types.IncludeItem{Type: "header", Name: name, Value: value}, nil
		
	case "param":
		// Format: param: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("param item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "param", Name: key, Value: value}, nil
		
	case "cookie":
		// Format: cookie: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("cookie item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "cookie", Name: key, Value: value}, nil
		
	default:
		return types.IncludeItem{}, fmt.Errorf("unknown include item tag: %s (expected header, param, or cookie)", typeTag)
	}
}

// splitRespectingQuotes splits a string by a delimiter while respecting quoted strings.
func splitRespectingQuotes(s string, delim rune) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	escape := false
	
	for _, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}
		
		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}
		
		if r == '\'' || r == '"' {
			inQuotes = !inQuotes
			current.WriteRune(r)
			continue
		}
		
		if r == delim && !inQuotes {
			parts = append(parts, current.String())
			current.Reset()
			continue
		}
		
		current.WriteRune(r)
	}
	
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	
	return parts
}

// unquoteString removes surrounding quotes if present and handles escapes.
func unquoteString(s string) string {
	if len(s) >= 2 && ((s[0] == '\'' && s[len(s)-1] == '\'') || (s[0] == '"' && s[len(s)-1] == '"')) {
		s = s[1 : len(s)-1]
		// Handle escapes
		var result strings.Builder
		escape := false
		for _, r := range s {
			if escape {
				if r == '\\' || r == '\'' || r == '"' {
					result.WriteRune(r)
				} else {
					result.WriteRune('\\')
					result.WriteRune(r)
				}
				escape = false
			} else if r == '\\' {
				escape = true
			} else {
				result.WriteRune(r)
			}
		}
		if escape {
			result.WriteRune('\\')
		}
		return result.String()
	}
	return s
}

// parseAttachClause parses an "attach=" clause.
// Format: attach='part: name=..., file=@path; part: name=..., value=...'
func (p *Parser) parseAttachClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected attach value"}
	}

	tok := p.tokens[p.pos]
	p.pos++

	value := tok.value
	parts, boundary, err := parseAttachItems(value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: err.Error()}
	}

	return types.AttachClause{Parts: parts, Boundary: boundary}, nil
}

// parseAttachItems parses semicolon-separated attach items.
func parseAttachItems(value string) ([]types.AttachPart, string, error) {
	var parts []types.AttachPart
	var boundary string
	
	// Split by semicolons, respecting quotes
	items := splitRespectingQuotes(value, ';')
	
	for _, item := range items {
		item = strings.TrimSpace(item)
		if item == "" {
			continue
		}
		
		// Check if it's a boundary specification
		if strings.HasPrefix(item, "boundary:") {
			boundary = strings.TrimSpace(strings.TrimPrefix(item, "boundary:"))
			boundary = unquoteString(boundary)
			continue
		}
		
		// Parse part: specification
		if !strings.HasPrefix(item, "part:") {
			return nil, "", fmt.Errorf("expected 'part:' or 'boundary:', got: %s", item)
		}
		
		partSpec := strings.TrimSpace(strings.TrimPrefix(item, "part:"))
		part, err := parseAttachPart(partSpec)
		if err != nil {
			return nil, "", err
		}
		parts = append(parts, part)
	}
	
	return parts, boundary, nil
}

// parseAttachPart parses a single attach part specification.
// Format: name=..., file=@path or value=..., optional filename=..., optional type=...
func parseAttachPart(spec string) (types.AttachPart, error) {
	var part types.AttachPart
	
	// Parse comma-separated key=value pairs
	pairs := splitRespectingQuotes(spec, ',')
	
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		eqIdx := strings.Index(pair, "=")
		if eqIdx == -1 {
			return types.AttachPart{}, fmt.Errorf("missing equals in attach part: %s", pair)
		}
		
		key := strings.TrimSpace(pair[:eqIdx])
		value := strings.TrimSpace(pair[eqIdx+1:])
		value = unquoteString(value)
		
		switch key {
		case "name":
			part.Name = value
		case "file":
			if strings.HasPrefix(value, "@") {
				part.FilePath = value[1:] // Remove @
			} else {
				part.FilePath = value
			}
		case "value":
			part.Value = value
		case "filename":
			part.Filename = value
		case "type":
			part.Type = value
		default:
			return types.AttachPart{}, fmt.Errorf("unknown attach part key: %s", key)
		}
	}
	
	// Validate: name is required
	if part.Name == "" {
		return types.AttachPart{}, fmt.Errorf("attach part missing required 'name='")
	}
	
	// Validate: exactly one of file or value
	hasFile := part.FilePath != ""
	hasValue := part.Value != ""
	if hasFile && hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part cannot have both 'file=' and 'value='")
	}
	if !hasFile && !hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part must have either 'file=' or 'value='")
	}
	
	return part, nil
}

// parseExpectClause parses an "expect=" clause.
// Format: expect=status:200, header:Content-Type=application/json, contains:"text"
func (p *Parser) parseExpectClause() (types.Clause, error) {
	// Collect tokens until we have a complete expect value
	// The value may contain colons and commas, so we need to collect multiple tokens
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected expect value"}
	}

	// Join tokens, but handle colons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon and current isn't a colon
			if valueParts[i-1] != ":" && part != ":" {
				value += " "
			}
		}
		value += part
	}
	
	checks, err := parseExpectChecks(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.ExpectClause{Checks: checks}, nil
}

// parseExpectChecks parses comma-separated expect checks.
func parseExpectChecks(value string) ([]types.ExpectCheck, error) {
	var checks []types.ExpectCheck
	
	// Split by commas, respecting quotes
	parts := splitRespectingQuotes(value, ',')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		check, err := parseExpectCheck(part)
		if err != nil {
			return nil, err
		}
		checks = append(checks, check)
	}
	
	return checks, nil
}

// parseExpectCheck parses a single expect check.
func parseExpectCheck(part string) (types.ExpectCheck, error) {
	// Unquote if needed first
	unquoted := unquoteString(part)
	
	// Check types: status:, header:, contains:, jsonpath:, matches:
	if strings.HasPrefix(unquoted, "status:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "status:"))
		return types.ExpectCheck{Type: "status", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "header:") {
		rest := strings.TrimSpace(strings.TrimPrefix(unquoted, "header:"))
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.ExpectCheck{}, fmt.Errorf("header check missing equals: %s", part)
		}
		name := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		value = unquoteString(value)
		return types.ExpectCheck{Type: "header", Name: name, Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "contains:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "contains:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "contains", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "jsonpath:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "jsonpath:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "jsonpath", Path: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "matches:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "matches:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "matches", Regex: value}, nil
	}
	
	return types.ExpectCheck{}, fmt.Errorf("unknown expect check type: %s", part)
}

// parseFollowClause parses a "follow=" clause.
func (p *Parser) parseFollowClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected follow value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "smart" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "follow accepts only 'smart'"}
	}
	
	return types.FollowClause{Policy: "smart"}, nil
}

// parseUnderClause parses an "under=" clause (duration or size).
func (p *Parser) parseUnderClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected under value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.TrimSpace(tok.value)
	
	// Try parsing as duration first
	if dur, err := parseDuration(value); err == nil {
		return types.UnderClause{Duration: dur, IsSize: false}, nil
	}
	
	// Try parsing as size (e.g., "10MB", "1GB")
	if size, err := parseSize(value); err == nil {
		return types.UnderClause{Size: size, IsSize: true}, nil
	}
	
	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "under value must be a duration (e.g., 30s) or size (e.g., 10MB)"}
}

// parseSize parses a size string like "10MB", "1GB", etc.
func parseSize(s string) (int64, error) {
	s = strings.TrimSpace(s)
	s = strings.ToUpper(s)
	
	multipliers := map[string]int64{
		"B":  1,
		"KB": 1024,
		"MB": 1024 * 1024,
		"GB": 1024 * 1024 * 1024,
		"TB": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, mult := range multipliers {
		if strings.HasSuffix(s, suffix) {
			numStr := strings.TrimSuffix(s, suffix)
			var num float64
			if _, err := fmt.Sscanf(numStr, "%f", &num); err != nil {
				return 0, err
			}
			return int64(num * float64(mult)), nil
		}
	}
	
	return 0, fmt.Errorf("unknown size suffix")
}

// parseViaClause parses a "via=" clause.
func (p *Parser) parseViaClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected via URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ViaClause{URL: tok.value}, nil
}

// parseInsecureClause parses an "insecure=" clause.
func (p *Parser) parseInsecureClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected insecure value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "true" && value != "false" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "insecure accepts only 'true' or 'false'"}
	}
	
	return types.InsecureClause{Value: value == "true"}, nil
}

----
internal/planner/plan.go
// Package planner applies defaults, validates commands, and produces execution plans.
package planner

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// ExecutionPlan represents a fully resolved execution plan ready for HTTP runtime.
type ExecutionPlan struct {
	Verb        types.Verb         `json:"verb"`
	Method      string             `json:"method"`
	URL         string             `json:"url"`
	Headers     map[string]string  `json:"headers,omitempty"`
	QueryParams map[string]string  `json:"query_params,omitempty"`
	Cookies     map[string]string  `json:"cookies,omitempty"`
	Body        *BodyPlan          `json:"body,omitempty"`
	Output      *OutputPlan        `json:"output,omitempty"`
	Retry       *RetryPlan         `json:"retry,omitempty"`
	Timeout     *time.Duration    `json:"timeout,omitempty"`
	SizeLimit   *int64            `json:"size_limit,omitempty"`
	Proxy       string             `json:"proxy,omitempty"`
	Insecure    bool               `json:"insecure,omitempty"`
	Verbose     bool               `json:"verbose,omitempty"`
	Resume      bool               `json:"resume,omitempty"`
	Follow      string             `json:"follow,omitempty"` // "smart" or empty
	Expect      []types.ExpectCheck `json:"expect,omitempty"`
}

// BodyPlan represents the request body configuration.
type BodyPlan struct {
	Type     string                `json:"type"` // json, form, multipart, raw
	Content  string                `json:"content,omitempty"`
	FilePath string                `json:"file_path,omitempty"`
	Field    string                `json:"field,omitempty"` // for multipart
	AttachParts []types.AttachPart `json:"attach_parts,omitempty"` // for multipart
	Boundary string                `json:"boundary,omitempty"` // for multipart
}

// OutputPlan represents the output configuration.
type OutputPlan struct {
	Format      string `json:"format"` // json, csv, text, raw
	Destination string `json:"destination,omitempty"`
	Pick        string `json:"pick,omitempty"` // JSONPath expression
}

// RetryPlan represents retry configuration.
type RetryPlan struct {
	Count  int           `json:"count"`
	Backoff BackoffRange `json:"backoff"`
}

// BackoffRange represents a backoff range with min and max durations.
type BackoffRange struct {
	Min time.Duration `json:"min"`
	Max time.Duration `json:"max"`
}

// Plan creates an ExecutionPlan from a parsed Command.
func Plan(cmd *types.Command) (*ExecutionPlan, error) {
	plan := &ExecutionPlan{
		Verb:        cmd.Verb,
		URL:         cmd.Target.URL,
		Headers:     make(map[string]string),
		QueryParams: make(map[string]string),
		Cookies:     make(map[string]string),
	}

	// Apply verb-specific defaults
	if err := applyVerbDefaults(cmd.Verb, plan); err != nil {
		return nil, err
	}

	// Process clauses
	for _, clause := range cmd.Clauses {
		if err := applyClause(clause, plan, cmd.Verb); err != nil {
			return nil, err
		}
	}

	// Post-process: extract filename for save verb if destination not provided or is a directory
	if cmd.Verb == types.VerbSave && plan.Output != nil {
		if plan.Output.Destination == "" {
			// No destination provided, extract from URL
			filename := extractFilenameFromURL(plan.URL)
			if filename != "" {
				plan.Output.Destination = filename
			}
		} else {
			// Destination provided - check if it's a directory
			if isDirectory(plan.Output.Destination) {
				// It's a directory, append filename from URL
				filename := extractFilenameFromURL(plan.URL)
				if filename != "" {
					plan.Output.Destination = filepath.Join(plan.Output.Destination, filename)
				}
			}
			// If it's a file path (like /tmp/file.zip), use it as-is
		}
	}

	// Validate plan
	if err := validatePlan(plan); err != nil {
		return nil, err
	}

	return plan, nil
}

// applyVerbDefaults applies default settings based on the verb.
func applyVerbDefaults(verb types.Verb, plan *ExecutionPlan) error {
	switch verb {
	case types.VerbRead:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSave:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "raw"}
	case types.VerbSend:
		// Default to GET, will be changed to POST if with= is present
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbUpload:
		// Default to POST, but will error if no attach= or with= present
		plan.Method = http.MethodPost
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbWatch:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbInspect:
		plan.Method = http.MethodHead
		plan.Output = &OutputPlan{Format: "json"}
	case types.VerbAuthenticate:
		// Default to POST if with= is present, otherwise require using=
		// We'll check this in validatePlan
		plan.Method = http.MethodPost // tentative, may be overridden
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSession:
		// Session verbs are handled separately in main
		plan.Method = http.MethodGet // placeholder
		plan.Output = &OutputPlan{Format: "auto"}
	default:
		return fmt.Errorf("unsupported verb: %s", verb)
	}
	return nil
}

// validateUsingClause validates that the HTTP method is compatible with the verb.
func validateUsingClause(verb types.Verb, method string) error {
	allowedMethods := map[types.Verb][]string{
		types.VerbRead:    {"GET", "HEAD", "OPTIONS"},
		types.VerbSave:    {"GET", "POST"},
		types.VerbSend:   {"POST", "PUT", "PATCH"},
		types.VerbUpload: {"POST", "PUT"},
		types.VerbWatch:  {"GET"},
		types.VerbInspect: {"HEAD", "GET", "OPTIONS"},
	}
	
	allowed, ok := allowedMethods[verb]
	if !ok {
		// If verb not in map, allow any method (for future verbs like delete)
		return nil
	}
	
	for _, allowedMethod := range allowed {
		if method == allowedMethod {
			return nil
		}
	}
	
	return fmt.Errorf("verb '%s' is incompatible with method '%s'", verb, method)
}

// applyClause applies a clause to the execution plan.
func applyClause(clause types.Clause, plan *ExecutionPlan, verb types.Verb) error {
	switch c := clause.(type) {
	case types.UsingClause:
		// Validate compatibility before applying
		if err := validateUsingClause(verb, c.Method); err != nil {
			return err
		}
		// Normalize to uppercase (defensive, should already be normalized in parser)
		plan.Method = strings.ToUpper(c.Method)
	case types.HeadersClause:
		for k, v := range c.Headers {
			plan.Headers[k] = v
		}
	case types.ParamsClause:
		for k, v := range c.Params {
			plan.QueryParams[k] = v
		}
	case types.WithClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		
		// Handle file or stdin
		if c.IsFile {
			plan.Body.FilePath = c.Value
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for files
			}
		} else if c.IsStdin {
			plan.Body.FilePath = "-" // Special marker for stdin
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for stdin
			}
		} else {
			plan.Body.Content = c.Value
			plan.Body.Type = c.Type
			// If type was inferred as JSON, we'll note it in runtime
			if plan.Body.Type == "json" {
				// JSON inference will be logged in runtime
			}
		}
		
		// If method is still GET and we have a body, default to POST
		if plan.Method == http.MethodGet {
			plan.Method = http.MethodPost
		}
	case types.AsClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Format = c.Format
	case types.ToClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Destination = c.Destination
	case types.RetryClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{
				Backoff: BackoffRange{
					Min: 200 * time.Millisecond,
					Max: 5 * time.Second,
				},
			}
		}
		plan.Retry.Count = c.Count
	case types.BackoffClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{Count: 3}
		}
		plan.Retry.Backoff = BackoffRange{
			Min: c.Min,
			Max: c.Max,
		}
	case types.TimeoutClause:
		plan.Timeout = &c.Duration
	case types.ProxyClause:
		plan.Proxy = c.URL
	case types.PickClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Pick = c.Path
	case types.InsecureClause:
		plan.Insecure = c.Value
	case types.ViaClause:
		plan.Proxy = c.URL
	case types.IncludeClause:
		// Merge include items into headers, params, or cookies
		for _, item := range c.Items {
			switch item.Type {
			case "header":
				// For multi-valued headers, we'd need to track arrays, but for now last wins
				// TODO: Support multi-valued headers properly
				plan.Headers[item.Name] = item.Value
			case "param":
				// Params can be repeated, so we append to query params
				// The runtime will handle serialization
				plan.QueryParams[item.Name] = item.Value
			case "cookie":
				// Cookies: last value wins
				plan.Cookies[item.Name] = item.Value
			}
		}
	case types.AttachClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		plan.Body.Type = "multipart"
		plan.Body.AttachParts = c.Parts
		if c.Boundary != "" {
			plan.Body.Boundary = c.Boundary
		}
	case types.ExpectClause:
		plan.Expect = c.Checks
	case types.FollowClause:
		plan.Follow = c.Policy
	case types.UnderClause:
		if c.IsSize {
			plan.SizeLimit = &c.Size
		} else {
			plan.Timeout = &c.Duration
		}
	case types.VerboseClause:
		plan.Verbose = true
	case types.ResumeClause:
		plan.Resume = true
	default:
		return fmt.Errorf("unsupported clause type: %T", clause)
	}
	return nil
}

// validatePlan validates the execution plan.
func validatePlan(plan *ExecutionPlan) error {
	if plan.Method == "" {
		return fmt.Errorf("method is required")
	}
	if plan.URL == "" {
		return fmt.Errorf("URL is required")
	}
	
	// Validate upload verb: must have attach= or with=
	// This check will be done after clauses are processed, so we check here
	// Actually, we need to check this in Plan() after processing clauses
	// For now, we'll do basic validation
	
	return nil
}

// extractFilenameFromURL extracts a filename from a URL.
func extractFilenameFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Get the path
	path := u.Path
	if path == "" || path == "/" {
		// Try to get from query or fragment
		return "download"
	}

	// Remove leading slash
	path = strings.TrimPrefix(path, "/")

	// Get the last segment
	parts := strings.Split(path, "/")
	if len(parts) == 0 {
		return "download"
	}

	filename := parts[len(parts)-1]

	// URL decode the filename (handle both path and query encoding)
	filename, err = url.PathUnescape(filename)
	if err != nil {
		// If PathUnescape fails, try QueryUnescape
		filename, err = url.QueryUnescape(filename)
		if err != nil {
			// If decoding fails, use the original
			filename = parts[len(parts)-1]
		}
	}

	// If filename is empty or doesn't have an extension, use a default
	if filename == "" || !strings.Contains(filename, ".") {
		filename = "download"
	}

	// Clean the filename (remove any path separators)
	filename = filepath.Base(filename)

	return filename
}

// isDirectory checks if a path is a directory.
func isDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}


----
internal/runtime/executor.go
// Package runtime executes HTTP requests based on execution plans.
package runtime

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
	"github.com/adammpkins/req/internal/session"
)

// Executor executes HTTP requests.
type Executor struct {
	client *http.Client
}

// NewExecutor creates a new executor.
func NewExecutor(plan *planner.ExecutionPlan) (*Executor, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create cookie jar: %w", err)
	}

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{},
	}

	// Configure TLS if insecure
	if plan.Insecure {
		transport.TLSClientConfig = getInsecureTLSConfig()
		fmt.Fprintf(os.Stderr, "Warning: TLS verification disabled\n")
	}

	// Configure proxy if specified
	if plan.Proxy != "" {
		proxyURL, err := url.Parse(plan.Proxy)
		if err != nil {
			return nil, fmt.Errorf("invalid proxy URL: %w", err)
		}
		transport.Proxy = http.ProxyURL(proxyURL)
	}

	client := &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
		Jar:       jar,
	}

	if plan.Timeout != nil {
		client.Timeout = *plan.Timeout
	}

	return &Executor{client: client}, nil
}

// Execute executes an HTTP request based on the plan.
func (e *Executor) Execute(plan *planner.ExecutionPlan) error {
	// Build request URL with query parameters (preserving order)
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("invalid URL: %v", err)}
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to build body: %v", err)}
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to create request: %v", err)}
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Auto-apply session if available and not explicitly set
	e.autoApplySession(req, plan)

	// Add Accept-Encoding if not set by user
	if req.Header.Get("Accept-Encoding") == "" {
		req.Header.Set("Accept-Encoding", "gzip, br")
	}

	// Execute request with redirect handling
	resp, redirectTrace, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
	}
	defer resp.Body.Close()

	// Print redirect trace to stderr
	if len(redirectTrace) > 0 {
		for _, trace := range redirectTrace {
			fmt.Fprintf(os.Stderr, "%s\n", trace)
		}
	}

	// Read and decompress response body
	bodyBytes, decompressed, err := e.readAndDecompress(resp)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("failed to read response: %v", err)}
	}

	if decompressed {
		fmt.Fprintf(os.Stderr, "Decompressed response\n")
	}

	// Print meta to stderr
	e.printMeta(resp, reqURL, len(bodyBytes), decompressed)

	// Capture session for authenticate verb
	if plan.Verb == types.VerbAuthenticate {
		host, err := session.ExtractHost(plan.URL)
		if err == nil {
			setCookies := resp.Header.Values("Set-Cookie")
			updatedSession, err := session.UpdateSessionFromResponse(host, setCookies, bodyBytes)
			if err == nil && updatedSession != nil {
				if err := session.SaveSession(updatedSession); err == nil {
					fmt.Fprintf(os.Stderr, "Session saved for %s\n", host)
				}
			}
		}
	}

	// Run expect checks
	if len(plan.Expect) > 0 {
		if err := e.runExpectChecks(resp, bodyBytes, plan.Expect); err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			return &ExecutionError{Code: 3, Message: "expectation failed"}
		}
	} else {
		// If no expect checks, fail on non-2xx status codes
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("HTTP %d %s", resp.StatusCode, resp.Status)}
		}
	}

	// Handle output based on plan
	if plan.Output != nil && plan.Output.Destination != "" {
		// Save to file - uses io.Copy for efficient writing
		// TODO: Optimize to stream directly from resp.Body when no expect checks
		return e.saveToFile(bytes.NewReader(bodyBytes), plan.Output.Destination)
	}

	// Handle watch verb with TTY detection
	if plan.Verb == types.VerbWatch {
		// TODO: Implement TTY detection
		// TTY: timestamped lines
		// Non-TTY: raw lines
		return e.writeOutput(bodyBytes, plan.Output)
	}

	// Format and write output
	return e.writeOutput(bodyBytes, plan.Output)
}

// ExecutionError represents an execution error with exit code.
type ExecutionError struct {
	Code    int
	Message string
}

func (e *ExecutionError) Error() string {
	return e.Message
}

// buildURL builds the request URL with query parameters, preserving order.
func (e *Executor) buildURL(plan *planner.ExecutionPlan) (string, error) {
	u, err := url.Parse(plan.URL)
	if err != nil {
		return "", err
	}

	// Merge existing query params with new ones
	existingParams := u.Query()
	for k, v := range plan.QueryParams {
		// Append to preserve order for repeated keys
		existingParams.Add(k, v)
	}
	u.RawQuery = existingParams.Encode()

	return u.String(), nil
}

// buildBody builds the request body.
func (e *Executor) buildBody(plan *planner.ExecutionPlan) (io.Reader, string, error) {
	if plan.Body == nil {
		return nil, "", nil
	}

	// Handle multipart
	if plan.Body.Type == "multipart" {
		return e.buildMultipartBody(plan.Body)
	}

	// Handle file or stdin
	if plan.Body.FilePath != "" {
		if plan.Body.FilePath == "-" {
			// Read from stdin
			data, err := io.ReadAll(os.Stdin)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read stdin: %w", err)
			}
			plan.Body.Content = string(data)
		} else {
			// Read from file
			data, err := os.ReadFile(plan.Body.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", plan.Body.FilePath, err)
			}
			plan.Body.Content = string(data)
		}
	}

	// Determine content type
	contentType := ""
	if plan.Body.Type == "json" {
		contentType = "application/json"
		// Log JSON inference if it was inferred
		if strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "{") || strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "[") {
			fmt.Fprintf(os.Stderr, "Inferred Content-Type: application/json\n")
		}
	} else if plan.Body.Type == "form" {
		contentType = "application/x-www-form-urlencoded"
	}

	return strings.NewReader(plan.Body.Content), contentType, nil
}

// buildMultipartBody builds a multipart/form-data body.
func (e *Executor) buildMultipartBody(bodyPlan *planner.BodyPlan) (io.Reader, string, error) {
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	boundary := bodyPlan.Boundary
	if boundary == "" {
		boundary = writer.Boundary()
	} else {
		writer.SetBoundary(boundary)
	}

	for _, part := range bodyPlan.AttachParts {
		var partWriter io.Writer
		var err error

		// Create form field
		if part.Filename != "" {
			partWriter, err = writer.CreateFormFile(part.Name, part.Filename)
		} else {
			partWriter, err = writer.CreateFormField(part.Name)
		}
		if err != nil {
			return nil, "", fmt.Errorf("failed to create form field: %w", err)
		}

		// Write part content
		if part.FilePath != "" {
			// Read file
			data, err := os.ReadFile(part.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", part.FilePath, err)
			}
			if _, err := partWriter.Write(data); err != nil {
				return nil, "", fmt.Errorf("failed to write file data: %w", err)
			}
		} else {
			// Write value
			if _, err := partWriter.Write([]byte(part.Value)); err != nil {
				return nil, "", fmt.Errorf("failed to write value: %w", err)
			}
		}
	}

	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
	return &buf, contentType, nil
}

// setHeaders sets request headers.
func (e *Executor) setHeaders(req *http.Request, plan *planner.ExecutionPlan, contentType string) {
	// Set user headers first
	for k, v := range plan.Headers {
		req.Header.Set(k, v)
	}

	// Override Content-Type if multipart (user may have set it manually)
	if plan.Body != nil && plan.Body.Type == "multipart" {
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
			// Check if user had set Content-Type manually
			if _, wasSet := plan.Headers["Content-Type"]; wasSet {
				fmt.Fprintf(os.Stderr, "Note: Content-Type overridden for multipart\n")
			}
		}
	} else if contentType != "" && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", contentType)
	}
}

// setCookies sets request cookies.
func (e *Executor) setCookies(req *http.Request, plan *planner.ExecutionPlan) {
	for name, value := range plan.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}
}

// autoApplySession automatically applies a stored session if available.
func (e *Executor) autoApplySession(req *http.Request, plan *planner.ExecutionPlan) {
	// Don't auto-apply if Authorization or Cookie headers are explicitly set
	hasAuth := req.Header.Get("Authorization") != ""
	hasCookie := false
	for name := range plan.Cookies {
		if name != "" {
			hasCookie = true
			break
		}
	}
	if hasAuth || hasCookie {
		return
	}

	// Extract host from URL
	host, err := session.ExtractHost(plan.URL)
	if err != nil {
		return
	}

	// Load session
	sess, err := session.LoadSession(host)
	if err != nil || sess == nil {
		return
	}

	// Apply authorization if available
	if sess.Authorization != "" {
		req.Header.Set("Authorization", sess.Authorization)
	}

	// Apply cookies
	for name, value := range sess.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}

	fmt.Fprintf(os.Stderr, "Using session for %s\n", host)
}

// executeWithRedirects executes the request with redirect handling.
func (e *Executor) executeWithRedirects(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, error) {
	maxRedirects := 5
	var redirectTrace []string

	// Determine redirect policy based on verb
	shouldFollow := false
	isWriteVerb := plan.Method == "POST" || plan.Method == "PUT" || plan.Method == "PATCH" || plan.Method == "DELETE"

	if plan.Follow == "smart" {
		// Smart follow: only follow 307/308 for write verbs
		shouldFollow = true
	} else {
		// Default: read and save follow, write verbs don't
		if plan.Verb == types.VerbRead || plan.Verb == types.VerbSave {
			shouldFollow = true
		} else if isWriteVerb {
			shouldFollow = false
		} else {
			// Other verbs (watch, inspect) don't follow by default
			shouldFollow = false
		}
	}

	if !shouldFollow {
		resp, err := e.client.Do(req)
		if err == nil && isWriteVerb && (resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303) {
			redirectTrace = append(redirectTrace, fmt.Sprintf("Advisory: %d redirect for write verb, not following", resp.StatusCode))
		}
		return resp, redirectTrace, err
	}

	// Follow redirects
	redirects := 0
	client := *e.client
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if redirects >= maxRedirects {
			return fmt.Errorf("stopped after %d redirects", maxRedirects)
		}

		// For smart follow with write verbs, only follow 307/308
		if plan.Follow == "smart" && isWriteVerb {
			statusCode := via[len(via)-1].Response.StatusCode
			if statusCode != 307 && statusCode != 308 {
				return fmt.Errorf("write verb: not following %d redirect (use 307/308)", statusCode)
			}
		}

		redirects++
		statusCode := via[len(via)-1].Response.StatusCode
		redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", statusCode, req.Method, req.URL.String()))
		return nil
	}

	resp, err := client.Do(req)
	return resp, redirectTrace, err
}

// readAndDecompress reads and decompresses the response body.
func (e *Executor) readAndDecompress(resp *http.Response) ([]byte, bool, error) {
	body := resp.Body
	decompressed := false

	// Check if compressed
	encoding := resp.Header.Get("Content-Encoding")
	if encoding == "gzip" {
		reader, err := gzip.NewReader(body)
		if err != nil {
			return nil, false, fmt.Errorf("failed to create gzip reader: %w", err)
		}
		defer reader.Close()
		body = reader
		decompressed = true
	} else if encoding == "br" {
		// Brotli decompression would require a library
		// For now, just read as-is
		// TODO: Add brotli support
	}

	data, err := io.ReadAll(body)
	return data, decompressed, err
}

// runExpectChecks runs expectation checks on the response.
func (e *Executor) runExpectChecks(resp *http.Response, body []byte, checks []types.ExpectCheck) error {
	for _, check := range checks {
		if err := e.runExpectCheck(resp, body, check); err != nil {
			return err
		}
	}
	return nil
}

// runExpectCheck runs a single expectation check.
func (e *Executor) runExpectCheck(resp *http.Response, body []byte, check types.ExpectCheck) error {
	switch check.Type {
	case "status":
		expected := check.Value
		actual := fmt.Sprintf("%d", resp.StatusCode)
		if actual != expected {
			return fmt.Errorf("expected status %s, got %s", expected, actual)
		}

	case "header":
		actual := resp.Header.Get(check.Name)
		if actual != check.Value {
			return fmt.Errorf("expected header %s=%s, got %s", check.Name, check.Value, actual)
		}

	case "contains":
		if !strings.Contains(string(body), check.Value) {
			return fmt.Errorf("expected body to contain %q", check.Value)
		}

	case "jsonpath":
		// Simple JSON path extraction (basic implementation)
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			return fmt.Errorf("failed to parse JSON: %w", err)
		}
		// TODO: Implement proper JSONPath evaluation
		// For now, just check if JSON is valid
		_ = data

	case "matches":
		matched, err := regexp.MatchString(check.Regex, string(body))
		if err != nil {
			return fmt.Errorf("invalid regex: %w", err)
		}
		if !matched {
			return fmt.Errorf("body does not match regex %q", check.Regex)
		}

	default:
		return fmt.Errorf("unknown expect check type: %s", check.Type)
	}

	return nil
}

// printMeta prints metadata to stderr.
func (e *Executor) printMeta(resp *http.Response, url string, bodySize int, decompressed bool) {
	fmt.Fprintf(os.Stderr, "HTTP %d\n", resp.StatusCode)
	fmt.Fprintf(os.Stderr, "URL: %s\n", url)
	fmt.Fprintf(os.Stderr, "Size: %d bytes\n", bodySize)
	if ct := resp.Header.Get("Content-Type"); ct != "" {
		fmt.Fprintf(os.Stderr, "Content-Type: %s\n", ct)
	}
}

// writeOutput formats and writes output to stdout.
func (e *Executor) writeOutput(body []byte, output *planner.OutputPlan) error {
	if output == nil {
		// Default: raw output
		_, err := os.Stdout.Write(body)
		return err
	}

	switch output.Format {
	case "json":
		// Pretty print JSON
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			// Not JSON, output as-is
			_, err := os.Stdout.Write(body)
			return err
		}
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)

	case "text":
		// Output as text
		_, err := os.Stdout.Write(body)
		return err

	case "raw":
		// Raw output
		_, err := os.Stdout.Write(body)
		return err

	case "csv":
		// CSV output (basic - would need proper CSV parsing)
		_, err := os.Stdout.Write(body)
		return err

	default:
		// Default: raw
		_, err := os.Stdout.Write(body)
		return err
	}
}

// saveToFile saves the response body to a file.
func (e *Executor) saveToFile(body io.Reader, destination string) error {
	// Create directory if needed
	dir := filepath.Dir(destination)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Create file
	file, err := os.Create(destination)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Copy response body to file
	_, err = io.Copy(file, body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// getInsecureTLSConfig returns an insecure TLS config.
func getInsecureTLSConfig() *tls.Config {
	return &tls.Config{
		InsecureSkipVerify: true,
	}
}

// ExecuteWithResponse executes an HTTP request and returns the response body as a string.
// This is useful for TUI mode where we need to capture and format the response.
func (e *Executor) ExecuteWithResponse(plan *planner.ExecutionPlan) (string, error) {
	// Build request URL with query parameters
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return "", fmt.Errorf("failed to build body: %w", err)
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Execute request
	resp, _, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and decompress response body
	bodyBytes, _, err := e.readAndDecompress(resp)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(bodyBytes), nil
}

----
internal/session/session.go
// Package session manages HTTP sessions (cookies and tokens) per host.
package session

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Session represents a stored session for a host.
type Session struct {
	Host          string            `json:"host"`
	Cookies       map[string]string `json:"cookies,omitempty"`
	Authorization string            `json:"authorization,omitempty"` // Bearer token
}

var (
	stateDir     string
	stateDirOnce sync.Once
)

// getStateDir returns the user state directory for storing sessions.
func getStateDir() string {
	stateDirOnce.Do(func() {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to current directory
			stateDir = ".req"
			return
		}
		stateDir = filepath.Join(homeDir, ".config", "req")
	})
	return stateDir
}

// ensureStateDir ensures the state directory exists with proper permissions.
func ensureStateDir() error {
	dir := getStateDir()
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}
	return nil
}

// getSessionPath returns the file path for a host's session.
func getSessionPath(host string) (string, error) {
	if err := ensureStateDir(); err != nil {
		return "", err
	}
	// Sanitize host name for filename
	safeHost := strings.ReplaceAll(host, ":", "_")
	safeHost = strings.ReplaceAll(safeHost, "/", "_")
	return filepath.Join(getStateDir(), fmt.Sprintf("session_%s.json", safeHost)), nil
}

// LoadSession loads a session for the given host.
func LoadSession(host string) (*Session, error) {
	path, err := getSessionPath(host)
	if err != nil {
		return nil, err
	}

	// Check file permissions - refuse to load if group or world readable
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // No session exists
		}
		return nil, fmt.Errorf("failed to stat session file: %w", err)
	}

	mode := info.Mode().Perm()
	// Check if group or others have read permission (044, 004, or any combination)
	if mode&0044 != 0 {
		return nil, fmt.Errorf("session file %s has insecure permissions (%s): group or world readable, refusing to load", path, mode.String())
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read session: %w", err)
	}

	var session Session
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, fmt.Errorf("failed to parse session: %w", err)
	}

	return &session, nil
}

// SaveSession saves a session for the given host.
func SaveSession(session *Session) error {
	path, err := getSessionPath(session.Host)
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal session: %w", err)
	}

	// Write with strict permissions (0600)
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write session: %w", err)
	}

	return nil
}

// DeleteSession deletes a session for the given host.
func DeleteSession(host string) error {
	path, err := getSessionPath(host)
	if err != nil {
		return err
	}

	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil // Already deleted
		}
		return fmt.Errorf("failed to delete session: %w", err)
	}

	return nil
}

// ExtractHost extracts the host from a URL.
func ExtractHost(urlStr string) (string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}
	return u.Host, nil
}

// UpdateSessionFromResponse updates a session from an HTTP response.
// Captures Set-Cookie headers and access_token from JSON body.
func UpdateSessionFromResponse(host string, setCookies []string, body []byte) (*Session, error) {
	session, err := LoadSession(host)
	if err != nil {
		return nil, err
	}

	if session == nil {
		session = &Session{
			Host:    host,
			Cookies: make(map[string]string),
		}
	}

	// Parse Set-Cookie headers
	for _, cookieHeader := range setCookies {
		// Simple cookie parsing (just get name=value part)
		parts := strings.Split(cookieHeader, ";")
		if len(parts) > 0 {
			cookiePart := strings.TrimSpace(parts[0])
			eqIdx := strings.Index(cookiePart, "=")
			if eqIdx > 0 {
				name := cookiePart[:eqIdx]
				value := cookiePart[eqIdx+1:]
				session.Cookies[name] = value
			}
		}
	}

	// Try to extract access_token from JSON body
	if len(body) > 0 {
		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err == nil {
			if token, ok := jsonData["access_token"].(string); ok && token != "" {
				session.Authorization = "Bearer " + token
			}
		}
	}

	return session, nil
}

// ListSessions lists all stored sessions.
func ListSessions() ([]string, error) {
	dir := getStateDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read state directory: %w", err)
	}

	var hosts []string
	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "session_") && strings.HasSuffix(entry.Name(), ".json") {
			// Extract host from filename
			host := strings.TrimPrefix(entry.Name(), "session_")
			host = strings.TrimSuffix(host, ".json")
			host = strings.ReplaceAll(host, "_", ":")
			hosts = append(hosts, host)
		}
	}

	return hosts, nil
}

// RedactSession creates a redacted version of a session for display.
func RedactSession(session *Session) *Session {
	redacted := &Session{
		Host:          session.Host,
		Cookies:       make(map[string]string),
		Authorization: "",
	}

	// Redact cookies (show only names)
	for name := range session.Cookies {
		redacted.Cookies[name] = "***"
	}

	// Redact authorization
	if session.Authorization != "" {
		redacted.Authorization = "Bearer ***"
	}

	return redacted
}


----
internal/tui/app.go
// Package tui provides an interactive terminal user interface for req.
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/adammpkins/req/internal/tui/views"
)

// Launch starts the TUI application.
func Launch() error {
	p := tea.NewProgram(NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run TUI: %w", err)
	}
	return nil
}

// Model represents the application state.
type Model struct {
	view View
}

// NewModel creates a new TUI model.
func NewModel() Model {
	return Model{
		view: views.NewBuilderView(),
	}
}

// Init initializes the model.
func (m Model) Init() tea.Cmd {
	// WindowSizeMsg will be sent automatically by bubbletea
	return m.view.Init()
}

// Update handles messages and updates the model.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		// Pass window size to view
		var cmd tea.Cmd
		m.view, cmd = m.view.Update(msg)
		return m, cmd
	}

	var cmd tea.Cmd
	m.view, cmd = m.view.Update(msg)
	return m, cmd
}

// View renders the current view.
func (m Model) View() string {
	return m.view.View()
}

// View represents a TUI view (exported from views package).
type View = views.View


----
internal/tui/views/builder.go
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("62")).
			Padding(1, 2)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Padding(1, 2).
			Width(80)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46")).
			Padding(1, 2).
			Width(80)

	commandStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252")).
			Padding(1, 2).
			Width(80)

	// JSON syntax highlighting styles
	jsonKeyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true)

	jsonStringStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46"))

	jsonNumberStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("220"))

	jsonBoolStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("213"))

	jsonNullStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			Italic(true)

	jsonPunctStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252"))

	outputStyle = lipgloss.NewStyle().
			Padding(1, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("62"))
)

// View represents a TUI view interface.
type View interface {
	Init() tea.Cmd
	Update(msg tea.Msg) (View, tea.Cmd)
	View() string
}

// BuilderView is an interactive command builder.
type BuilderView struct {
	form         *huh.Form
	executed     bool
	response     string
	responseBody string
	formattedBody string
	err          error
	verb         string
	url          string
	execute      bool
	width        int
	height       int
	viewport     viewport.Model
}

// NewBuilderView creates a new builder view.
func NewBuilderView() View {
	vp := viewport.New(80, 20) // default width and height
	b := &BuilderView{
		width:    80, // default width
		height:   20, // default height
		viewport: vp,
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Verb").
				Description("Select the action to perform").
				Options(
					huh.NewOption("read - Read a resource (GET)", "read"),
					huh.NewOption("save - Save a resource to file (GET)", "save"),
					huh.NewOption("send - Send data (POST)", "send"),
				).
				Value(&b.verb).
				Key("verb"),

			huh.NewInput().
				Title("URL").
				Description("Enter the target URL").
				Placeholder("https://api.example.com/users").
				Value(&b.url).
				Key("url"),

			huh.NewConfirm().
				Title("Execute immediately?").
				Description("Execute the command when form is complete").
				Value(&b.execute).
				Key("execute"),
		),
	)

	b.form = form
	return b
}

// Init initializes the view.
func (b *BuilderView) Init() tea.Cmd {
	return b.form.Init()
}

// Update handles messages.
func (b *BuilderView) Update(msg tea.Msg) (View, tea.Cmd) {
	var cmds []tea.Cmd

	// Handle window size messages first
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		b.width = msg.Width
		b.height = msg.Height
		if b.width == 0 {
			b.width = 80 // default width
		}
		if b.height == 0 {
			b.height = 20 // default height
		}
		// Update viewport size
		b.updateViewportSize()
	}

	// Handle keyboard input
	switch msg := msg.(type) {
	case tea.KeyMsg:
		key := msg.String()
		
		// If we have output to scroll, handle scrolling keys first
		if b.formattedBody != "" {
			// Check if it's a scrolling key
			switch key {
			case "up", "k", "pgup":
				b.viewport.LineUp(1)
				return b, nil
			case "down", "j", "pgdown":
				b.viewport.LineDown(1)
				return b, nil
			case "home":
				b.viewport.GotoTop()
				return b, nil
			case "end":
				b.viewport.GotoBottom()
				return b, nil
			case "ctrl+u":
				b.viewport.LineUp(b.viewport.Height / 2)
				return b, nil
			case "ctrl+d":
				b.viewport.LineDown(b.viewport.Height / 2)
				return b, nil
			case "esc":
				return b, tea.Quit
			}
		} else {
			// No output, just handle quit
			switch key {
			case "esc":
				return b, tea.Quit
			}
		}
	}

	// Update form (only if not a scrolling key when we have output)
	form, cmd := b.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		b.form = f
		cmds = append(cmds, cmd)
	}

	// Handle messages from command execution
	switch msg := msg.(type) {
	case ErrorMsg:
		b.err = msg.Err
		b.executed = false
		b.responseBody = ""
		b.formattedBody = ""
		b.viewport.SetContent("")
	case SuccessMsg:
		b.response = msg.Message
		b.responseBody = msg.ResponseBody
		b.err = nil
		// Format the response body
		b.updateFormattedBody()
	}
	
	// Handle viewport updates for other messages (like mouse wheel, etc.)
	if b.formattedBody != "" {
		vp, cmd := b.viewport.Update(msg)
		b.viewport = vp
		if cmd != nil {
			cmds = append(cmds, cmd)
		}
	}

	// Check if form is complete and should execute
	if b.form.State == huh.StateCompleted {
		if !b.executed && b.verb != "" && b.url != "" {
			// Values are already bound to b.verb, b.url, and b.execute via Value() in form creation
			// The bound variables are updated automatically when form fields change
			if b.execute {
				b.executed = true
				cmds = append(cmds, b.executeCommand())
			} else {
				// Form completed but execute was false - show message
				b.response = "Command built but not executed. Press 'esc' to exit."
			}
		}
	}

	return b, tea.Batch(cmds...)
}

// executeCommand executes the built command.
func (b *BuilderView) executeCommand() tea.Cmd {
	return func() tea.Msg {
		// Build command string
		cmdStr := fmt.Sprintf("%s %s", b.verb, b.url)
		
		// Parse command
		cmd, err := parser.Parse(cmdStr)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Plan execution
		plan, err := planner.Plan(cmd)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Execute
		executor, err := runtime.NewExecutor(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Capture response body for TUI display
		responseBody, err := executor.ExecuteWithResponse(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		return SuccessMsg{
			Message:      "Command executed successfully",
			ResponseBody: responseBody,
		}
	}
}

// View renders the view.
func (b *BuilderView) View() string {
	var s strings.Builder

	s.WriteString(titleStyle.Render("req - Interactive Command Builder"))
	s.WriteString("\n\n")

	if b.err != nil {
		s.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", b.err)))
		s.WriteString("\n\n")
	}

	if b.response != "" {
		s.WriteString(successStyle.Render(b.response))
		s.WriteString("\n\n")
	}

	// Display response body with formatting (using viewport for scrolling)
	if b.formattedBody != "" {
		// Calculate available width and height for viewport
		contentWidth := b.width - 6 // Account for border and padding
		if contentWidth < 20 {
			contentWidth = 20 // Minimum width
		}
		
		// Calculate available height (account for header, success message, form, command line, instructions)
		// Rough estimate: title ~3, success ~2, form ~varies, command ~2, instructions ~1 = ~8-10 lines
		// Reserve some space for the form and other UI elements
		availableHeight := b.height - 15 // Reserve space for other UI elements
		if availableHeight < 5 {
			availableHeight = 5 // Minimum height
		}
		
		// Update viewport dimensions if needed
		b.updateViewportSize()
		
		// Render viewport with border
		// The viewport handles its own height, so we just need to wrap it with the border style
		viewportContent := b.viewport.View()
		// Use the viewport's actual dimensions for the border
		s.WriteString(outputStyle.Width(contentWidth + 4).Render(viewportContent))
		s.WriteString("\n\n")
	}

	s.WriteString(b.form.View())
	
	// Show current values when form is completed
	if b.form.State == huh.StateCompleted {
		s.WriteString("\n\n")
		if b.verb != "" && b.url != "" {
			cmdText := fmt.Sprintf("Command: %s %s", b.verb, b.url)
			// Wrap the command text to fit terminal width
			width := b.width
			if width == 0 {
				width = 80 // default width
			}
			wrapped := wrapText(cmdText, width)
			s.WriteString(commandStyle.Render(wrapped))
			s.WriteString("\n")
			if b.response != "" {
				s.WriteString("\n")
			}
		}
	}
	
	s.WriteString("\n")
	if b.formattedBody != "" {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit, ↑/↓ to scroll, pgup/pgdn for page scroll\n")
	} else {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit\n")
	}

	return s.String()
}

// ErrorMsg represents an error message.
type ErrorMsg struct {
	Err error
}

// SuccessMsg represents a success message.
type SuccessMsg struct {
	Message      string
	ResponseBody string
}

// wrapText wraps text to the specified width, breaking at word boundaries.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}
	
	var result strings.Builder
	words := strings.Fields(text)
	currentLine := ""
	
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		if len(testLine) > width {
			if currentLine != "" {
				result.WriteString(currentLine)
				result.WriteString("\n")
				currentLine = word
			} else {
				// Word is longer than width, just add it
				result.WriteString(word)
				result.WriteString("\n")
				currentLine = ""
			}
		} else {
			currentLine = testLine
		}
	}
	
	if currentLine != "" {
		result.WriteString(currentLine)
	}
	
	return result.String()
}

// updateFormattedBody formats the response body and updates the viewport content.
func (b *BuilderView) updateFormattedBody() {
	if b.responseBody == "" {
		b.formattedBody = ""
		b.viewport.SetContent("")
		return
	}
	
	// Calculate available width for content
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	// Format the response
	formatted := formatResponse(b.responseBody, contentWidth)
	b.formattedBody = formatted
	
	// Update viewport content
	b.viewport.SetContent(formatted)
	b.viewport.GotoTop() // Start at the top
}

// updateViewportSize updates the viewport dimensions based on available space.
func (b *BuilderView) updateViewportSize() {
	if b.responseBody == "" {
		return
	}
	
	// Calculate available width and height
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	availableHeight := b.height - 15 // Reserve space for other UI elements
	if availableHeight < 5 {
		availableHeight = 5 // Minimum height
	}
	
	// Update viewport dimensions
	b.viewport.Width = contentWidth
	b.viewport.Height = availableHeight
	
	// If content is already set, ensure it's properly sized
	if b.formattedBody != "" {
		b.viewport.SetContent(b.formattedBody)
	}
}

// formatResponse formats the response body with syntax highlighting for JSON.
func formatResponse(body string, width int) string {
	// Try to parse as JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(body), &jsonData); err == nil {
		// It's valid JSON, format it with syntax highlighting
		return formatJSON(body, width)
	}

	// Not JSON, return as-is with word wrapping
	return wrapText(body, width)
}

// formatJSON formats JSON with syntax highlighting using lipgloss.
func formatJSON(jsonStr string, width int) string {
	// First, pretty-print the JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(jsonStr), &jsonData); err != nil {
		return jsonStr // Return original if parsing fails
	}

	prettyJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return jsonStr // Return original if formatting fails
	}

	// Now apply syntax highlighting
	lines := strings.Split(string(prettyJSON), "\n")
	var formattedLines []string

	for _, line := range lines {
		formattedLine := highlightJSONLine(line)
		formattedLines = append(formattedLines, formattedLine)
	}

	return strings.Join(formattedLines, "\n")
}

// highlightJSONLine applies syntax highlighting to a single line of JSON.
func highlightJSONLine(line string) string {
	// This is a simple JSON highlighter that handles common cases
	// For a more robust solution, consider using a proper JSON tokenizer
	
	result := ""
	i := 0
	
	for i < len(line) {
		char := line[i]
		
		// Skip whitespace
		if char == ' ' || char == '\t' {
			result += string(char)
			i++
			continue
		}
		
		// Handle string literals
		if char == '"' {
			end := i + 1
			escaped := false
			for end < len(line) {
				if line[end] == '\\' && !escaped {
					escaped = true
					end++
				} else if line[end] == '"' && !escaped {
					end++
					// Check if this is a key (followed by :)
					isKey := end < len(line) && line[end] == ':'
					str := line[i:end]
					if isKey {
						result += jsonKeyStyle.Render(str)
					} else {
						result += jsonStringStyle.Render(str)
					}
					i = end
					break
				} else {
					escaped = false
					end++
				}
			}
			if end >= len(line) {
				// Unterminated string, just add it
				result += jsonStringStyle.Render(line[i:])
				break
			}
			continue
		}
		
		// Handle numbers
		if (char >= '0' && char <= '9') || char == '-' {
			start := i
			for i < len(line) && ((line[i] >= '0' && line[i] <= '9') || 
				line[i] == '.' || line[i] == 'e' || line[i] == 'E' || 
				line[i] == '+' || line[i] == '-' || line[i] == 'i' || 
				line[i] == 'n' || line[i] == 'f') {
				i++
			}
			result += jsonNumberStyle.Render(line[start:i])
			continue
		}
		
		// Handle boolean and null
		if strings.HasPrefix(line[i:], "true") {
			result += jsonBoolStyle.Render("true")
			i += 4
			continue
		}
		if strings.HasPrefix(line[i:], "false") {
			result += jsonBoolStyle.Render("false")
			i += 5
			continue
		}
		if strings.HasPrefix(line[i:], "null") {
			result += jsonNullStyle.Render("null")
			i += 4
			continue
		}
		
		// Handle punctuation
		if char == '{' || char == '}' || char == '[' || char == ']' || 
		   char == ',' || char == ':' {
			result += jsonPunctStyle.Render(string(char))
			i++
			continue
		}
		
		// Default: just add the character
		result += string(char)
		i++
	}
	
	return result
}

----
internal/types/command.go
// Package types provides shared types and enums used across the req package.
package types

import "time"

// Verb represents the action verb in a req command.
type Verb string

const (
	VerbRead         Verb = "read"
	VerbSave         Verb = "save"
	VerbSend         Verb = "send"
	VerbUpload       Verb = "upload"
	VerbWatch        Verb = "watch"
	VerbInspect      Verb = "inspect"
	VerbAuthenticate Verb = "authenticate"
	VerbSession      Verb = "session"
)

// Command represents a parsed req command AST.
type Command struct {
	Verb    Verb
	Target  Target
	Clauses []Clause
	// For session verb, subcommand (show, clear, use)
	SessionSubcommand string
}

// Target represents the URL or resource being acted upon.
type Target struct {
	URL string
}

// Clause represents a modifier clause in the command.
// This is a sum type that will be expanded as we add more clause types.
type Clause interface {
	clause()
}

// WithClause represents a "with=" clause for request body.
type WithClause struct {
	Value    string // inline value, file path, or "-" for stdin
	Type     string // json, form, etc. (inferred if empty)
	IsFile   bool   // true if value starts with @
	IsStdin  bool   // true if value is @-
}

func (WithClause) clause() {}

// HeadersClause represents a "headers=" clause.
type HeadersClause struct {
	Headers map[string]string
}

func (HeadersClause) clause() {}

// ParamsClause represents a "params=" clause for query parameters.
type ParamsClause struct {
	Params map[string]string
}

func (ParamsClause) clause() {}

// AsClause represents an "as=" clause for output format.
type AsClause struct {
	Format string // json, csv, text, raw
}

func (AsClause) clause() {}

// ToClause represents a "to=" clause for destination.
type ToClause struct {
	Destination string
}

func (ToClause) clause() {}

// UsingClause represents a "using=" clause for HTTP method override.
type UsingClause struct {
	Method string // GET, POST, PUT, PATCH, DELETE, etc.
}

func (UsingClause) clause() {}

// RetryClause represents a "retry=" clause.
type RetryClause struct {
	Count int
}

func (RetryClause) clause() {}

// BackoffClause represents a "backoff=" clause.
type BackoffClause struct {
	Min time.Duration
	Max time.Duration
}

func (BackoffClause) clause() {}

// TimeoutClause represents a "timeout=" clause.
type TimeoutClause struct {
	Duration time.Duration
}

func (TimeoutClause) clause() {}

// ProxyClause represents a "proxy=" clause.
type ProxyClause struct {
	URL string
}

func (ProxyClause) clause() {}

// PickClause represents a "pick=" clause for JSON path selection.
type PickClause struct {
	Path string // JSONPath expression
}

func (PickClause) clause() {}

// EveryClause represents an "every=" clause for polling.
type EveryClause struct {
	Interval time.Duration
}

func (EveryClause) clause() {}

// UntilClause represents an "until=" clause for conditional polling.
type UntilClause struct {
	Predicate string
}

func (UntilClause) clause() {}

// FieldClause represents a "field=" clause for multipart uploads.
type FieldClause struct {
	Name  string
	Value string
}

func (FieldClause) clause() {}

// VerboseClause represents the "verbose" flag.
type VerboseClause struct{}

func (VerboseClause) clause() {}

// ResumeClause represents the "resume" flag for resumable downloads.
type ResumeClause struct{}

func (ResumeClause) clause() {}

// IncludeClause represents an "include=" clause for headers, params, and cookies.
type IncludeClause struct {
	Items []IncludeItem
}

func (IncludeClause) clause() {}

// IncludeItem represents a single item in an include clause.
type IncludeItem struct {
	Type  string // "header", "param", "cookie"
	Name  string // header name, param key, or cookie key
	Value string // header value, param value, or cookie value
}

// AttachClause represents an "attach=" clause for multipart form data.
type AttachClause struct {
	Parts    []AttachPart
	Boundary string // optional explicit boundary
}

func (AttachClause) clause() {}

// AttachPart represents a single part in an attach clause.
type AttachPart struct {
	Name     string // required
	FilePath string // file=@path (mutually exclusive with Value)
	Value    string // value=... (mutually exclusive with FilePath)
	Filename string // optional filename
	Type     string // optional Content-Type
}

// ExpectClause represents an "expect=" clause for response assertions.
type ExpectClause struct {
	Checks []ExpectCheck
}

func (ExpectClause) clause() {}

// ExpectCheck represents a single assertion check.
type ExpectCheck struct {
	Type  string // "status", "header", "contains", "jsonpath", "matches"
	Name  string // for header checks, the header name
	Value string // the value to check against
	Path  string // for jsonpath, the JSONPath expression
	Regex string // for matches, the regex pattern
}

// FollowClause represents a "follow=" clause for redirect policy.
type FollowClause struct {
	Policy string // "smart" or empty for default
}

func (FollowClause) clause() {}

// UnderClause represents an "under=" clause for timeout or size limit.
type UnderClause struct {
	Duration time.Duration // if it's a duration
	Size     int64         // if it's a size (in bytes)
	IsSize   bool          // true if it's a size limit, false if duration
}

func (UnderClause) clause() {}

// ViaClause represents a "via=" clause for proxy URL.
type ViaClause struct {
	URL string
}

func (ViaClause) clause() {}

// InsecureClause represents an "insecure=" clause (updated to support true/false).
type InsecureClause struct {
	Value bool // true or false
}

func (InsecureClause) clause() {}



----
tests/fixtures/grammar_snapshot.json
{
  "verbs": [
    "read",
    "save",
    "send",
    "upload",
    "watch",
    "inspect",
    "authenticate",
    "session"
  ],
  "clauses": [
    {
      "name": "using=",
      "description": "HTTP method override",
      "repeatable": false
    },
    {
      "name": "include=",
      "description": "Add headers, params, cookies",
      "repeatable": true
    },
    {
      "name": "with=",
      "description": "Request body",
      "repeatable": false
    },
    {
      "name": "expect=",
      "description": "Assertions on response",
      "repeatable": false
    },
    {
      "name": "as=",
      "description": "Output format for stdout",
      "repeatable": false
    },
    {
      "name": "to=",
      "description": "Destination path",
      "repeatable": false
    },
    {
      "name": "retry=",
      "description": "Retry attempts for transient errors",
      "repeatable": false
    },
    {
      "name": "under=",
      "description": "Timeout or size limit",
      "repeatable": false
    },
    {
      "name": "via=",
      "description": "Proxy URL",
      "repeatable": false
    },
    {
      "name": "attach=",
      "description": "Multipart parts for upload or send",
      "repeatable": true
    },
    {
      "name": "follow=",
      "description": "Redirect policy for write verbs",
      "repeatable": false
    },
    {
      "name": "insecure=",
      "description": "Disable TLS verification for this request",
      "repeatable": false
    }
  ]
}


----
tests/grammar_drift_test.go
package tests

import (
	"encoding/json"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/grammar"
)

// TestGrammarDrift ensures the binary help output matches the grammar snapshot.
func TestGrammarDrift(t *testing.T) {
	// Get expected snapshot from grammar package
	expectedJSON, err := grammar.GetSnapshotJSON()
	if err != nil {
		t.Fatalf("Failed to generate expected snapshot: %v", err)
	}

	var expected grammar.Snapshot
	if err := json.Unmarshal(expectedJSON, &expected); err != nil {
		t.Fatalf("Failed to unmarshal expected snapshot: %v", err)
	}

	// Load actual snapshot from file
	snapshotPath := filepath.Join("fixtures", "grammar_snapshot.json")
	actualJSON, err := os.ReadFile(snapshotPath)
	if err != nil {
		t.Fatalf("Failed to read snapshot file: %v", err)
	}

	var actual grammar.Snapshot
	if err := json.Unmarshal(actualJSON, &actual); err != nil {
		t.Fatalf("Failed to unmarshal actual snapshot: %v", err)
	}

	// Compare verbs
	if len(expected.Verbs) != len(actual.Verbs) {
		t.Errorf("Verb count mismatch: expected %d, got %d", len(expected.Verbs), len(actual.Verbs))
	}

	expectedVerbs := make(map[string]bool)
	for _, v := range expected.Verbs {
		expectedVerbs[v] = true
	}
	for _, v := range actual.Verbs {
		if !expectedVerbs[v] {
			t.Errorf("Unexpected verb in snapshot: %s", v)
		}
	}
	for _, v := range expected.Verbs {
		found := false
		for _, av := range actual.Verbs {
			if av == v {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Missing verb in snapshot: %s", v)
		}
	}

	// Compare clauses
	if len(expected.Clauses) != len(actual.Clauses) {
		t.Errorf("Clause count mismatch: expected %d, got %d", len(expected.Clauses), len(actual.Clauses))
	}

	expectedClauses := make(map[string]grammar.ClauseSnapshot)
	for _, c := range expected.Clauses {
		expectedClauses[c.Name] = c
	}

	for _, ac := range actual.Clauses {
		ec, ok := expectedClauses[ac.Name]
		if !ok {
			t.Errorf("Unexpected clause in snapshot: %s", ac.Name)
			continue
		}
		if ec.Description != ac.Description {
			t.Errorf("Clause %s description mismatch: expected %q, got %q", ac.Name, ec.Description, ac.Description)
		}
		if ec.Repeatable != ac.Repeatable {
			t.Errorf("Clause %s repeatable mismatch: expected %v, got %v", ac.Name, ec.Repeatable, ac.Repeatable)
		}
	}

	for _, ec := range expected.Clauses {
		found := false
		for _, ac := range actual.Clauses {
			if ac.Name == ec.Name {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Missing clause in snapshot: %s", ec.Name)
		}
	}
}

// TestBinaryHelpDrift ensures the binary help output matches the grammar.
func TestBinaryHelpDrift(t *testing.T) {
	// Build the binary
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	// Run req help
	cmd := exec.Command(binaryPath, "help")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Failed to run req help: %v", err)
	}

	helpText := string(output)

	// Get grammar
	g := grammar.GetGrammar()

	// Check that all verbs appear in help
	for _, verb := range g.Verbs {
		if !strings.Contains(helpText, verb.Name) {
			t.Errorf("Verb %s not found in help output", verb.Name)
		}
		if !strings.Contains(helpText, verb.Description) {
			t.Errorf("Verb %s description not found in help output", verb.Name)
		}
	}

	// Check that all clauses appear in help
	for _, clause := range g.Clauses {
		if !strings.Contains(helpText, clause.Name) {
			t.Errorf("Clause %s not found in help output", clause.Name)
		}
		if !strings.Contains(helpText, clause.Description) {
			t.Errorf("Clause %s description not found in help output", clause.Name)
		}
	}
}


----
tests/parser_test.go
package tests

import (
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/types"
)

func TestParseBasicRead(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    *types.Command
		wantErr bool
	}{
		{
			name:  "simple read",
			input: "read https://api.example.com/users",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
			},
			wantErr: false,
		},
		{
			name:  "read with as clause",
			input: "read https://api.example.com/users as=json",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.AsClause{Format: "json"},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with multiple clauses",
			input: "read https://api.example.com/users as=json verbose",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.AsClause{Format: "json"},
					types.VerboseClause{},
				},
			},
			wantErr: false,
		},
		{
			name:  "send with json body",
			input: "send https://api.example.com/users with='{\"name\":\"Ada\"}'",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.WithClause{Type: "json", Value: "'{\"name\":\"Ada\"}'"},
				},
			},
			wantErr: false,
		},
		{
			name:  "save with destination",
			input: "save https://example.com/file.zip to=file.zip",
			want: &types.Command{
				Verb:   types.VerbSave,
				Target: types.Target{URL: "https://example.com/file.zip"},
				Clauses: []types.Clause{
					types.ToClause{Destination: "file.zip"},
				},
			},
			wantErr: false,
		},
		{
			name:    "invalid verb",
			input:   "invalid https://example.com",
			wantErr: true,
		},
		{
			name:    "missing target",
			input:   "read",
			wantErr: true,
		},
		{
			name:  "read with insecure clause",
			input: "read https://api.example.com/users insecure=true",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.InsecureClause{Value: true},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with timeout",
			input: "read https://api.example.com/users under=5s",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UnderClause{Duration: 5000000000, IsSize: false}, // 5s in nanoseconds
				},
			},
			wantErr: false,
		},
		{
			name:  "send with using=PUT",
			input: "send https://api.example.com/users using=PUT",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "PUT"},
				},
			},
			wantErr: false,
		},
		{
			name:  "send with using=patch (normalize to uppercase)",
			input: "send https://api.example.com/users using=patch",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "PATCH"},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with using=HEAD",
			input: "read https://api.example.com/users using=HEAD",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "HEAD"},
				},
			},
			wantErr: false,
		},
		{
			name:    "using= with invalid method",
			input:   "read https://api.example.com/users using=INVALID",
			wantErr: true,
		},
		{
			name:    "old method= syntax should error",
			input:   "read https://api.example.com/users method=PUT",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parser.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if got.Verb != tt.want.Verb {
				t.Errorf("Parse() Verb = %v, want %v", got.Verb, tt.want.Verb)
			}
			if got.Target.URL != tt.want.Target.URL {
				t.Errorf("Parse() Target.URL = %v, want %v", got.Target.URL, tt.want.Target.URL)
			}
			if len(got.Clauses) != len(tt.want.Clauses) {
				t.Errorf("Parse() Clauses length = %v, want %v", len(got.Clauses), len(tt.want.Clauses))
				return
			}
			// Check UsingClause if present
			for i, clause := range got.Clauses {
				if usingClause, ok := clause.(types.UsingClause); ok {
					if i >= len(tt.want.Clauses) {
						t.Errorf("Parse() UsingClause found but not expected")
						continue
					}
					if wantUsingClause, ok := tt.want.Clauses[i].(types.UsingClause); ok {
						if usingClause.Method != wantUsingClause.Method {
							t.Errorf("Parse() UsingClause.Method = %v, want %v", usingClause.Method, wantUsingClause.Method)
						}
					}
				}
			}
		})
	}
}

func TestParseErrorSuggestions(t *testing.T) {
	tests := []struct {
		name       string
		input      string
		wantSuggestion string
	}{
		{
			name: "typo in verb",
			input: "reed https://api.example.com/users",
			wantSuggestion: "read",
		},
		{
			name: "typo in clause",
			input: "read https://api.example.com/users ass=json",
			wantSuggestion: "as",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := parser.Parse(tt.input)
			if err == nil {
				t.Errorf("Parse() expected error but got none")
				return
			}
			parseErr, ok := err.(*parser.ParseError)
			if !ok {
				t.Errorf("Parse() error is not a ParseError: %T", err)
				return
			}
			if parseErr.Suggest != tt.wantSuggestion {
				t.Errorf("Parse() Suggest = %v, want %v", parseErr.Suggest, tt.wantSuggestion)
			}
		})
	}
}


----
tests/planner_test.go
package tests

import (
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
)

func TestPlanRead(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.AsClause{Format: "json"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Method != http.MethodGet {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodGet)
	}
	if plan.URL != "https://api.example.com/users" {
		t.Errorf("Plan() URL = %v, want %v", plan.URL, "https://api.example.com/users")
	}
	if plan.Output == nil {
		t.Errorf("Plan() Output is nil")
	} else if plan.Output.Format != "json" {
		t.Errorf("Plan() Output.Format = %v, want json", plan.Output.Format)
	}
}

func TestPlanSend(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.WithClause{Type: "json", Value: "{\"name\":\"Ada\"}"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Send with with= should default to POST
	if plan.Method != http.MethodPost {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodPost)
	}
	if plan.Body == nil {
		t.Errorf("Plan() Body is nil")
	} else if plan.Body.Type != "json" {
		t.Errorf("Plan() Body.Type = %v, want json", plan.Body.Type)
	}
}

func TestPlanSave(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSave,
		Target: types.Target{URL: "https://example.com/file.zip"},
		Clauses: []types.Clause{
			types.ToClause{Destination: "file.zip"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Method != http.MethodGet {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodGet)
	}
	if plan.Output == nil {
		t.Errorf("Plan() Output is nil")
	} else if plan.Output.Destination != "file.zip" {
		t.Errorf("Plan() Output.Destination = %v, want file.zip", plan.Output.Destination)
	}
}

func TestPlanWithTimeout(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.TimeoutClause{Duration: 5 * time.Second},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Timeout == nil {
		t.Errorf("Plan() Timeout is nil")
	} else if *plan.Timeout != 5*time.Second {
		t.Errorf("Plan() Timeout = %v, want %v", *plan.Timeout, 5*time.Second)
	}
}

func TestPlanWithRetry(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.RetryClause{Count: 3},
			types.BackoffClause{
				Min: 200 * time.Millisecond,
				Max: 5 * time.Second,
			},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Retry == nil {
		t.Errorf("Plan() Retry is nil")
	} else {
		if plan.Retry.Count != 3 {
			t.Errorf("Plan() Retry.Count = %v, want 3", plan.Retry.Count)
		}
		if plan.Retry.Backoff.Min != 200*time.Millisecond {
			t.Errorf("Plan() Retry.Backoff.Min = %v, want %v", plan.Retry.Backoff.Min, 200*time.Millisecond)
		}
		if plan.Retry.Backoff.Max != 5*time.Second {
			t.Errorf("Plan() Retry.Backoff.Max = %v, want %v", plan.Retry.Backoff.Max, 5*time.Second)
		}
	}
}

func TestPlanWithUsingOverride(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "PUT"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Method override should take precedence
	if plan.Method != "PUT" {
		t.Errorf("Plan() Method = %v, want PUT", plan.Method)
	}
}

func TestPlanWithUsingIncompatible(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "POST"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err == nil {
		t.Fatalf("Plan() expected error for incompatible verb-method combination")
	}

	// Should have error message
	if plan != nil {
		t.Errorf("Plan() should return nil on error")
	}
	
	// Check error message
	if !strings.Contains(err.Error(), "incompatible") {
		t.Errorf("Plan() error message should mention incompatibility, got: %v", err)
	}
}

func TestPlanWithUsingDeleteForSend(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "DELETE"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err == nil {
		t.Fatalf("Plan() expected error for incompatible verb-method combination")
	}

	if plan != nil {
		t.Errorf("Plan() should return nil on error")
	}
}


----
tests/redirect_compression_test.go
package tests

import (
	"bytes"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestRedirectTrace tests that redirect traces appear in stderr.
func TestRedirectTrace(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Test redirect with read verb (should follow by default)
	cmdStr := "read " + ts.URL() + "/redirect/301"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	err = executor.Execute(plan)
	os.Stderr = oldStderr
	w.Close()

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read stderr
	var buf bytes.Buffer
	buf.ReadFrom(r)
	stderr := buf.String()

	// Check for redirect trace
	if !strings.Contains(stderr, "→") {
		t.Errorf("Expected redirect trace in stderr, got: %s", stderr)
	}
	if !strings.Contains(stderr, "301") {
		t.Errorf("Expected status code 301 in redirect trace, got: %s", stderr)
	}
}

// TestCompressionTrace tests that decompression notes appear in stderr.
func TestCompressionTrace(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/gzip"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	err = executor.Execute(plan)
	os.Stderr = oldStderr
	w.Close()

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read stderr
	var buf bytes.Buffer
	buf.ReadFrom(r)
	stderr := buf.String()

	// Check for decompression note
	if !strings.Contains(stderr, "Decompressed") {
		t.Errorf("Expected decompression note in stderr, got: %s", stderr)
	}
}

// TestRedirectTraceGolden tests redirect trace output against golden file.
func TestRedirectTraceGolden(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/redirect/307"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	stderr := stderrBuf.String()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "redirect_trace.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		// Create golden file if it doesn't exist
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, []byte(stderr), 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare (normalize line endings)
	actualNorm := strings.ReplaceAll(stderr, "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Redirect trace mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestCompressionTraceGolden tests compression trace output against golden file.
func TestCompressionTraceGolden(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/gzip"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	stderr := stderrBuf.String()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "compression_trace.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		// Create golden file if it doesn't exist
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, []byte(stderr), 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare (normalize line endings)
	actualNorm := strings.ReplaceAll(stderr, "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Compression trace mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestBinaryRedirectTrace tests redirect trace using the built binary.
func TestBinaryRedirectTrace(t *testing.T) {
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	ts := NewTestServer()
	defer ts.Close()

	// Run req with redirect
	cmd := exec.Command(binaryPath, "read", ts.URL()+"/redirect/302")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Run() // Don't care about exit code, just want stderr

	output := stderr.String()
	if !strings.Contains(output, "→") {
		t.Errorf("Expected redirect trace in binary output, got: %s", output)
	}
}

// TestBinaryCompressionTrace tests compression trace using the built binary.
func TestBinaryCompressionTrace(t *testing.T) {
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	ts := NewTestServer()
	defer ts.Close()

	// Run req with gzip endpoint
	cmd := exec.Command(binaryPath, "read", ts.URL()+"/gzip")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Run() // Don't care about exit code, just want stderr

	output := stderr.String()
	if !strings.Contains(output, "Decompressed") {
		t.Errorf("Expected decompression note in binary output, got: %s", output)
	}
}


----
tests/runtime_test.go
package tests

import (
	"encoding/json"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestRuntimeReadDogFacts tests reading from a real API.
// Note: This test requires internet connectivity.
func TestRuntimeReadDogFacts(t *testing.T) {
	// Use httpbin.org as a reliable test API
	// If dog-facts-api comes back online, we can switch back
	cmdStr := "read https://httpbin.org/json"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read captured output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	// Verify output is JSON
	var data map[string]interface{}
	if err := json.Unmarshal(output, &data); err != nil {
		t.Fatalf("Output is not valid JSON: %v\nOutput: %s", err, string(output))
	}

	// Verify we got some data
	if len(data) == 0 {
		t.Errorf("Expected non-empty JSON response, got empty map")
	}

	t.Logf("Successfully received JSON response: %v", data)
}

// TestRuntimeReadMultipleDogFacts tests reading from a real API with query params.
// Note: This test requires internet connectivity.
func TestRuntimeReadMultipleDogFacts(t *testing.T) {
	// Use httpbin.org with query params
	cmdStr := "read https://httpbin.org/get?foo=bar&baz=qux"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read captured output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	// Verify output is JSON
	var data map[string]interface{}
	if err := json.Unmarshal(output, &data); err != nil {
		t.Fatalf("Output is not valid JSON: %v\nOutput: %s", err, string(output))
	}

	// Verify we got data with query params
	if args, ok := data["args"].(map[string]interface{}); ok {
		if args["foo"] != "bar" || args["baz"] != "qux" {
			t.Errorf("Expected query params foo=bar&baz=qux, got: %v", args)
		}
	} else {
		t.Errorf("Expected 'args' field in response, got: %v", data)
	}

	t.Logf("Successfully received JSON response with query params")
}

// TestRuntimeSaveDogFact tests saving API response to a file.
// Note: This test requires internet connectivity.
func TestRuntimeSaveDogFact(t *testing.T) {
	// Create a temporary file
	tmpFile, err := os.CreateTemp("", "api-response-*.json")
	if err != nil {
		t.Fatalf("CreateTemp() error = %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	cmdStr := "read https://httpbin.org/json to=" + tmpFile.Name()
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and contains valid JSON
	fileContent, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("ReadFile() error = %v", err)
	}

	var data map[string]interface{}
	if err := json.Unmarshal(fileContent, &data); err != nil {
		t.Fatalf("File content is not valid JSON: %v\nContent: %s", err, string(fileContent))
	}

	if len(data) == 0 {
		t.Errorf("Expected non-empty JSON in file, got empty map")
	}

	t.Logf("Successfully saved API response to file: %s", tmpFile.Name())
}

// TestRuntimeSaveVideoFile tests downloading a video file using the save command.
// Note: This test requires internet connectivity.
func TestRuntimeSaveVideoFile(t *testing.T) {
	// Create a temporary file
	tmpFile, err := os.CreateTemp("", "video-*.mp4")
	if err != nil {
		t.Fatalf("CreateTemp() error = %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	// Use the provided test video URL
	cmdStr := "save http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4 to=" + tmpFile.Name()
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and has content
	fileInfo, err := os.Stat(tmpFile.Name())
	if err != nil {
		t.Fatalf("Stat() error = %v", err)
	}

	if fileInfo.Size() == 0 {
		t.Error("Expected non-empty file, got empty file")
	}

	// Video files should be reasonably large (at least a few KB)
	if fileInfo.Size() < 1024 {
		t.Errorf("Expected file size >= 1KB, got %d bytes", fileInfo.Size())
	}

	// Verify file content is binary (not text)
	fileContent, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("ReadFile() error = %v", err)
	}

	// Check for MP4 file signature (ftyp box at the beginning)
	// MP4 files typically start with some metadata, but we can check for non-text content
	if len(fileContent) == 0 {
		t.Error("Expected non-empty file content")
	}

	// MP4 files typically start with specific bytes or contain binary data
	// For a simple test, verify it's not plain text by checking for null bytes
	// or non-printable characters in the first few bytes
	hasBinaryContent := false
	for i := 0; i < len(fileContent) && i < 100; i++ {
		if fileContent[i] == 0 || (fileContent[i] < 32 && fileContent[i] != 9 && fileContent[i] != 10 && fileContent[i] != 13) {
			hasBinaryContent = true
			break
		}
	}

	if !hasBinaryContent && len(fileContent) > 100 {
		// If first 100 bytes are all printable, it's likely not a binary video file
		t.Logf("Warning: File content appears to be text, expected binary video file")
	}

	t.Logf("Successfully downloaded video file: %s (size: %d bytes)", tmpFile.Name(), fileInfo.Size())
}

// TestRuntimeReadWithTimeout tests request with timeout.
// Note: This test requires internet connectivity.
func TestRuntimeReadWithTimeout(t *testing.T) {
	cmdStr := "read https://httpbin.org/json under=10s"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify we got output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(output) == 0 {
		t.Error("Expected non-empty output")
	}

	t.Logf("Successfully received response with timeout")
}

// TestRuntimeHTTPError tests handling of HTTP errors.
// Note: This test requires internet connectivity.
func TestRuntimeHTTPError(t *testing.T) {
	// Use a non-existent endpoint to trigger 404
	cmdStr := "read https://httpbin.org/status/404"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	
	// Should return an error for non-2xx status
	if err == nil {
		t.Error("Expected error for non-existent endpoint, got nil")
	}

	// Verify error message contains status code
	if !strings.Contains(err.Error(), "404") {
		t.Errorf("Expected error to contain '404', got: %v", err)
	}

	t.Logf("Successfully handled HTTP error: %v", err)
}

// TestRuntimeInvalidURL tests handling of invalid URLs.
func TestRuntimeInvalidURL(t *testing.T) {
	cmdStr := "read https://this-domain-does-not-exist-12345.example.com/nonexistent"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	
	// Should return an error for invalid domain
	if err == nil {
		t.Error("Expected error for invalid domain, got nil")
	}

	t.Logf("Successfully handled invalid URL error: %v", err)
}


----
tests/session_test.go
package tests

import (
	"bytes"
	"net/http"
	"os"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
)

// TestAuthenticateStoresSession tests that authenticate verb stores Set-Cookie and access_token.
func TestAuthenticateStoresSession(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Create a login endpoint that returns Set-Cookie and access_token
	ts.mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) {
		http.SetCookie(w, &http.Cookie{
			Name:  "session",
			Value: "test-session-123",
			Path:  "/",
		})
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte(`{"access_token": "test-token-456", "user": "test"}`))
	})

	// Clean up any existing session
	host, _ := session.ExtractHost(ts.URL())
	session.DeleteSession(host)

	cmdStr := "authenticate " + ts.URL() + "/login using=POST with='{\"user\":\"test\"}'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify session was saved
	sess, err := session.LoadSession(host)
	if err != nil {
		t.Fatalf("LoadSession() error = %v", err)
	}
	if sess == nil {
		t.Fatal("Session was not saved")
	}

	// Verify cookie was captured
	if sess.Cookies["session"] != "test-session-123" {
		t.Errorf("Expected cookie 'session'='test-session-123', got %q", sess.Cookies["session"])
	}

	// Verify access_token was captured
	if sess.Authorization != "Bearer test-token-456" {
		t.Errorf("Expected Authorization 'Bearer test-token-456', got %q", sess.Authorization)
	}

	// Verify stderr shows session saved
	stderr := stderrBuf.String()
	if !strings.Contains(stderr, "Session saved") {
		t.Errorf("Expected 'Session saved' in stderr, got: %s", stderr)
	}

	// Clean up
	session.DeleteSession(host)
}

// TestAutoApplySession tests that sessions are auto-applied for matching hosts.
func TestAutoApplySession(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "auto-applied-session"},
		Authorization: "Bearer auto-applied-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes headers
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		auth := r.Header.Get("Authorization")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"auth": "` + auth + `", "cookie": "` + cookie + `"}`))
	})

	cmdStr := "read " + ts.URL() + "/test"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify Authorization header was applied
	output := stdoutBuf.String()
	if !strings.Contains(output, "Bearer auto-applied-token") {
		t.Errorf("Expected Authorization header in request, output: %s", output)
	}

	// Verify Cookie was applied
	if !strings.Contains(output, "auto-applied-session") {
		t.Errorf("Expected session cookie in request, output: %s", output)
	}

	// Verify stderr shows session was used
	stderr := stderrBuf.String()
	if !strings.Contains(stderr, "Using session for") {
		t.Errorf("Expected 'Using session for' in stderr, got: %s", stderr)
	}
}

// TestSessionSuppression tests that explicit include of Authorization or Cookie suppresses session injection.
func TestSessionSuppression(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes headers
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		auth := r.Header.Get("Authorization")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"auth": "` + auth + `", "cookie": "` + cookie + `"}`))
	})

	// Test with explicit Authorization header
	cmdStr := "read " + ts.URL() + "/test include='header: Authorization: Bearer explicit-token'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify explicit Authorization was used, not stored session
	output := stdoutBuf.String()
	if !strings.Contains(output, "Bearer explicit-token") {
		t.Errorf("Expected explicit Authorization header, output: %s", output)
	}
	if strings.Contains(output, "Bearer stored-token") {
		t.Errorf("Stored session token should not be used when explicit header is set, output: %s", output)
	}

	// Verify stderr does NOT show "Using session for"
	stderr := stderrBuf.String()
	if strings.Contains(stderr, "Using session for") {
		t.Errorf("Session should not be auto-applied when explicit Authorization is set, stderr: %s", stderr)
	}
}

// TestSessionSuppressionWithCookie tests that explicit Cookie suppresses session injection.
func TestSessionSuppressionWithCookie(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes cookies
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"cookie": "` + cookie + `"}`))
	})

	// Test with explicit Cookie
	cmdStr := "read " + ts.URL() + "/test include='cookie: session=explicit-cookie'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify explicit cookie was used
	output := stdoutBuf.String()
	if !strings.Contains(output, "explicit-cookie") {
		t.Errorf("Expected explicit cookie, output: %s", output)
	}
	if strings.Contains(output, "stored-session") {
		t.Errorf("Stored session cookie should not be used when explicit cookie is set, output: %s", output)
	}

	// Verify stderr does NOT show "Using session for"
	stderr := stderrBuf.String()
	if strings.Contains(stderr, "Using session for") {
		t.Errorf("Session should not be auto-applied when explicit Cookie is set, stderr: %s", stderr)
	}
}

// TestSessionNotUsedMessage tests that stderr prints a message when session exists but wasn't used.
// Note: This test may need adjustment based on actual implementation behavior.
func TestSessionNotUsedMessage(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Request with explicit Authorization (suppresses session)
	cmdStr := "read " + ts.URL() + "/json include='header: Authorization: Bearer explicit'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// The current implementation doesn't print a message when session exists but wasn't used
	// This test documents the expected behavior - if we want to add this feature, we'd need
	// to modify the executor to check if a session exists but wasn't applied
	stderr := stderrBuf.String()
	// For now, just verify the request succeeded
	_ = stderr
}


----
tests/shell_quoting_test.go
package tests

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// TestShellQuotingBash tests bash quoting behavior.
func TestShellQuotingBash(t *testing.T) {
	if _, err := exec.LookPath("bash"); err != nil {
		t.Skip("bash not available")
		return
	}

	// Test command with include clause containing commas and semicolons
	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	// Create a test script that prints argv
	script := `#!/bin/bash
exec "$@" --argv-test
`
	tmpScript := filepath.Join(t.TempDir(), "test.sh")
	if err := os.WriteFile(tmpScript, []byte(script), 0755); err != nil {
		t.Fatalf("Failed to write test script: %v", err)
	}

	// Run through bash and capture output
	cmd := exec.Command("bash", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "shell_quoting_bash.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare
	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Bash quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingZsh tests zsh quoting behavior.
func TestShellQuotingZsh(t *testing.T) {
	if _, err := exec.LookPath("zsh"); err != nil {
		t.Skip("zsh not available")
		return
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	cmd := exec.Command("zsh", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_zsh.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Zsh quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingFish tests fish shell quoting behavior.
func TestShellQuotingFish(t *testing.T) {
	if _, err := exec.LookPath("fish"); err != nil {
		t.Skip("fish not available")
		return
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	cmd := exec.Command("fish", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_fish.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Fish quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingPowerShell tests PowerShell quoting behavior.
func TestShellQuotingPowerShell(t *testing.T) {
	if _, err := exec.LookPath("pwsh"); err != nil {
		if _, err := exec.LookPath("powershell"); err != nil {
			t.Skip("PowerShell not available")
			return
		}
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	var cmd *exec.Cmd
	if _, err := exec.LookPath("pwsh"); err == nil {
		cmd = exec.Command("pwsh", "-Command", testCmd+" --argv-test")
	} else {
		cmd = exec.Command("powershell", "-Command", testCmd+" --argv-test")
	}
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_powershell.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("PowerShell quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// Note: These tests require the binary to support --argv-test flag that prints argv.
// For now, they will skip if shells are not available, which is acceptable.
// The golden files can be created manually by running the commands and capturing output.


----
tests/testserver.go
// Package tests provides a local HTTP test server for integration tests.
package tests

import (
	"compress/gzip"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
)

// TestServer provides a test HTTP server with various endpoints.
type TestServer struct {
	server *httptest.Server
	mux    *http.ServeMux
}

// NewTestServer creates a new test server.
func NewTestServer() *TestServer {
	mux := http.NewServeMux()
	ts := &TestServer{
		mux: mux,
	}

	// Echo endpoint - returns request details
	mux.HandleFunc("/echo", ts.handleEcho)

	// Headers endpoint - returns request headers
	mux.HandleFunc("/headers", ts.handleHeaders)

	// Cookies endpoint - sets and returns cookies
	mux.HandleFunc("/cookies", ts.handleCookies)

	// Query endpoint - returns query parameters
	mux.HandleFunc("/query", ts.handleQuery)

	// Gzip endpoint - returns gzipped content
	mux.HandleFunc("/gzip", ts.handleGzip)

	// Redirect endpoints
	mux.HandleFunc("/redirect/301", ts.handleRedirect(301))
	mux.HandleFunc("/redirect/302", ts.handleRedirect(302))
	mux.HandleFunc("/redirect/303", ts.handleRedirect(303))
	mux.HandleFunc("/redirect/307", ts.handleRedirect(307))
	mux.HandleFunc("/redirect/308", ts.handleRedirect(308))
	mux.HandleFunc("/final", ts.handleFinal)

	// Multipart endpoint - echoes multipart form data
	mux.HandleFunc("/multipart", ts.handleMultipart)

	// JSON endpoint - returns JSON
	mux.HandleFunc("/json", ts.handleJSON)

	// Status endpoint - returns specific status code
	mux.HandleFunc("/status/", ts.handleStatus)

	ts.server = httptest.NewServer(mux)
	return ts
}

// URL returns the base URL of the test server.
func (ts *TestServer) URL() string {
	return ts.server.URL
}

// Close shuts down the test server.
func (ts *TestServer) Close() {
	ts.server.Close()
}

// handleEcho returns request details as JSON.
func (ts *TestServer) handleEcho(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{
  "method": "%s",
  "url": "%s",
  "headers": %s,
  "body": "%s"
}`, r.Method, r.URL.String(), ts.headersJSON(r), ts.bodyString(r))
}

// handleHeaders returns request headers as JSON.
func (ts *TestServer) handleHeaders(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"headers": %s}`, ts.headersJSON(r))
}

// handleCookies sets and returns cookies.
func (ts *TestServer) handleCookies(w http.ResponseWriter, r *http.Request) {
	// Set a test cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "session",
		Value: "test-session-value",
		Path:  "/",
	})

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"cookies": %s}`, ts.cookiesJSON(r))
}

// handleQuery returns query parameters as JSON.
func (ts *TestServer) handleQuery(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"query": %s}`, ts.queryJSON(r))
}

// handleGzip returns gzipped content.
func (ts *TestServer) handleGzip(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Encoding", "gzip")
	w.Header().Set("Content-Type", "text/plain")

	gz := gzip.NewWriter(w)
	defer gz.Close()
	fmt.Fprint(gz, "This is gzipped content")
}

// handleFinal is the final destination for redirects.
func (ts *TestServer) handleFinal(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	fmt.Fprint(w, "Final destination")
}

// handleRedirect returns a redirect response.
func (ts *TestServer) handleRedirect(code int) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Location", ts.server.URL+"/final")
		w.WriteHeader(code)
	}
}

// handleMultipart echoes multipart form data.
func (ts *TestServer) handleMultipart(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	err := r.ParseMultipartForm(10 << 20) // 10 MB
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Error parsing multipart: %v", err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{
  "form": %s,
  "files": %s
}`, ts.formJSON(r), ts.filesJSON(r))
}

// handleJSON returns JSON data.
func (ts *TestServer) handleJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprint(w, `{"message": "Hello, World!", "items": [1, 2, 3]}`)
}

// handleStatus returns a specific HTTP status code.
func (ts *TestServer) handleStatus(w http.ResponseWriter, r *http.Request) {
	// Extract status code from path
	path := strings.TrimPrefix(r.URL.Path, "/status/")
	var code int
	fmt.Sscanf(path, "%d", &code)
	if code == 0 {
		code = 200
	}
	w.WriteHeader(code)
	fmt.Fprintf(w, "Status %d", code)
}

// Helper functions

func (ts *TestServer) headersJSON(r *http.Request) string {
	headers := make(map[string]string)
	for k, v := range r.Header {
		headers[k] = strings.Join(v, ", ")
	}
	return fmt.Sprintf(`{"%s": "%s"}`, "User-Agent", headers["User-Agent"])
}

func (ts *TestServer) cookiesJSON(r *http.Request) string {
	cookies := make([]string, 0)
	for _, cookie := range r.Cookies() {
		cookies = append(cookies, fmt.Sprintf(`"%s=%s"`, cookie.Name, cookie.Value))
	}
	return "[" + strings.Join(cookies, ", ") + "]"
}

func (ts *TestServer) queryJSON(r *http.Request) string {
	params := make([]string, 0)
	for k, v := range r.URL.Query() {
		for _, val := range v {
			params = append(params, fmt.Sprintf(`"%s": "%s"`, k, val))
		}
	}
	return "{" + strings.Join(params, ", ") + "}"
}

func (ts *TestServer) bodyString(r *http.Request) string {
	body, _ := io.ReadAll(r.Body)
	return strings.ReplaceAll(string(body), "\"", "\\\"")
}

func (ts *TestServer) formJSON(r *http.Request) string {
	form := make([]string, 0)
	for k, v := range r.MultipartForm.Value {
		for _, val := range v {
			form = append(form, fmt.Sprintf(`"%s": "%s"`, k, val))
		}
	}
	return "{" + strings.Join(form, ", ") + "}"
}

func (ts *TestServer) filesJSON(r *http.Request) string {
	files := make([]string, 0)
	for k, v := range r.MultipartForm.File {
		for _, fh := range v {
			files = append(files, fmt.Sprintf(`"%s": "%s"`, k, fh.Filename))
		}
	}
	return "{" + strings.Join(files, ", ") + "}"
}

----
tests/watch_save_test.go
package tests

import (
	"net/http"
	"os"
	"path/filepath"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestSaveStreaming tests that save verb uses efficient file writing.
// Note: Current implementation uses io.Copy which is efficient, but reads body into memory first.
// Future optimization: stream directly from resp.Body when no expect checks are present.
func TestSaveStreaming(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Create a large response endpoint
	ts.mux.HandleFunc("/large", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain")
		// Write 1MB of data
		data := make([]byte, 1024*1024)
		for i := range data {
			data[i] = byte(i % 256)
		}
		w.Write(data)
	})

	tmpFile := filepath.Join(t.TempDir(), "output.bin")
	cmdStr := "save " + ts.URL() + "/large to=" + tmpFile
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and has correct size
	info, err := os.Stat(tmpFile)
	if err != nil {
		t.Fatalf("Failed to stat output file: %v", err)
	}

	expectedSize := int64(1024 * 1024)
	if info.Size() != expectedSize {
		t.Errorf("Expected file size %d, got %d", expectedSize, info.Size())
	}
}

// TestWatchTTYDetection tests TTY detection for watch verb.
// Note: Watch verb TTY detection is not yet implemented.
func TestWatchTTYDetection(t *testing.T) {
	t.Skip("Watch verb TTY detection not yet implemented")
}


--END--
----
go.mod
module github.com/adammpkins/req

go 1.24.0

toolchain go1.24.10

require (
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
)

require (
	github.com/andybalholm/brotli v1.2.0 // indirect
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

----
go.sum
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/andybalholm/brotli v1.2.0 h1:ukwgCxwYrmACq68yiUqwIWnGY0cTPox/M94sVwToPjQ=
github.com/andybalholm/brotli v1.2.0/go.mod h1:rzTDkvFWvIrjDXZHkuS16NPggd91W3kUSvPlQ1pLaKY=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=

----
internal/grammar/grammar.go
// Package grammar defines the structured grammar data for req commands.
package grammar

import "fmt"

// Verb represents a req command verb.
type Verb struct {
	Name        string
	Description string
}

// Clause represents a req command clause.
type Clause struct {
	Name        string
	Description string
	Repeatable  bool
	Example     string
}

// Grammar contains the complete grammar definition.
type Grammar struct {
	Verbs   []Verb
	Clauses []Clause
}

// GetGrammar returns the canonical grammar definition.
func GetGrammar() Grammar {
	return Grammar{
		Verbs: []Verb{
			{Name: "read", Description: "GET, print to stdout"},
			{Name: "save", Description: "GET, write to file via to="},
			{Name: "send", Description: "default GET, POST if with= present"},
			{Name: "upload", Description: "POST when attach= or with= present, else error"},
			{Name: "watch", Description: "GET with SSE or polling"},
			{Name: "inspect", Description: "HEAD only"},
			{Name: "authenticate", Description: "login and store session state"},
			{Name: "session", Description: "session management (show, clear, use)"},
		},
		Clauses: []Clause{
			{Name: "using=", Description: "HTTP method override", Repeatable: false, Example: "using=PUT"},
			{Name: "include=", Description: "Add headers, params, cookies, basic auth", Repeatable: true, Example: "include='header: Authorization: Bearer token; param: q=search query; basic: user:pass'"},
			{Name: "with=", Description: "Request body", Repeatable: false, Example: "with=@user.json or with='{\"name\":\"Adam\"}'"},
			{Name: "expect=", Description: "Assertions on response", Repeatable: false, Example: "expect=status:200, header:Content-Type=application/json, contains:\"ok\""},
			{Name: "as=", Description: "Output format for stdout", Repeatable: false, Example: "as=json"},
			{Name: "to=", Description: "Destination path", Repeatable: false, Example: "to=out.json"},
			{Name: "retry=", Description: "Retry attempts for transient errors", Repeatable: false, Example: "retry=3"},
			{Name: "under=", Description: "Timeout or size limit", Repeatable: false, Example: "under=30s or under=10MB"},
			{Name: "via=", Description: "Proxy URL", Repeatable: false, Example: "via=http://proxy:8080"},
			{Name: "attach=", Description: "Multipart parts for upload or send", Repeatable: true, Example: "attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'"},
			{Name: "follow=", Description: "Redirect policy for write verbs", Repeatable: false, Example: "follow=smart"},
			{Name: "insecure=", Description: "Disable TLS verification for this request", Repeatable: false, Example: "insecure=true"},
		},
	}
}

// FormatHelp formats the grammar as help text.
func FormatHelp() string {
	g := GetGrammar()
	
	var help string
	help += "req - HTTP client DSL\n\n"
	help += "Usage: req <verb> <url> [clauses...]\n\n"
	help += "Verbs:\n"
	
	for _, verb := range g.Verbs {
		help += fmt.Sprintf("  %-13s - %s\n", verb.Name, verb.Description)
	}
	
	help += "\nClauses:\n"
	for _, clause := range g.Clauses {
		help += fmt.Sprintf("  %-13s - %s", clause.Name, clause.Description)
		if clause.Repeatable {
			help += " (repeatable)"
		}
		help += "\n"
		if clause.Example != "" {
			help += fmt.Sprintf("                 Example: %s\n", clause.Example)
		}
	}
	
	help += "\nExamples:\n"
	help += "  req read https://api.example.com/search include='param: q=search query' as=json\n"
	help += "  \n"
	help += "  req read https://httpbin.org/basic-auth/user/passwd include='basic: user:passwd' expect=status:200\n"
	help += "  \n"
	help += "  req send https://api.example.com/users \\\n"
	help += "    using=POST \\\n"
	help += "    include='header: Authorization: Bearer $TOKEN' \\\n"
	help += "    with='{\"name\":\"Adam\"}' \\\n"
	help += "    expect=status:201, header:Content-Type=application/json \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req upload https://api.example.com/upload \\\n"
	help += "    attach='part: name=file, file=@./avatar.png, type=image/png' \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req authenticate https://api.example.com/login \\\n"
	help += "    using=POST \\\n"
	help += "    with='{\"user\":\"adam\",\"pass\":\"xyz\"}'\n"
	help += "  \n"
	help += "  req read https://api.example.com/me as=json\n\n"
	help += "For more information, see the grammar documentation.\n"
	
	return help
}


----
internal/grammar/snapshot.go
package grammar

import "encoding/json"

// Snapshot represents a snapshot of the grammar for drift detection.
type Snapshot struct {
	Verbs   []string `json:"verbs"`
	Clauses []ClauseSnapshot `json:"clauses"`
}

// ClauseSnapshot represents a clause in the snapshot.
type ClauseSnapshot struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Repeatable  bool   `json:"repeatable"`
}

// GetSnapshot returns a JSON-serializable snapshot of the grammar.
func GetSnapshot() Snapshot {
	g := GetGrammar()
	
	verbs := make([]string, len(g.Verbs))
	for i, v := range g.Verbs {
		verbs[i] = v.Name
	}
	
	clauses := make([]ClauseSnapshot, len(g.Clauses))
	for i, c := range g.Clauses {
		clauses[i] = ClauseSnapshot{
			Name:        c.Name,
			Description: c.Description,
			Repeatable:  c.Repeatable,
		}
	}
	
	return Snapshot{
		Verbs:   verbs,
		Clauses: clauses,
	}
}

// GetSnapshotJSON returns the snapshot as JSON bytes.
func GetSnapshotJSON() ([]byte, error) {
	snapshot := GetSnapshot()
	return json.MarshalIndent(snapshot, "", "  ")
}


----
internal/output/format.go
// Package output provides formatting and pretty-printing for execution plans.
package output

import (
	"encoding/json"
	"os"

	"github.com/adammpkins/req/internal/planner"
	"github.com/mattn/go-isatty"
)

// FormatPlan formats an ExecutionPlan as JSON for output.
func FormatPlan(plan *planner.ExecutionPlan) ([]byte, error) {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		// Pretty print when outputting to terminal
		return json.MarshalIndent(plan, "", "  ")
	}
	// Compact JSON when piped
	return json.Marshal(plan)
}


----
internal/parser/parser.go
// Package parser implements a lexer and parser for the req command grammar.
//
// Grammar (EBNF):
//
//	command = verb target [clauses]
//	verb = "read" | "save" | "send" | "upload" | "watch" | "inspect" | "authenticate" | "session"
//	target = url
//	clauses = clause { clause }
//	clause = with_clause | include_clause | attach_clause | expect_clause | as_clause | to_clause |
//	         using_clause | retry_clause | under_clause | via_clause | follow_clause | insecure_clause
//	with_clause = "with=" ( string | "@file" | "@-" )
//	include_clause = "include=" items
//	attach_clause = "attach=" parts
//	expect_clause = "expect=" checks
//	as_clause = "as=" ( "json" | "csv" | "text" | "raw" )
//	to_clause = "to=" path
//	using_clause = "using=" ( "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS" )
//	retry_clause = "retry=" number
//	under_clause = "under=" ( duration | size )
//	via_clause = "via=" url
//	follow_clause = "follow=smart"
//	insecure_clause = "insecure=" ( "true" | "false" )
package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// isValidHTTPMethod checks if a method is a valid HTTP method.
func isValidHTTPMethod(method string) bool {
	validMethods := []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	methodUpper := strings.ToUpper(method)
	for _, valid := range validMethods {
		if methodUpper == valid {
			return true
		}
	}
	return false
}

// ParseError represents a parse error with position information.
type ParseError struct {
	Position int
	Token    string
	Message  string
	Suggest  string
}

func (e *ParseError) Error() string {
	if e.Suggest != "" {
		return fmt.Sprintf("parse error at position %d (token: %q): %s (did you mean %q?)", e.Position, e.Token, e.Message, e.Suggest)
	}
	return fmt.Sprintf("parse error at position %d (token: %q): %s", e.Position, e.Token, e.Message)
}

// Parser parses req commands into AST.
type Parser struct {
	tokens []token
	pos    int
}

// token represents a lexical token.
type token struct {
	typ   tokenType
	value string
	pos   int
}

type tokenType int

const (
	tokenEOF tokenType = iota
	tokenWord
	tokenURL
	tokenEquals
	tokenColon
	tokenDotDot
	tokenString
	tokenNumber
	tokenDuration
	tokenFlag
)

// Parse parses a command string into a Command AST.
func Parse(input string) (*types.Command, error) {
	p := &Parser{}
	p.tokenize(input)
	return p.parseCommand()
}

// tokenize tokenizes the input string.
func (p *Parser) tokenize(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		p.tokens = []token{{typ: tokenEOF, pos: 0}}
		return
	}

	// Split on whitespace while respecting quoted strings
	parts := tokenizeRespectingQuotes(input)
	tokens := make([]token, 0, len(parts))

	for i, part := range parts {
		pos := i
		// Check if this is a URL first (URLs with query params contain = but are not clauses)
		if looksLikeURL(part) {
			tokens = append(tokens, token{typ: tokenURL, value: part, pos: pos})
		} else if strings.Contains(part, "=") {
			// Handle clauses with equals
			// Split on = but keep the = as a token
			eqIdx := strings.Index(part, "=")
			key := part[:eqIdx]
			value := part[eqIdx+1:]

			tokens = append(tokens, token{typ: tokenWord, value: key, pos: pos})
			tokens = append(tokens, token{typ: tokenEquals, value: "=", pos: pos})
			// Handle typed values like json:... (but not if value is quoted or looks like JSON)
			valueTrimmed := strings.TrimSpace(value)
			isQuoted := (len(valueTrimmed) >= 2 && ((valueTrimmed[0] == '\'' && valueTrimmed[len(valueTrimmed)-1] == '\'') || (valueTrimmed[0] == '"' && valueTrimmed[len(valueTrimmed)-1] == '"')))
			looksLikeJSON := strings.HasPrefix(valueTrimmed, "{") || strings.HasPrefix(valueTrimmed, "[")
			// Only parse as typed value if it matches pattern "word:" at the start (like json:...)
			// and not quoted or JSON-like
			if !isQuoted && !looksLikeJSON && strings.Contains(value, ":") {
				colonIdx := strings.Index(value, ":")
				typeName := strings.TrimSpace(value[:colonIdx])
				// Only treat as typed if typeName is a simple word (no special chars)
				if isSimpleWord(typeName) {
					typeValue := value[colonIdx+1:]
					tokens = append(tokens, token{typ: tokenWord, value: typeName, pos: pos})
					tokens = append(tokens, token{typ: tokenColon, value: ":", pos: pos})
					tokens = append(tokens, token{typ: tokenString, value: typeValue, pos: pos})
				} else {
					tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
				}
			} else if looksLikeURL(value) {
				tokens = append(tokens, token{typ: tokenURL, value: value, pos: pos})
			} else if looksLikeDuration(value) {
				tokens = append(tokens, token{typ: tokenDuration, value: value, pos: pos})
			} else {
				tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
			}
		} else if isFlag(part) {
			tokens = append(tokens, token{typ: tokenFlag, value: part, pos: pos})
		} else {
			tokens = append(tokens, token{typ: tokenWord, value: part, pos: pos})
		}
	}

	tokens = append(tokens, token{typ: tokenEOF, pos: len(parts)})
	p.tokens = tokens
}

// tokenizeRespectingQuotes splits a string on whitespace while respecting quoted strings.
// Quoted strings (single or double quotes) are preserved as single tokens.
// Also preserves clause values (everything after =) as single tokens even if unquoted.
func tokenizeRespectingQuotes(s string) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	quoteChar := rune(0)
	escape := false
	afterEquals := false // Track if we're in a clause value (after =)

	for i, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}

		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}

		if (r == '\'' || r == '"') && !inQuotes {
			// Start of quoted string
			inQuotes = true
			quoteChar = r
			current.WriteRune(r)
			continue
		}

		if inQuotes && r == quoteChar {
			// End of quoted string
			inQuotes = false
			quoteChar = 0
			current.WriteRune(r)
			continue
		}

		if r == '=' && !inQuotes {
			// Found equals - mark that we're now in a clause value
			afterEquals = true
			current.WriteRune(r)
			continue
		}

		if !inQuotes && (r == ' ' || r == '\t' || r == '\n') {
			// Whitespace outside quotes
			if afterEquals {
				// We're in a clause value - check if next token starts a new clause
				// Look ahead to see if there's a word followed by =
				remaining := s[i+1:]
				remaining = strings.TrimLeft(remaining, " \t\n")
				// Check if remaining starts with a word followed by = (new clause)
				// or if it's empty/EOF
				if remaining == "" || looksLikeNewClause(remaining) {
					// This whitespace separates clauses - split here
					if current.Len() > 0 {
						parts = append(parts, current.String())
						current.Reset()
					}
					afterEquals = false
					continue
				}
				// Otherwise, preserve whitespace as part of the clause value
				current.WriteRune(r)
				continue
			}
			// Not in a clause value - split here
			if current.Len() > 0 {
				parts = append(parts, current.String())
				current.Reset()
			}
			afterEquals = false
			continue
		}

		// If we hit a non-whitespace character after being in a clause value,
		// and it's not part of a quoted string, check if it starts a new clause
		if afterEquals && !inQuotes && r != ' ' && r != '\t' && r != '\n' {
			// Check if we're starting a new clause (word followed by =)
			// This is tricky - we need to look at what we've accumulated
			// For now, just continue accumulating
		}

		current.WriteRune(r)
	}

	// Add remaining content
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}

	return parts
}

// looksLikeNewClause checks if a string looks like it starts a new clause (word=)
func looksLikeNewClause(s string) bool {
	// Find first space or equals
	for i, r := range s {
		if r == '=' {
			// Found = - check if there's a word before it
			if i > 0 {
				word := strings.TrimSpace(s[:i])
				// Check if it's a valid clause key
				validKeys := []string{"include", "expect", "with", "as", "to", "using", "retry", "under", "via", "follow", "insecure", "attach"}
				for _, key := range validKeys {
					if word == key {
						return true
					}
				}
			}
			return false
		}
		if r == ' ' || r == '\t' {
			// Found space before = - not a new clause
			return false
		}
	}
	return false
}

// isSimpleWord checks if a string is a simple word (letters, numbers, underscore, no special chars)
func isSimpleWord(s string) bool {
	if len(s) == 0 {
		return false
	}
	for _, r := range s {
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
			return false
		}
	}
	return true
}

// looksLikeURL checks if a string looks like a URL.
func looksLikeURL(s string) bool {
	return strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://")
}

// looksLikeDuration checks if a string looks like a duration.
func looksLikeDuration(s string) bool {
	_, err := parseDuration(s)
	return err == nil
}

// isFlag checks if a string is a flag.
func isFlag(s string) bool {
	return s == "verbose" || s == "resume"
}

// parseCommand parses a command.
func (p *Parser) parseCommand() (*types.Command, error) {
	cmd := &types.Command{}

	// Parse verb
	verb, err := p.parseVerb()
	if err != nil {
		return nil, err
	}
	cmd.Verb = verb

	// Handle session subcommands (show, clear, use)
	if verb == types.VerbSession {
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected session subcommand (show, clear, use)"}
		}
		tok := p.tokens[p.pos]
		if tok.typ == tokenWord {
			subcmd := tok.value
			if subcmd == "show" || subcmd == "clear" || subcmd == "use" {
				cmd.SessionSubcommand = subcmd
				p.pos++
			} else {
				return nil, &ParseError{Position: tok.pos, Token: subcmd, Message: "unknown session subcommand (expected show, clear, or use)"}
			}
		}
	}

	// Parse target
	target, err := p.parseTarget()
	if err != nil {
		return nil, err
	}
	cmd.Target = target

	// Parse clauses
	clauses, err := p.parseClauses()
	if err != nil {
		return nil, err
	}
	cmd.Clauses = clauses

	return cmd, nil
}

// parseVerb parses a verb.
func (p *Parser) parseVerb() (types.Verb, error) {
	if p.pos >= len(p.tokens) {
		return "", &ParseError{Position: p.pos, Token: "", Message: "expected verb"}
	}

	tok := p.tokens[p.pos]
	if tok.typ != tokenWord {
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "expected verb"}
	}

	verb := types.Verb(tok.value)
	switch verb {
	case types.VerbRead, types.VerbSave, types.VerbSend, types.VerbUpload,
		types.VerbWatch, types.VerbInspect, types.VerbAuthenticate, types.VerbSession:
		p.pos++
		return verb, nil
	default:
		suggest := suggestVerb(tok.value)
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "unknown verb", Suggest: suggest}
	}
}

// suggestVerb suggests a similar verb.
func suggestVerb(input string) string {
	verbs := []string{"read", "save", "send", "upload", "watch", "inspect", "authenticate", "session"}
	best := ""
	minDist := 999
	for _, v := range verbs {
		dist := levenshteinDistance(input, v)
		if dist < minDist {
			minDist = dist
			best = v
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// levenshteinDistance calculates the Levenshtein distance between two strings.
func levenshteinDistance(a, b string) int {
	if len(a) == 0 {
		return len(b)
	}
	if len(b) == 0 {
		return len(a)
	}

	matrix := make([][]int, len(a)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(b)+1)
	}

	for i := 0; i <= len(a); i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len(b); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {
			cost := 0
			if a[i-1] != b[j-1] {
				cost = 1
			}
			matrix[i][j] = min(
				matrix[i-1][j]+1,
				matrix[i][j-1]+1,
				matrix[i-1][j-1]+cost,
			)
		}
	}

	return matrix[len(a)][len(b)]
}

func min(a, b, c int) int {
	if a < b && a < c {
		return a
	}
	if b < c {
		return b
	}
	return c
}

// parseTarget parses a target URL.
func (p *Parser) parseTarget() (types.Target, error) {
	if p.pos >= len(p.tokens) {
		return types.Target{}, &ParseError{Position: p.pos, Token: "", Message: "expected target URL or host"}
	}

	tok := p.tokens[p.pos]
	// For session commands, target might be a host instead of full URL
	if tok.typ == tokenURL {
		p.pos++
		return types.Target{URL: tok.value}, nil
	} else if tok.typ == tokenWord {
		// Might be a host name for session commands
		// Try to parse as URL, if it fails, treat as host
		if strings.Contains(tok.value, ".") || strings.Contains(tok.value, ":") {
			// Looks like a host, construct URL
			urlStr := "https://" + tok.value
			p.pos++
			return types.Target{URL: urlStr}, nil
		}
	}

	return types.Target{}, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected URL or host"}
}

// parseClauses parses zero or more clauses.
func (p *Parser) parseClauses() ([]types.Clause, error) {
	var clauses []types.Clause
	singletonSeen := make(map[string]bool)

	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}

		clause, err := p.parseClause()
		if err != nil {
			return nil, err
		}

		// Check for duplicate singletons
		if singletonKey := getSingletonKey(clause); singletonKey != "" {
			if singletonSeen[singletonKey] {
				return nil, &ParseError{
					Position: tok.pos,
					Token:    tok.value,
					Message:  fmt.Sprintf("duplicate singleton clause '%s'", singletonKey),
					Suggest:  fmt.Sprintf("remove duplicate '%s=' clause", singletonKey),
				}
			}
			singletonSeen[singletonKey] = true
		}

		clauses = append(clauses, clause)
	}

	return clauses, nil
}

// getSingletonKey returns the key name for singleton clauses, or empty string for repeatable clauses.
func getSingletonKey(clause types.Clause) string {
	switch clause.(type) {
	case types.UsingClause:
		return "using"
	case types.WithClause:
		return "with"
	case types.ExpectClause:
		return "expect"
	case types.AsClause:
		return "as"
	case types.ToClause:
		return "to"
	case types.RetryClause:
		return "retry"
	case types.UnderClause:
		return "under"
	case types.ViaClause:
		return "via"
	case types.InsecureClause:
		return "insecure"
	case types.FollowClause:
		return "follow"
	case types.TimeoutClause:
		return "timeout"
	case types.BackoffClause:
		return "backoff"
	case types.PickClause:
		return "pick"
	case types.EveryClause:
		return "every"
	case types.UntilClause:
		return "until"
	case types.ProxyClause:
		return "proxy"
	case types.FieldClause:
		return "field"
	case types.VerboseClause:
		return "verbose"
	case types.ResumeClause:
		return "resume"
	// Repeatable clauses return empty string
	case types.IncludeClause, types.AttachClause:
		return ""
	default:
		return ""
	}
}

// parseClause parses a single clause.
func (p *Parser) parseClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected clause"}
	}

	tok := p.tokens[p.pos]

	// Handle flags (insecure is now a clause with =, but keep verbose and resume as flags)
	if tok.typ == tokenFlag {
		p.pos++
		switch tok.value {
		case "verbose":
			return types.VerboseClause{}, nil
		case "resume":
			return types.ResumeClause{}, nil
		}
	}

	// Handle clauses with equals
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
		key := tok.value
		p.pos += 2 // skip key and =

		switch key {
		case "with":
			return p.parseWithClause()
		case "include":
			return p.parseIncludeClause()
		case "attach":
			return p.parseAttachClause()
		case "expect":
			return p.parseExpectClause()
		case "headers":
			return p.parseHeadersClause()
		case "params":
			return p.parseParamsClause()
		case "as":
			return p.parseAsClause()
		case "to":
			return p.parseToClause()
		case "using":
			return p.parseUsingClause()
		case "retry":
			return p.parseRetryClause()
		case "backoff":
			return p.parseBackoffClause()
		case "timeout":
			return p.parseTimeoutClause()
		case "under":
			return p.parseUnderClause()
		case "proxy":
			return p.parseProxyClause()
		case "via":
			return p.parseViaClause()
		case "follow":
			return p.parseFollowClause()
		case "insecure":
			return p.parseInsecureClause()
		case "pick":
			return p.parsePickClause()
		case "every":
			return p.parseEveryClause()
		case "until":
			return p.parseUntilClause()
		case "field":
			return p.parseFieldClause()
		default:
			suggest := suggestClause(key)
			return nil, &ParseError{Position: tok.pos, Token: key, Message: "unknown clause", Suggest: suggest}
		}
	}

	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected clause"}
}

// suggestClause suggests a similar clause name.
func suggestClause(input string) string {
	clauses := []string{"with", "include", "attach", "expect", "headers", "params", "as", "to", "using", "retry", "backoff", "timeout", "under", "proxy", "via", "follow", "insecure", "pick", "every", "until", "field"}
	best := ""
	minDist := 999
	for _, c := range clauses {
		dist := levenshteinDistance(input, c)
		if dist < minDist {
			minDist = dist
			best = c
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// parseWithClause parses a "with=" clause.
func (p *Parser) parseWithClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	tok := p.tokens[p.pos]
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenColon {
		// typed value like json:...
		typeName := tok.value
		p.pos += 2 // skip type and :
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
		}
		valueTok := p.tokens[p.pos]
		p.pos++
		value := valueTok.value
		isFile := strings.HasPrefix(value, "@") && value != "@-"
		isStdin := value == "@-"
		if isFile {
			value = value[1:] // Remove @ prefix
		}
		return types.WithClause{Type: typeName, Value: value, IsFile: isFile, IsStdin: isStdin}, nil
	}

	// plain value - collect all tokens until next clause
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	// Join tokens with spaces
	value := strings.Join(valueParts, " ")
	
	// Unquote if needed
	value = unquoteString(value)
	
	isFile := strings.HasPrefix(value, "@") && value != "@-"
	isStdin := value == "@-"
	if isFile {
		value = value[1:] // Remove @ prefix
	}
	
	// Infer JSON type if value starts with { or [
	typeInferred := ""
	if !isFile && !isStdin {
		trimmed := strings.TrimSpace(value)
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			typeInferred = "json"
		}
	}
	
	return types.WithClause{Value: value, Type: typeInferred, IsFile: isFile, IsStdin: isStdin}, nil
}

// parseHeadersClause parses a "headers=" clause (simplified for v0.1.0).
func (p *Parser) parseHeadersClause() (types.Clause, error) {
	// Simplified: just parse a single key:value pair for now
	// Full object parsing will come later
	return types.HeadersClause{Headers: make(map[string]string)}, nil
}

// parseParamsClause parses a "params=" clause (simplified for v0.1.0).
func (p *Parser) parseParamsClause() (types.Clause, error) {
	// Simplified: just parse a single key=value pair for now
	return types.ParamsClause{Params: make(map[string]string)}, nil
}

// parseAsClause parses an "as=" clause.
func (p *Parser) parseAsClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected format"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.AsClause{Format: tok.value}, nil
}

// parseToClause parses a "to=" clause.
func (p *Parser) parseToClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected destination"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ToClause{Destination: tok.value}, nil
}

// parseUsingClause parses a "using=" clause.
func (p *Parser) parseUsingClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected HTTP method"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	method := strings.ToUpper(tok.value)
	
	if !isValidHTTPMethod(method) {
		return nil, &ParseError{
			Position: tok.pos,
			Token:    tok.value,
			Message:  fmt.Sprintf("invalid HTTP method: %s (valid methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS)", tok.value),
		}
	}
	
	return types.UsingClause{Method: method}, nil
}

// parseRetryClause parses a "retry=" clause.
func (p *Parser) parseRetryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected retry count"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	// Parse number (simplified)
	count := 3 // default
	if tok.typ == tokenNumber {
		// In a real implementation, parse the number
		// For now, just use default
	}
	return types.RetryClause{Count: count}, nil
}

// parseBackoffClause parses a "backoff=" clause.
func (p *Parser) parseBackoffClause() (types.Clause, error) {
	// Format: backoff=200ms..5s
	if p.pos+2 >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected backoff range"}
	}

	minTok := p.tokens[p.pos]
	p.pos++
	if p.tokens[p.pos].typ != tokenDotDot {
		return nil, &ParseError{Position: p.pos, Token: p.tokens[p.pos].value, Message: "expected .."}
	}
	p.pos++
	maxTok := p.tokens[p.pos]
	p.pos++

	minDur, err := parseDuration(minTok.value)
	if err != nil {
		return nil, &ParseError{Position: minTok.pos, Token: minTok.value, Message: "invalid duration"}
	}
	maxDur, err := parseDuration(maxTok.value)
	if err != nil {
		return nil, &ParseError{Position: maxTok.pos, Token: maxTok.value, Message: "invalid duration"}
	}

	return types.BackoffClause{Min: minDur, Max: maxDur}, nil
}

// parseDuration parses a duration string.
func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

// parseTimeoutClause parses a "timeout=" clause.
func (p *Parser) parseTimeoutClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected timeout duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.TimeoutClause{Duration: dur}, nil
}

// parseProxyClause parses a "proxy=" clause.
func (p *Parser) parseProxyClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected proxy URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ProxyClause{URL: tok.value}, nil
}

// parsePickClause parses a "pick=" clause.
func (p *Parser) parsePickClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected JSONPath expression"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.PickClause{Path: tok.value}, nil
}

// parseEveryClause parses an "every=" clause.
func (p *Parser) parseEveryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected interval duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.EveryClause{Interval: dur}, nil
}

// parseUntilClause parses an "until=" clause.
func (p *Parser) parseUntilClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected predicate"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.UntilClause{Predicate: tok.value}, nil
}

// parseFieldClause parses a "field=" clause.
func (p *Parser) parseFieldClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field name"}
	}

	nameTok := p.tokens[p.pos]
	p.pos++
	if p.pos >= len(p.tokens) || p.tokens[p.pos].typ != tokenEquals {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected ="}
	}
	p.pos++
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field value"}
	}
	valueTok := p.tokens[p.pos]
	p.pos++

	return types.FieldClause{Name: nameTok.value, Value: valueTok.value}, nil
}

// parseIncludeClause parses an "include=" clause.
// Format: include='header: Name: Value; param: key=value; cookie: key=value'
func (p *Parser) parseIncludeClause() (types.Clause, error) {
	// Collect tokens until we have a complete include value
	// The value may contain colons, semicolons, and spaces
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected include value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}

	// Unquote the value if it's a single quoted string
	value = unquoteString(value)

	items, err := parseIncludeItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.IncludeClause{Items: items}, nil
}

// parseIncludeItems parses semicolon-separated include items.
func parseIncludeItems(value string) ([]types.IncludeItem, error) {
	var items []types.IncludeItem
	
	// For header items, semicolons in the value should not split items
	// We need to parse more carefully by looking for type tags
	value = strings.TrimSpace(value)
	if value == "" {
		return items, nil
	}
	
	// Split by semicolons, but be smarter about it:
	// - Look for type tags (header:, param:, cookie:)
	// - For header items, everything after "Name: " is the value, including semicolons
	// - Only split on semicolons that are followed by a type tag
	
	var current strings.Builder
	var parts []string
	
	i := 0
	for i < len(value) {
		// Look ahead for a type tag pattern: "; header:", "; param:", "; cookie:"
		if i > 0 && value[i] == ';' {
			// Check if this semicolon is followed by a type tag
			remaining := strings.TrimSpace(value[i+1:])
			if strings.HasPrefix(remaining, "header:") ||
				strings.HasPrefix(remaining, "param:") ||
				strings.HasPrefix(remaining, "cookie:") {
				// This semicolon is a separator
				if current.Len() > 0 {
					parts = append(parts, strings.TrimSpace(current.String()))
					current.Reset()
				}
				i++ // Skip the semicolon
				continue
			}
		}
		current.WriteByte(value[i])
		i++
	}
	
	if current.Len() > 0 {
		parts = append(parts, strings.TrimSpace(current.String()))
	}
	
	// If we didn't find any type tag separators, treat the whole thing as one item
	if len(parts) == 0 {
		parts = []string{value}
	}
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		item, err := parseIncludeItem(part)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	
	return items, nil
}

// parseIncludeItem parses a single include item (header:, param:, cookie:).
func parseIncludeItem(part string) (types.IncludeItem, error) {
	// Find the first colon to determine the type
	colonIdx := strings.Index(part, ":")
	if colonIdx == -1 {
		return types.IncludeItem{}, fmt.Errorf("missing colon in include item: %s", part)
	}
	
	typeTag := strings.TrimSpace(part[:colonIdx])
	rest := strings.TrimSpace(part[colonIdx+1:])
	
	switch typeTag {
	case "header":
		// Format: header: Name: Value
		headerColonIdx := strings.Index(rest, ":")
		if headerColonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("header item missing Name colon Value: %s", part)
		}
		name := strings.TrimSpace(rest[:headerColonIdx])
		value := strings.TrimSpace(rest[headerColonIdx+1:])
		// Unquote if needed
		name = unquoteString(name)
		value = unquoteString(value)
		return types.IncludeItem{Type: "header", Name: name, Value: value}, nil
		
	case "param":
		// Format: param: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("param item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "param", Name: key, Value: value}, nil
		
	case "cookie":
		// Format: cookie: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("cookie item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "cookie", Name: key, Value: value}, nil
		
	case "basic":
		// Format: basic: username:password
		// The rest should be username:password
		rest = strings.TrimSpace(rest)
		rest = unquoteString(rest)
		// Validate that it contains at least one colon
		colonIdx := strings.Index(rest, ":")
		if colonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("basic item must be in format username:password: %s", part)
		}
		// Store the full username:password as the value
		// We'll split it in the planner when encoding
		return types.IncludeItem{Type: "basic", Value: rest}, nil
		
	default:
		return types.IncludeItem{}, fmt.Errorf("unknown include item tag: %s (expected header, param, cookie, or basic)", typeTag)
	}
}

// splitRespectingQuotes splits a string by a delimiter while respecting quoted strings.
func splitRespectingQuotes(s string, delim rune) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	escape := false
	
	for _, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}
		
		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}
		
		if r == '\'' || r == '"' {
			inQuotes = !inQuotes
			current.WriteRune(r)
			continue
		}
		
		if r == delim && !inQuotes {
			parts = append(parts, current.String())
			current.Reset()
			continue
		}
		
		current.WriteRune(r)
	}
	
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	
	return parts
}

// unquoteString removes surrounding quotes if present and handles escapes.
func unquoteString(s string) string {
	if len(s) >= 2 && ((s[0] == '\'' && s[len(s)-1] == '\'') || (s[0] == '"' && s[len(s)-1] == '"')) {
		s = s[1 : len(s)-1]
		// Handle escapes
		var result strings.Builder
		escape := false
		for _, r := range s {
			if escape {
				if r == '\\' || r == '\'' || r == '"' {
					result.WriteRune(r)
				} else {
					result.WriteRune('\\')
					result.WriteRune(r)
				}
				escape = false
			} else if r == '\\' {
				escape = true
			} else {
				result.WriteRune(r)
			}
		}
		if escape {
			result.WriteRune('\\')
		}
		return result.String()
	}
	return s
}

// parseAttachClause parses an "attach=" clause.
// Format: attach='part: name=..., file=@path; part: name=..., value=...'
func (p *Parser) parseAttachClause() (types.Clause, error) {
	// Collect tokens until we have a complete attach value
	// The value may contain spaces, commas, and semicolons
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected attach value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}
	
	// Unquote if needed
	value = unquoteString(value)
	
	parts, boundary, err := parseAttachItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.AttachClause{Parts: parts, Boundary: boundary}, nil
}

// parseAttachItems parses semicolon-separated attach items.
func parseAttachItems(value string) ([]types.AttachPart, string, error) {
	var parts []types.AttachPart
	var boundary string
	
	// Split by semicolons, respecting quotes
	items := splitRespectingQuotes(value, ';')
	
	for _, item := range items {
		item = strings.TrimSpace(item)
		if item == "" {
			continue
		}
		
		// Check if it's a boundary specification
		if strings.HasPrefix(item, "boundary:") {
			boundary = strings.TrimSpace(strings.TrimPrefix(item, "boundary:"))
			boundary = unquoteString(boundary)
			continue
		}
		
		// Parse part: specification
		if !strings.HasPrefix(item, "part:") {
			return nil, "", fmt.Errorf("expected 'part:' or 'boundary:', got: %s", item)
		}
		
		partSpec := strings.TrimSpace(strings.TrimPrefix(item, "part:"))
		part, err := parseAttachPart(partSpec)
		if err != nil {
			return nil, "", err
		}
		parts = append(parts, part)
	}
	
	return parts, boundary, nil
}

// parseAttachPart parses a single attach part specification.
// Format: name=..., file=@path or value=..., optional filename=..., optional type=...
func parseAttachPart(spec string) (types.AttachPart, error) {
	var part types.AttachPart
	
	// Parse comma-separated key=value pairs
	pairs := splitRespectingQuotes(spec, ',')
	
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		eqIdx := strings.Index(pair, "=")
		if eqIdx == -1 {
			return types.AttachPart{}, fmt.Errorf("missing equals in attach part: %s", pair)
		}
		
		key := strings.TrimSpace(pair[:eqIdx])
		value := strings.TrimSpace(pair[eqIdx+1:])
		value = unquoteString(value)
		
		switch key {
		case "name":
			part.Name = value
		case "file":
			if strings.HasPrefix(value, "@") {
				part.FilePath = value[1:] // Remove @
			} else {
				part.FilePath = value
			}
		case "value":
			part.Value = value
		case "filename":
			part.Filename = value
		case "type":
			part.Type = value
		default:
			return types.AttachPart{}, fmt.Errorf("unknown attach part key: %s", key)
		}
	}
	
	// Validate: name is required
	if part.Name == "" {
		return types.AttachPart{}, fmt.Errorf("attach part missing required 'name='")
	}
	
	// Validate: exactly one of file or value
	hasFile := part.FilePath != ""
	hasValue := part.Value != ""
	if hasFile && hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part cannot have both 'file=' and 'value='")
	}
	if !hasFile && !hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part must have either 'file=' or 'value='")
	}
	
	return part, nil
}

// parseExpectClause parses an "expect=" clause.
// Format: expect=status:200, header:Content-Type=application/json, contains:"text"
func (p *Parser) parseExpectClause() (types.Clause, error) {
	// Collect tokens until we have a complete expect value
	// The value may contain colons and commas, so we need to collect multiple tokens
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected expect value"}
	}

	// Join tokens, but handle colons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon and current isn't a colon
			if valueParts[i-1] != ":" && part != ":" {
				value += " "
			}
		}
		value += part
	}
	
	// Unquote the value if it's a single quoted string
	value = unquoteString(value)
	
	checks, err := parseExpectChecks(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.ExpectClause{Checks: checks}, nil
}

// parseExpectChecks parses comma-separated expect checks.
func parseExpectChecks(value string) ([]types.ExpectCheck, error) {
	var checks []types.ExpectCheck
	
	// Split by commas, respecting quotes
	parts := splitRespectingQuotes(value, ',')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		check, err := parseExpectCheck(part)
		if err != nil {
			return nil, err
		}
		checks = append(checks, check)
	}
	
	return checks, nil
}

// parseExpectCheck parses a single expect check.
func parseExpectCheck(part string) (types.ExpectCheck, error) {
	// Unquote if needed first
	unquoted := unquoteString(part)
	
	// Check types: status:, header:, contains:, jsonpath:, matches:
	if strings.HasPrefix(unquoted, "status:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "status:"))
		return types.ExpectCheck{Type: "status", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "header:") {
		rest := strings.TrimSpace(strings.TrimPrefix(unquoted, "header:"))
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.ExpectCheck{}, fmt.Errorf("header check missing equals: %s", part)
		}
		name := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		value = unquoteString(value)
		return types.ExpectCheck{Type: "header", Name: name, Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "contains:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "contains:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "contains", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "jsonpath:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "jsonpath:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "jsonpath", Path: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "matches:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "matches:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "matches", Regex: value}, nil
	}
	
	return types.ExpectCheck{}, fmt.Errorf("unknown expect check type: %s", part)
}

// parseFollowClause parses a "follow=" clause.
func (p *Parser) parseFollowClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected follow value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "smart" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "follow accepts only 'smart'"}
	}
	
	return types.FollowClause{Policy: "smart"}, nil
}

// parseUnderClause parses an "under=" clause (duration or size).
func (p *Parser) parseUnderClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected under value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.TrimSpace(tok.value)
	
	// Try parsing as duration first
	if dur, err := parseDuration(value); err == nil {
		return types.UnderClause{Duration: dur, IsSize: false}, nil
	}
	
	// Try parsing as size (e.g., "10MB", "1GB")
	if size, err := parseSize(value); err == nil {
		return types.UnderClause{Size: size, IsSize: true}, nil
	}
	
	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "under value must be a duration (e.g., 30s) or size (e.g., 10MB)"}
}

// parseSize parses a size string like "10MB", "1GB", etc.
func parseSize(s string) (int64, error) {
	s = strings.TrimSpace(s)
	s = strings.ToUpper(s)
	
	multipliers := map[string]int64{
		"B":  1,
		"KB": 1024,
		"MB": 1024 * 1024,
		"GB": 1024 * 1024 * 1024,
		"TB": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, mult := range multipliers {
		if strings.HasSuffix(s, suffix) {
			numStr := strings.TrimSuffix(s, suffix)
			var num float64
			if _, err := fmt.Sscanf(numStr, "%f", &num); err != nil {
				return 0, err
			}
			return int64(num * float64(mult)), nil
		}
	}
	
	return 0, fmt.Errorf("unknown size suffix")
}

// parseViaClause parses a "via=" clause.
func (p *Parser) parseViaClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected via URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ViaClause{URL: tok.value}, nil
}

// parseInsecureClause parses an "insecure=" clause.
func (p *Parser) parseInsecureClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected insecure value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "true" && value != "false" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "insecure accepts only 'true' or 'false'"}
	}
	
	return types.InsecureClause{Value: value == "true"}, nil
}

----
internal/planner/plan.go
// Package planner applies defaults, validates commands, and produces execution plans.
package planner

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// ExecutionPlan represents a fully resolved execution plan ready for HTTP runtime.
type ExecutionPlan struct {
	Verb        types.Verb         `json:"verb"`
	Method      string             `json:"method"`
	URL         string             `json:"url"`
	Headers     map[string]string  `json:"headers,omitempty"`
	QueryParams map[string]string  `json:"query_params,omitempty"`
	Cookies     map[string]string  `json:"cookies,omitempty"`
	Body        *BodyPlan          `json:"body,omitempty"`
	Output      *OutputPlan        `json:"output,omitempty"`
	Retry       *RetryPlan         `json:"retry,omitempty"`
	Timeout     *time.Duration    `json:"timeout,omitempty"`
	SizeLimit   *int64            `json:"size_limit,omitempty"`
	Proxy       string             `json:"proxy,omitempty"`
	Insecure    bool               `json:"insecure,omitempty"`
	Verbose     bool               `json:"verbose,omitempty"`
	Resume      bool               `json:"resume,omitempty"`
	Follow      string             `json:"follow,omitempty"` // "smart" or empty
	Expect      []types.ExpectCheck `json:"expect,omitempty"`
}

// BodyPlan represents the request body configuration.
type BodyPlan struct {
	Type     string                `json:"type"` // json, form, multipart, raw
	Content  string                `json:"content,omitempty"`
	FilePath string                `json:"file_path,omitempty"`
	Field    string                `json:"field,omitempty"` // for multipart
	AttachParts []types.AttachPart `json:"attach_parts,omitempty"` // for multipart
	Boundary string                `json:"boundary,omitempty"` // for multipart
}

// OutputPlan represents the output configuration.
type OutputPlan struct {
	Format      string `json:"format"` // json, csv, text, raw
	Destination string `json:"destination,omitempty"`
	Pick        string `json:"pick,omitempty"` // JSONPath expression
}

// RetryPlan represents retry configuration.
type RetryPlan struct {
	Count  int           `json:"count"`
	Backoff BackoffRange `json:"backoff"`
}

// BackoffRange represents a backoff range with min and max durations.
type BackoffRange struct {
	Min time.Duration `json:"min"`
	Max time.Duration `json:"max"`
}

// Plan creates an ExecutionPlan from a parsed Command.
func Plan(cmd *types.Command) (*ExecutionPlan, error) {
	plan := &ExecutionPlan{
		Verb:        cmd.Verb,
		URL:         cmd.Target.URL,
		Headers:     make(map[string]string),
		QueryParams: make(map[string]string),
		Cookies:     make(map[string]string),
	}

	// Apply verb-specific defaults
	if err := applyVerbDefaults(cmd.Verb, plan); err != nil {
		return nil, err
	}

	// Process clauses
	for _, clause := range cmd.Clauses {
		if err := applyClause(clause, plan, cmd.Verb); err != nil {
			return nil, err
		}
	}

	// Post-process: extract filename for save verb if destination not provided or is a directory
	if cmd.Verb == types.VerbSave && plan.Output != nil {
		if plan.Output.Destination == "" {
			// No destination provided, extract from URL
			filename := extractFilenameFromURL(plan.URL)
			if filename != "" {
				plan.Output.Destination = filename
			}
		} else {
			// Destination provided - check if it's a directory
			if isDirectory(plan.Output.Destination) {
				// It's a directory, append filename from URL
				filename := extractFilenameFromURL(plan.URL)
				if filename != "" {
					plan.Output.Destination = filepath.Join(plan.Output.Destination, filename)
				}
			}
			// If it's a file path (like /tmp/file.zip), use it as-is
		}
	}

	// Validate plan
	if err := validatePlan(plan); err != nil {
		return nil, err
	}

	return plan, nil
}

// applyVerbDefaults applies default settings based on the verb.
func applyVerbDefaults(verb types.Verb, plan *ExecutionPlan) error {
	switch verb {
	case types.VerbRead:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSave:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "raw"}
	case types.VerbSend:
		// Default to GET, will be changed to POST if with= is present
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbUpload:
		// Default to POST, but will error if no attach= or with= present
		plan.Method = http.MethodPost
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbWatch:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbInspect:
		plan.Method = http.MethodHead
		plan.Output = &OutputPlan{Format: "json"}
	case types.VerbAuthenticate:
		// Default to POST if with= is present, otherwise require using=
		// We'll check this in validatePlan
		plan.Method = http.MethodPost // tentative, may be overridden
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSession:
		// Session verbs are handled separately in main
		plan.Method = http.MethodGet // placeholder
		plan.Output = &OutputPlan{Format: "auto"}
	default:
		return fmt.Errorf("unsupported verb: %s", verb)
	}
	return nil
}

// validateUsingClause validates that the HTTP method is compatible with the verb.
func validateUsingClause(verb types.Verb, method string) error {
	allowedMethods := map[types.Verb][]string{
		types.VerbRead:    {"GET", "HEAD", "OPTIONS"},
		types.VerbSave:    {"GET", "POST"},
		types.VerbSend:   {"POST", "PUT", "PATCH"},
		types.VerbUpload: {"POST", "PUT"},
		types.VerbWatch:  {"GET"},
		types.VerbInspect: {"HEAD", "GET", "OPTIONS"},
	}
	
	allowed, ok := allowedMethods[verb]
	if !ok {
		// If verb not in map, allow any method (for future verbs like delete)
		return nil
	}
	
	for _, allowedMethod := range allowed {
		if method == allowedMethod {
			return nil
		}
	}
	
	return fmt.Errorf("verb '%s' is incompatible with method '%s'", verb, method)
}

// applyClause applies a clause to the execution plan.
func applyClause(clause types.Clause, plan *ExecutionPlan, verb types.Verb) error {
	switch c := clause.(type) {
	case types.UsingClause:
		// Validate compatibility before applying
		if err := validateUsingClause(verb, c.Method); err != nil {
			return err
		}
		// Normalize to uppercase (defensive, should already be normalized in parser)
		plan.Method = strings.ToUpper(c.Method)
	case types.HeadersClause:
		for k, v := range c.Headers {
			plan.Headers[k] = v
		}
	case types.ParamsClause:
		for k, v := range c.Params {
			plan.QueryParams[k] = v
		}
	case types.WithClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		
		// Handle file or stdin
		if c.IsFile {
			plan.Body.FilePath = c.Value
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for files
			}
		} else if c.IsStdin {
			plan.Body.FilePath = "-" // Special marker for stdin
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for stdin
			}
		} else {
			plan.Body.Content = c.Value
			plan.Body.Type = c.Type
			// If type was inferred as JSON, we'll note it in runtime
			if plan.Body.Type == "json" {
				// JSON inference will be logged in runtime
			}
		}
		
		// If method is still GET and we have a body, default to POST
		if plan.Method == http.MethodGet {
			plan.Method = http.MethodPost
		}
	case types.AsClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Format = c.Format
	case types.ToClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Destination = c.Destination
	case types.RetryClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{
				Backoff: BackoffRange{
					Min: 200 * time.Millisecond,
					Max: 5 * time.Second,
				},
			}
		}
		plan.Retry.Count = c.Count
	case types.BackoffClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{Count: 3}
		}
		plan.Retry.Backoff = BackoffRange{
			Min: c.Min,
			Max: c.Max,
		}
	case types.TimeoutClause:
		plan.Timeout = &c.Duration
	case types.ProxyClause:
		plan.Proxy = c.URL
	case types.PickClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Pick = c.Path
	case types.InsecureClause:
		plan.Insecure = c.Value
	case types.ViaClause:
		plan.Proxy = c.URL
	case types.IncludeClause:
		// Merge include items into headers, params, or cookies
		for _, item := range c.Items {
			switch item.Type {
			case "header":
				// For multi-valued headers, we'd need to track arrays, but for now last wins
				// TODO: Support multi-valued headers properly
				plan.Headers[item.Name] = item.Value
			case "param":
				// Params can be repeated, so we append to query params
				// The runtime will handle serialization
				plan.QueryParams[item.Name] = item.Value
			case "cookie":
				// Cookies: last value wins
				plan.Cookies[item.Name] = item.Value
			case "basic":
				// Basic Auth: encode username:password and set Authorization header
				// item.Value contains "username:password"
				credentials := item.Value
				// Base64 encode the credentials
				encoded := base64.StdEncoding.EncodeToString([]byte(credentials))
				// Set Authorization header with Basic scheme
				plan.Headers["Authorization"] = "Basic " + encoded
			}
		}
	case types.AttachClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		plan.Body.Type = "multipart"
		plan.Body.AttachParts = c.Parts
		if c.Boundary != "" {
			plan.Body.Boundary = c.Boundary
		}
	case types.ExpectClause:
		plan.Expect = c.Checks
	case types.FollowClause:
		plan.Follow = c.Policy
	case types.UnderClause:
		if c.IsSize {
			plan.SizeLimit = &c.Size
		} else {
			plan.Timeout = &c.Duration
		}
	case types.VerboseClause:
		plan.Verbose = true
	case types.ResumeClause:
		plan.Resume = true
	default:
		return fmt.Errorf("unsupported clause type: %T", clause)
	}
	return nil
}

// validatePlan validates the execution plan.
func validatePlan(plan *ExecutionPlan) error {
	if plan.Method == "" {
		return fmt.Errorf("method is required")
	}
	if plan.URL == "" {
		return fmt.Errorf("URL is required")
	}
	
	// Validate upload verb: must have attach= or with=
	// This check will be done after clauses are processed, so we check here
	// Actually, we need to check this in Plan() after processing clauses
	// For now, we'll do basic validation
	
	return nil
}

// extractFilenameFromURL extracts a filename from a URL.
func extractFilenameFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Get the path
	path := u.Path
	if path == "" || path == "/" {
		// Try to get from query or fragment
		return "download"
	}

	// Remove leading slash
	path = strings.TrimPrefix(path, "/")

	// Get the last segment
	parts := strings.Split(path, "/")
	if len(parts) == 0 {
		return "download"
	}

	filename := parts[len(parts)-1]

	// URL decode the filename (handle both path and query encoding)
	filename, err = url.PathUnescape(filename)
	if err != nil {
		// If PathUnescape fails, try QueryUnescape
		filename, err = url.QueryUnescape(filename)
		if err != nil {
			// If decoding fails, use the original
			filename = parts[len(parts)-1]
		}
	}

	// If filename is empty or doesn't have an extension, use a default
	if filename == "" || !strings.Contains(filename, ".") {
		filename = "download"
	}

	// Clean the filename (remove any path separators)
	filename = filepath.Base(filename)

	return filename
}

// isDirectory checks if a path is a directory.
func isDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}


----
internal/runtime/executor.go
// Package runtime executes HTTP requests based on execution plans.
package runtime

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/andybalholm/brotli"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
	"github.com/adammpkins/req/internal/session"
)

// Executor executes HTTP requests.
type Executor struct {
	client *http.Client
}

// NewExecutor creates a new executor.
func NewExecutor(plan *planner.ExecutionPlan) (*Executor, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create cookie jar: %w", err)
	}

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{},
	}

	// Configure TLS if insecure
	if plan.Insecure {
		transport.TLSClientConfig = getInsecureTLSConfig()
		fmt.Fprintf(os.Stderr, "Warning: TLS verification disabled\n")
	}

	// Configure proxy if specified
	if plan.Proxy != "" {
		proxyURL, err := url.Parse(plan.Proxy)
		if err != nil {
			return nil, fmt.Errorf("invalid proxy URL: %w", err)
		}
		transport.Proxy = http.ProxyURL(proxyURL)
	}

	client := &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
		Jar:       jar,
	}

	if plan.Timeout != nil {
		client.Timeout = *plan.Timeout
	}

	return &Executor{client: client}, nil
}

// Execute executes an HTTP request based on the plan.
func (e *Executor) Execute(plan *planner.ExecutionPlan) error {
	// Build request URL with query parameters (preserving order)
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("invalid URL: %v", err)}
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to build body: %v", err)}
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to create request: %v", err)}
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Auto-apply session if available and not explicitly set
	e.autoApplySession(req, plan)

	// Add Accept-Encoding if not set by user
	if req.Header.Get("Accept-Encoding") == "" {
		req.Header.Set("Accept-Encoding", "gzip, br")
	}

	// Execute request with redirect handling
	// For authenticate verb, we need to capture Set-Cookie from redirect responses
	var resp *http.Response
	var redirectTrace []string
	var bodyBytes []byte
	var decompressed bool
	var allSetCookies []string

	if plan.Verb == types.VerbAuthenticate {
		resp, redirectTrace, allSetCookies, err = e.executeWithRedirectsCapturingCookies(req, plan)
		if err != nil {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
		}
		defer resp.Body.Close()
		// Also include Set-Cookie from final response
		allSetCookies = append(allSetCookies, resp.Header.Values("Set-Cookie")...)
	} else {
		resp, redirectTrace, err = e.executeWithRedirects(req, plan)
		if err != nil {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
		}
		defer resp.Body.Close()
	}

	// Print redirect trace to stderr
	if len(redirectTrace) > 0 {
		for _, trace := range redirectTrace {
			fmt.Fprintf(os.Stderr, "%s\n", trace)
		}
	}

	// Read and decompress response body
	bodyBytes, decompressed, err = e.readAndDecompress(resp)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("failed to read response: %v", err)}
	}

	if decompressed {
		fmt.Fprintf(os.Stderr, "Decompressed response\n")
	}

	// Print meta to stderr
	e.printMeta(resp, reqURL, len(bodyBytes), decompressed)

	// Capture session for authenticate verb
	if plan.Verb == types.VerbAuthenticate {
		host, err := session.ExtractHost(plan.URL)
		if err == nil {
			updatedSession, err := session.UpdateSessionFromResponse(host, allSetCookies, bodyBytes)
			if err == nil && updatedSession != nil {
				if err := session.SaveSession(updatedSession); err == nil {
					fmt.Fprintf(os.Stderr, "Session saved for %s\n", host)
				}
			}
		}
	}

	// Run expect checks
	if len(plan.Expect) > 0 {
		if err := e.runExpectChecks(resp, bodyBytes, plan.Expect); err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			return &ExecutionError{Code: 3, Message: "expectation failed"}
		}
	} else {
		// If no expect checks, fail on non-2xx status codes
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("HTTP %d %s", resp.StatusCode, resp.Status)}
		}
	}

	// Handle output based on plan
	if plan.Output != nil && plan.Output.Destination != "" {
		// Save to file - uses io.Copy for efficient writing
		// TODO: Optimize to stream directly from resp.Body when no expect checks
		return e.saveToFile(bytes.NewReader(bodyBytes), plan.Output.Destination)
	}

	// Handle watch verb with TTY detection
	if plan.Verb == types.VerbWatch {
		// TODO: Implement TTY detection
		// TTY: timestamped lines
		// Non-TTY: raw lines
		return e.writeOutput(bodyBytes, plan.Output)
	}

	// Format and write output
	return e.writeOutput(bodyBytes, plan.Output)
}

// ExecutionError represents an execution error with exit code.
type ExecutionError struct {
	Code    int
	Message string
}

func (e *ExecutionError) Error() string {
	return e.Message
}

// buildURL builds the request URL with query parameters, preserving order.
func (e *Executor) buildURL(plan *planner.ExecutionPlan) (string, error) {
	u, err := url.Parse(plan.URL)
	if err != nil {
		return "", err
	}

	// Merge existing query params with new ones
	existingParams := u.Query()
	for k, v := range plan.QueryParams {
		// Append to preserve order for repeated keys
		existingParams.Add(k, v)
	}
	u.RawQuery = existingParams.Encode()

	return u.String(), nil
}

// buildBody builds the request body.
func (e *Executor) buildBody(plan *planner.ExecutionPlan) (io.Reader, string, error) {
	if plan.Body == nil {
		return nil, "", nil
	}

	// Handle multipart
	if plan.Body.Type == "multipart" {
		return e.buildMultipartBody(plan.Body)
	}

	// Handle file or stdin
	if plan.Body.FilePath != "" {
		if plan.Body.FilePath == "-" {
			// Read from stdin
			data, err := io.ReadAll(os.Stdin)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read stdin: %w", err)
			}
			plan.Body.Content = string(data)
		} else {
			// Read from file
			data, err := os.ReadFile(plan.Body.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", plan.Body.FilePath, err)
			}
			plan.Body.Content = string(data)
		}
	}

	// Determine content type
	contentType := ""
	if plan.Body.Type == "json" {
		contentType = "application/json"
		// Log JSON inference if it was inferred
		if strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "{") || strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "[") {
			fmt.Fprintf(os.Stderr, "Inferred Content-Type: application/json\n")
		}
	} else if plan.Body.Type == "form" {
		contentType = "application/x-www-form-urlencoded"
	}

	return strings.NewReader(plan.Body.Content), contentType, nil
}

// buildMultipartBody builds a multipart/form-data body.
func (e *Executor) buildMultipartBody(bodyPlan *planner.BodyPlan) (io.Reader, string, error) {
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	boundary := bodyPlan.Boundary
	if boundary == "" {
		boundary = writer.Boundary()
	} else {
		writer.SetBoundary(boundary)
	}

	for _, part := range bodyPlan.AttachParts {
		var partWriter io.Writer
		var err error

		// Create form field
		if part.Filename != "" {
			partWriter, err = writer.CreateFormFile(part.Name, part.Filename)
		} else {
			partWriter, err = writer.CreateFormField(part.Name)
		}
		if err != nil {
			return nil, "", fmt.Errorf("failed to create form field: %w", err)
		}

		// Write part content
		if part.FilePath != "" {
			// Read file
			data, err := os.ReadFile(part.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", part.FilePath, err)
			}
			if _, err := partWriter.Write(data); err != nil {
				return nil, "", fmt.Errorf("failed to write file data: %w", err)
			}
		} else {
			// Write value
			if _, err := partWriter.Write([]byte(part.Value)); err != nil {
				return nil, "", fmt.Errorf("failed to write value: %w", err)
			}
		}
	}

	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
	return &buf, contentType, nil
}

// setHeaders sets request headers.
func (e *Executor) setHeaders(req *http.Request, plan *planner.ExecutionPlan, contentType string) {
	// Set user headers first
	for k, v := range plan.Headers {
		req.Header.Set(k, v)
	}

	// Override Content-Type if multipart (user may have set it manually)
	if plan.Body != nil && plan.Body.Type == "multipart" {
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
			// Check if user had set Content-Type manually
			if _, wasSet := plan.Headers["Content-Type"]; wasSet {
				fmt.Fprintf(os.Stderr, "Note: Content-Type overridden for multipart\n")
			}
		}
	} else if contentType != "" && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", contentType)
	}
}

// setCookies sets request cookies.
func (e *Executor) setCookies(req *http.Request, plan *planner.ExecutionPlan) {
	for name, value := range plan.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}
}

// autoApplySession automatically applies a stored session if available.
func (e *Executor) autoApplySession(req *http.Request, plan *planner.ExecutionPlan) {
	// Don't auto-apply if Authorization or Cookie headers are explicitly set
	hasAuth := req.Header.Get("Authorization") != ""
	hasCookie := false
	for name := range plan.Cookies {
		if name != "" {
			hasCookie = true
			break
		}
	}
	if hasAuth || hasCookie {
		return
	}

	// Extract host from URL
	host, err := session.ExtractHost(plan.URL)
	if err != nil {
		return
	}

	// Load session
	sess, err := session.LoadSession(host)
	if err != nil || sess == nil {
		return
	}

	// Apply authorization if available
	if sess.Authorization != "" {
		req.Header.Set("Authorization", sess.Authorization)
	}

	// Apply cookies
	for name, value := range sess.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}

	fmt.Fprintf(os.Stderr, "Using session for %s\n", host)
}

// executeWithRedirects executes the request with redirect handling.
func (e *Executor) executeWithRedirects(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, error) {
	maxRedirects := 5
	var redirectTrace []string

	// Determine redirect policy based on verb
	shouldFollow := false
	isWriteVerb := plan.Method == "POST" || plan.Method == "PUT" || plan.Method == "PATCH" || plan.Method == "DELETE"

	if plan.Follow == "smart" {
		// Smart follow: only follow 307/308 for write verbs
		shouldFollow = true
	} else {
		// Default: read, save, and authenticate follow, write verbs don't
		if plan.Verb == types.VerbRead || plan.Verb == types.VerbSave || plan.Verb == types.VerbAuthenticate {
			shouldFollow = true
		} else if isWriteVerb {
			shouldFollow = false
		} else {
			// Other verbs (watch, inspect) don't follow by default
			shouldFollow = false
		}
	}

	if !shouldFollow {
		resp, err := e.client.Do(req)
		if err == nil && isWriteVerb && (resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303) {
			redirectTrace = append(redirectTrace, fmt.Sprintf("Advisory: %d redirect for write verb, not following", resp.StatusCode))
		}
		return resp, redirectTrace, err
	}

	// Follow redirects
	redirects := 0
	client := *e.client
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if redirects >= maxRedirects {
			return fmt.Errorf("stopped after %d redirects", maxRedirects)
		}

		// For smart follow with write verbs, only follow 307/308
		if plan.Follow == "smart" && isWriteVerb {
			statusCode := via[len(via)-1].Response.StatusCode
			if statusCode != 307 && statusCode != 308 {
				return fmt.Errorf("write verb: not following %d redirect (use 307/308)", statusCode)
			}
		}

		redirects++
		statusCode := via[len(via)-1].Response.StatusCode
		redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", statusCode, req.Method, req.URL.String()))
		return nil
	}

	resp, err := client.Do(req)
	return resp, redirectTrace, err
}

// executeWithRedirectsCapturingCookies executes the request with redirect handling,
// capturing Set-Cookie headers from all redirect responses.
// This is needed for authenticate verb to capture cookies from redirect responses.
func (e *Executor) executeWithRedirectsCapturingCookies(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, []string, error) {
	maxRedirects := 5
	var redirectTrace []string
	var allSetCookies []string

	// Use the client's CookieJar to automatically handle cookies during redirects
	// Then extract cookies from the jar after redirects complete
	client := *e.client
	client.CheckRedirect = nil // Disable automatic redirect following

	originalURL := req.URL
	for i := 0; i < maxRedirects; i++ {
		resp, err := client.Do(req)
		if err != nil {
			return nil, redirectTrace, allSetCookies, err
		}

		// Capture Set-Cookie headers from this response
		setCookies := resp.Header.Values("Set-Cookie")
		allSetCookies = append(allSetCookies, setCookies...)

		// Check if this is a redirect
		if resp.StatusCode >= 300 && resp.StatusCode < 400 {
			location := resp.Header.Get("Location")
			if location == "" {
				resp.Body.Close()
				return resp, redirectTrace, allSetCookies, nil
			}

			// Parse the location URL
			redirectURL, err := url.Parse(location)
			if err != nil {
				resp.Body.Close()
				return resp, redirectTrace, allSetCookies, fmt.Errorf("invalid redirect URL: %w", err)
			}

			// Make location absolute if needed
			if !redirectURL.IsAbs() {
				baseURL, _ := url.Parse(req.URL.String())
				redirectURL = baseURL.ResolveReference(redirectURL)
			}

			// Create new request for redirect
			redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", resp.StatusCode, req.Method, redirectURL.String()))
			resp.Body.Close()

			// Create new request for redirect (preserve method for 307/308)
			method := req.Method
			if resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303 {
				// Change to GET for these redirects
				method = "GET"
			}

			newReq, err := http.NewRequest(method, redirectURL.String(), nil)
			if err != nil {
				return nil, redirectTrace, allSetCookies, fmt.Errorf("failed to create redirect request: %w", err)
			}

			// Copy headers from original request
			for k, v := range req.Header {
				newReq.Header[k] = v
			}
			req = newReq
			continue
		}

		// Not a redirect, return the response
		// Extract cookies from CookieJar for the original host
		if client.Jar != nil {
			hostURL, err := url.Parse(originalURL.Scheme + "://" + originalURL.Host)
			if err == nil {
				jarCookies := client.Jar.Cookies(hostURL)
				// Convert jar cookies to Set-Cookie format strings
				for _, cookie := range jarCookies {
					allSetCookies = append(allSetCookies, fmt.Sprintf("%s=%s", cookie.Name, cookie.Value))
				}
			}
		}
		return resp, redirectTrace, allSetCookies, nil
	}

	return nil, redirectTrace, allSetCookies, fmt.Errorf("stopped after %d redirects", maxRedirects)
}

// readAndDecompress reads and decompresses the response body.
func (e *Executor) readAndDecompress(resp *http.Response) ([]byte, bool, error) {
	var reader io.Reader = resp.Body
	decompressed := false

	// Check if compressed - handle case-insensitive and multiple encodings
	encoding := resp.Header.Get("Content-Encoding")
	if encoding != "" {
		// Split by comma and check each encoding (case-insensitive)
		// Process encodings in reverse order (last encoding applied first)
		encodings := strings.Split(encoding, ",")
		for i := len(encodings) - 1; i >= 0; i-- {
			enc := strings.TrimSpace(strings.ToLower(encodings[i]))
			if enc == "gzip" {
				gzipReader, err := gzip.NewReader(reader)
				if err != nil {
					return nil, false, fmt.Errorf("failed to create gzip reader: %w", err)
				}
				defer gzipReader.Close()
				reader = gzipReader
				decompressed = true
			} else if enc == "br" {
				// brotli.Reader implements io.Reader
				reader = brotli.NewReader(reader)
				decompressed = true
			}
		}
	}

	data, err := io.ReadAll(reader)
	return data, decompressed, err
}

// runExpectChecks runs expectation checks on the response.
func (e *Executor) runExpectChecks(resp *http.Response, body []byte, checks []types.ExpectCheck) error {
	for _, check := range checks {
		if err := e.runExpectCheck(resp, body, check); err != nil {
			return err
		}
	}
	return nil
}

// runExpectCheck runs a single expectation check.
func (e *Executor) runExpectCheck(resp *http.Response, body []byte, check types.ExpectCheck) error {
	switch check.Type {
	case "status":
		expected := check.Value
		actual := fmt.Sprintf("%d", resp.StatusCode)
		if actual != expected {
			return fmt.Errorf("expected status %s, got %s", expected, actual)
		}

	case "header":
		actual := resp.Header.Get(check.Name)
		if actual != check.Value {
			return fmt.Errorf("expected header %s=%s, got %s", check.Name, check.Value, actual)
		}

	case "contains":
		if !strings.Contains(string(body), check.Value) {
			return fmt.Errorf("expected body to contain %q", check.Value)
		}

	case "jsonpath":
		// Simple JSON path extraction (basic implementation)
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			return fmt.Errorf("failed to parse JSON: %w", err)
		}
		// TODO: Implement proper JSONPath evaluation
		// For now, just check if JSON is valid
		_ = data

	case "matches":
		matched, err := regexp.MatchString(check.Regex, string(body))
		if err != nil {
			return fmt.Errorf("invalid regex: %w", err)
		}
		if !matched {
			return fmt.Errorf("body does not match regex %q", check.Regex)
		}

	default:
		return fmt.Errorf("unknown expect check type: %s", check.Type)
	}

	return nil
}

// printMeta prints metadata to stderr.
func (e *Executor) printMeta(resp *http.Response, url string, bodySize int, decompressed bool) {
	fmt.Fprintf(os.Stderr, "HTTP %d\n", resp.StatusCode)
	fmt.Fprintf(os.Stderr, "URL: %s\n", url)
	fmt.Fprintf(os.Stderr, "Size: %d bytes\n", bodySize)
	if ct := resp.Header.Get("Content-Type"); ct != "" {
		fmt.Fprintf(os.Stderr, "Content-Type: %s\n", ct)
	}
}

// writeOutput formats and writes output to stdout.
func (e *Executor) writeOutput(body []byte, output *planner.OutputPlan) error {
	if output == nil {
		// Default: raw output
		_, err := os.Stdout.Write(body)
		return err
	}

	switch output.Format {
	case "json":
		// Pretty print JSON
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			// Not JSON, output as-is
			_, err := os.Stdout.Write(body)
			return err
		}
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)

	case "text":
		// Output as text
		_, err := os.Stdout.Write(body)
		return err

	case "raw":
		// Raw output
		_, err := os.Stdout.Write(body)
		return err

	case "csv":
		// CSV output (basic - would need proper CSV parsing)
		_, err := os.Stdout.Write(body)
		return err

	default:
		// Default: raw
		_, err := os.Stdout.Write(body)
		return err
	}
}

// saveToFile saves the response body to a file.
func (e *Executor) saveToFile(body io.Reader, destination string) error {
	// Create directory if needed
	dir := filepath.Dir(destination)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Create file
	file, err := os.Create(destination)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Copy response body to file
	_, err = io.Copy(file, body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// getInsecureTLSConfig returns an insecure TLS config.
func getInsecureTLSConfig() *tls.Config {
	return &tls.Config{
		InsecureSkipVerify: true,
	}
}

// ExecuteWithResponse executes an HTTP request and returns the response body as a string.
// This is useful for TUI mode where we need to capture and format the response.
func (e *Executor) ExecuteWithResponse(plan *planner.ExecutionPlan) (string, error) {
	// Build request URL with query parameters
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return "", fmt.Errorf("failed to build body: %w", err)
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Execute request
	resp, _, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and decompress response body
	bodyBytes, _, err := e.readAndDecompress(resp)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(bodyBytes), nil
}

----
internal/session/session.go
// Package session manages HTTP sessions (cookies and tokens) per host.
package session

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Session represents a stored session for a host.
type Session struct {
	Host          string            `json:"host"`
	Cookies       map[string]string `json:"cookies,omitempty"`
	Authorization string            `json:"authorization,omitempty"` // Bearer token
}

var (
	stateDir     string
	stateDirOnce sync.Once
)

// getStateDir returns the user state directory for storing sessions.
func getStateDir() string {
	stateDirOnce.Do(func() {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to current directory
			stateDir = ".req"
			return
		}
		stateDir = filepath.Join(homeDir, ".config", "req")
	})
	return stateDir
}

// ensureStateDir ensures the state directory exists with proper permissions.
func ensureStateDir() error {
	dir := getStateDir()
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}
	return nil
}

// getSessionPath returns the file path for a host's session.
func getSessionPath(host string) (string, error) {
	if err := ensureStateDir(); err != nil {
		return "", err
	}
	// Sanitize host name for filename
	safeHost := strings.ReplaceAll(host, ":", "_")
	safeHost = strings.ReplaceAll(safeHost, "/", "_")
	return filepath.Join(getStateDir(), fmt.Sprintf("session_%s.json", safeHost)), nil
}

// LoadSession loads a session for the given host.
func LoadSession(host string) (*Session, error) {
	path, err := getSessionPath(host)
	if err != nil {
		return nil, err
	}

	// Check file permissions - refuse to load if group or world readable
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // No session exists
		}
		return nil, fmt.Errorf("failed to stat session file: %w", err)
	}

	mode := info.Mode().Perm()
	// Check if group or others have read permission (044, 004, or any combination)
	if mode&0044 != 0 {
		return nil, fmt.Errorf("session file %s has insecure permissions (%s): group or world readable, refusing to load", path, mode.String())
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read session: %w", err)
	}

	var session Session
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, fmt.Errorf("failed to parse session: %w", err)
	}

	return &session, nil
}

// SaveSession saves a session for the given host.
func SaveSession(session *Session) error {
	path, err := getSessionPath(session.Host)
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal session: %w", err)
	}

	// Write with strict permissions (0600)
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write session: %w", err)
	}

	return nil
}

// DeleteSession deletes a session for the given host.
func DeleteSession(host string) error {
	path, err := getSessionPath(host)
	if err != nil {
		return err
	}

	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil // Already deleted
		}
		return fmt.Errorf("failed to delete session: %w", err)
	}

	return nil
}

// ExtractHost extracts the host from a URL.
func ExtractHost(urlStr string) (string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}
	return u.Host, nil
}

// UpdateSessionFromResponse updates a session from an HTTP response.
// Captures Set-Cookie headers and access_token from JSON body.
func UpdateSessionFromResponse(host string, setCookies []string, body []byte) (*Session, error) {
	session, err := LoadSession(host)
	if err != nil {
		return nil, err
	}

	if session == nil {
		session = &Session{
			Host:    host,
			Cookies: make(map[string]string),
		}
	}

	// Parse Set-Cookie headers
	for _, cookieHeader := range setCookies {
		// Simple cookie parsing (just get name=value part)
		parts := strings.Split(cookieHeader, ";")
		if len(parts) > 0 {
			cookiePart := strings.TrimSpace(parts[0])
			eqIdx := strings.Index(cookiePart, "=")
			if eqIdx > 0 {
				name := cookiePart[:eqIdx]
				value := cookiePart[eqIdx+1:]
				session.Cookies[name] = value
			}
		}
	}

	// Try to extract access_token from JSON body
	if len(body) > 0 {
		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err == nil {
			if token, ok := jsonData["access_token"].(string); ok && token != "" {
				session.Authorization = "Bearer " + token
			}
		}
	}

	return session, nil
}

// ListSessions lists all stored sessions.
func ListSessions() ([]string, error) {
	dir := getStateDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read state directory: %w", err)
	}

	var hosts []string
	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "session_") && strings.HasSuffix(entry.Name(), ".json") {
			// Extract host from filename
			host := strings.TrimPrefix(entry.Name(), "session_")
			host = strings.TrimSuffix(host, ".json")
			host = strings.ReplaceAll(host, "_", ":")
			hosts = append(hosts, host)
		}
	}

	return hosts, nil
}

// RedactSession creates a redacted version of a session for display.
func RedactSession(session *Session) *Session {
	redacted := &Session{
		Host:          session.Host,
		Cookies:       make(map[string]string),
		Authorization: "",
	}

	// Redact cookies (show only names)
	for name := range session.Cookies {
		redacted.Cookies[name] = "***"
	}

	// Redact authorization
	if session.Authorization != "" {
		redacted.Authorization = "Bearer ***"
	}

	return redacted
}


----
internal/tui/app.go
// Package tui provides an interactive terminal user interface for req.
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/adammpkins/req/internal/tui/views"
)

// Launch starts the TUI application.
func Launch() error {
	p := tea.NewProgram(NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run TUI: %w", err)
	}
	return nil
}

// Model represents the application state.
type Model struct {
	view View
}

// NewModel creates a new TUI model.
func NewModel() Model {
	return Model{
		view: views.NewBuilderView(),
	}
}

// Init initializes the model.
func (m Model) Init() tea.Cmd {
	// WindowSizeMsg will be sent automatically by bubbletea
	return m.view.Init()
}

// Update handles messages and updates the model.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		// Pass window size to view
		var cmd tea.Cmd
		m.view, cmd = m.view.Update(msg)
		return m, cmd
	}

	var cmd tea.Cmd
	m.view, cmd = m.view.Update(msg)
	return m, cmd
}

// View renders the current view.
func (m Model) View() string {
	return m.view.View()
}

// View represents a TUI view (exported from views package).
type View = views.View


----
internal/tui/views/builder.go
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("62")).
			Padding(1, 2)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Padding(1, 2).
			Width(80)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46")).
			Padding(1, 2).
			Width(80)

	commandStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252")).
			Padding(1, 2).
			Width(80)

	// JSON syntax highlighting styles
	jsonKeyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true)

	jsonStringStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46"))

	jsonNumberStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("220"))

	jsonBoolStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("213"))

	jsonNullStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			Italic(true)

	jsonPunctStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252"))

	outputStyle = lipgloss.NewStyle().
			Padding(1, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("62"))
)

// View represents a TUI view interface.
type View interface {
	Init() tea.Cmd
	Update(msg tea.Msg) (View, tea.Cmd)
	View() string
}

// BuilderView is an interactive command builder.
type BuilderView struct {
	form         *huh.Form
	executed     bool
	response     string
	responseBody string
	formattedBody string
	err          error
	verb         string
	url          string
	execute      bool
	width        int
	height       int
	viewport     viewport.Model
}

// NewBuilderView creates a new builder view.
func NewBuilderView() View {
	vp := viewport.New(80, 20) // default width and height
	b := &BuilderView{
		width:    80, // default width
		height:   20, // default height
		viewport: vp,
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Verb").
				Description("Select the action to perform").
				Options(
					huh.NewOption("read - Read a resource (GET)", "read"),
					huh.NewOption("save - Save a resource to file (GET)", "save"),
					huh.NewOption("send - Send data (POST)", "send"),
				).
				Value(&b.verb).
				Key("verb"),

			huh.NewInput().
				Title("URL").
				Description("Enter the target URL").
				Placeholder("https://api.example.com/users").
				Value(&b.url).
				Key("url"),

			huh.NewConfirm().
				Title("Execute immediately?").
				Description("Execute the command when form is complete").
				Value(&b.execute).
				Key("execute"),
		),
	)

	b.form = form
	return b
}

// Init initializes the view.
func (b *BuilderView) Init() tea.Cmd {
	return b.form.Init()
}

// Update handles messages.
func (b *BuilderView) Update(msg tea.Msg) (View, tea.Cmd) {
	var cmds []tea.Cmd

	// Handle window size messages first
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		b.width = msg.Width
		b.height = msg.Height
		if b.width == 0 {
			b.width = 80 // default width
		}
		if b.height == 0 {
			b.height = 20 // default height
		}
		// Update viewport size
		b.updateViewportSize()
	}

	// Handle keyboard input
	switch msg := msg.(type) {
	case tea.KeyMsg:
		key := msg.String()
		
		// If we have output to scroll, handle scrolling keys first
		if b.formattedBody != "" {
			// Check if it's a scrolling key
			switch key {
			case "up", "k", "pgup":
				b.viewport.LineUp(1)
				return b, nil
			case "down", "j", "pgdown":
				b.viewport.LineDown(1)
				return b, nil
			case "home":
				b.viewport.GotoTop()
				return b, nil
			case "end":
				b.viewport.GotoBottom()
				return b, nil
			case "ctrl+u":
				b.viewport.LineUp(b.viewport.Height / 2)
				return b, nil
			case "ctrl+d":
				b.viewport.LineDown(b.viewport.Height / 2)
				return b, nil
			case "esc":
				return b, tea.Quit
			}
		} else {
			// No output, just handle quit
			switch key {
			case "esc":
				return b, tea.Quit
			}
		}
	}

	// Update form (only if not a scrolling key when we have output)
	form, cmd := b.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		b.form = f
		cmds = append(cmds, cmd)
	}

	// Handle messages from command execution
	switch msg := msg.(type) {
	case ErrorMsg:
		b.err = msg.Err
		b.executed = false
		b.responseBody = ""
		b.formattedBody = ""
		b.viewport.SetContent("")
	case SuccessMsg:
		b.response = msg.Message
		b.responseBody = msg.ResponseBody
		b.err = nil
		// Format the response body
		b.updateFormattedBody()
	}
	
	// Handle viewport updates for other messages (like mouse wheel, etc.)
	if b.formattedBody != "" {
		vp, cmd := b.viewport.Update(msg)
		b.viewport = vp
		if cmd != nil {
			cmds = append(cmds, cmd)
		}
	}

	// Check if form is complete and should execute
	if b.form.State == huh.StateCompleted {
		if !b.executed && b.verb != "" && b.url != "" {
			// Values are already bound to b.verb, b.url, and b.execute via Value() in form creation
			// The bound variables are updated automatically when form fields change
			if b.execute {
				b.executed = true
				cmds = append(cmds, b.executeCommand())
			} else {
				// Form completed but execute was false - show message
				b.response = "Command built but not executed. Press 'esc' to exit."
			}
		}
	}

	return b, tea.Batch(cmds...)
}

// executeCommand executes the built command.
func (b *BuilderView) executeCommand() tea.Cmd {
	return func() tea.Msg {
		// Build command string
		cmdStr := fmt.Sprintf("%s %s", b.verb, b.url)
		
		// Parse command
		cmd, err := parser.Parse(cmdStr)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Plan execution
		plan, err := planner.Plan(cmd)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Execute
		executor, err := runtime.NewExecutor(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Capture response body for TUI display
		responseBody, err := executor.ExecuteWithResponse(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		return SuccessMsg{
			Message:      "Command executed successfully",
			ResponseBody: responseBody,
		}
	}
}

// View renders the view.
func (b *BuilderView) View() string {
	var s strings.Builder

	s.WriteString(titleStyle.Render("req - Interactive Command Builder"))
	s.WriteString("\n\n")

	if b.err != nil {
		s.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", b.err)))
		s.WriteString("\n\n")
	}

	if b.response != "" {
		s.WriteString(successStyle.Render(b.response))
		s.WriteString("\n\n")
	}

	// Display response body with formatting (using viewport for scrolling)
	if b.formattedBody != "" {
		// Calculate available width and height for viewport
		contentWidth := b.width - 6 // Account for border and padding
		if contentWidth < 20 {
			contentWidth = 20 // Minimum width
		}
		
		// Calculate available height (account for header, success message, form, command line, instructions)
		// Rough estimate: title ~3, success ~2, form ~varies, command ~2, instructions ~1 = ~8-10 lines
		// Reserve some space for the form and other UI elements
		availableHeight := b.height - 15 // Reserve space for other UI elements
		if availableHeight < 5 {
			availableHeight = 5 // Minimum height
		}
		
		// Update viewport dimensions if needed
		b.updateViewportSize()
		
		// Render viewport with border
		// The viewport handles its own height, so we just need to wrap it with the border style
		viewportContent := b.viewport.View()
		// Use the viewport's actual dimensions for the border
		s.WriteString(outputStyle.Width(contentWidth + 4).Render(viewportContent))
		s.WriteString("\n\n")
	}

	s.WriteString(b.form.View())
	
	// Show current values when form is completed
	if b.form.State == huh.StateCompleted {
		s.WriteString("\n\n")
		if b.verb != "" && b.url != "" {
			cmdText := fmt.Sprintf("Command: %s %s", b.verb, b.url)
			// Wrap the command text to fit terminal width
			width := b.width
			if width == 0 {
				width = 80 // default width
			}
			wrapped := wrapText(cmdText, width)
			s.WriteString(commandStyle.Render(wrapped))
			s.WriteString("\n")
			if b.response != "" {
				s.WriteString("\n")
			}
		}
	}
	
	s.WriteString("\n")
	if b.formattedBody != "" {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit, ↑/↓ to scroll, pgup/pgdn for page scroll\n")
	} else {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit\n")
	}

	return s.String()
}

// ErrorMsg represents an error message.
type ErrorMsg struct {
	Err error
}

// SuccessMsg represents a success message.
type SuccessMsg struct {
	Message      string
	ResponseBody string
}

// wrapText wraps text to the specified width, breaking at word boundaries.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}
	
	var result strings.Builder
	words := strings.Fields(text)
	currentLine := ""
	
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		if len(testLine) > width {
			if currentLine != "" {
				result.WriteString(currentLine)
				result.WriteString("\n")
				currentLine = word
			} else {
				// Word is longer than width, just add it
				result.WriteString(word)
				result.WriteString("\n")
				currentLine = ""
			}
		} else {
			currentLine = testLine
		}
	}
	
	if currentLine != "" {
		result.WriteString(currentLine)
	}
	
	return result.String()
}

// updateFormattedBody formats the response body and updates the viewport content.
func (b *BuilderView) updateFormattedBody() {
	if b.responseBody == "" {
		b.formattedBody = ""
		b.viewport.SetContent("")
		return
	}
	
	// Calculate available width for content
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	// Format the response
	formatted := formatResponse(b.responseBody, contentWidth)
	b.formattedBody = formatted
	
	// Update viewport content
	b.viewport.SetContent(formatted)
	b.viewport.GotoTop() // Start at the top
}

// updateViewportSize updates the viewport dimensions based on available space.
func (b *BuilderView) updateViewportSize() {
	if b.responseBody == "" {
		return
	}
	
	// Calculate available width and height
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	availableHeight := b.height - 15 // Reserve space for other UI elements
	if availableHeight < 5 {
		availableHeight = 5 // Minimum height
	}
	
	// Update viewport dimensions
	b.viewport.Width = contentWidth
	b.viewport.Height = availableHeight
	
	// If content is already set, ensure it's properly sized
	if b.formattedBody != "" {
		b.viewport.SetContent(b.formattedBody)
	}
}

// formatResponse formats the response body with syntax highlighting for JSON.
func formatResponse(body string, width int) string {
	// Try to parse as JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(body), &jsonData); err == nil {
		// It's valid JSON, format it with syntax highlighting
		return formatJSON(body, width)
	}

	// Not JSON, return as-is with word wrapping
	return wrapText(body, width)
}

// formatJSON formats JSON with syntax highlighting using lipgloss.
func formatJSON(jsonStr string, width int) string {
	// First, pretty-print the JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(jsonStr), &jsonData); err != nil {
		return jsonStr // Return original if parsing fails
	}

	prettyJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return jsonStr // Return original if formatting fails
	}

	// Now apply syntax highlighting
	lines := strings.Split(string(prettyJSON), "\n")
	var formattedLines []string

	for _, line := range lines {
		formattedLine := highlightJSONLine(line)
		formattedLines = append(formattedLines, formattedLine)
	}

	return strings.Join(formattedLines, "\n")
}

// highlightJSONLine applies syntax highlighting to a single line of JSON.
func highlightJSONLine(line string) string {
	// This is a simple JSON highlighter that handles common cases
	// For a more robust solution, consider using a proper JSON tokenizer
	
	result := ""
	i := 0
	
	for i < len(line) {
		char := line[i]
		
		// Skip whitespace
		if char == ' ' || char == '\t' {
			result += string(char)
			i++
			continue
		}
		
		// Handle string literals
		if char == '"' {
			end := i + 1
			escaped := false
			for end < len(line) {
				if line[end] == '\\' && !escaped {
					escaped = true
					end++
				} else if line[end] == '"' && !escaped {
					end++
					// Check if this is a key (followed by :)
					isKey := end < len(line) && line[end] == ':'
					str := line[i:end]
					if isKey {
						result += jsonKeyStyle.Render(str)
					} else {
						result += jsonStringStyle.Render(str)
					}
					i = end
					break
				} else {
					escaped = false
					end++
				}
			}
			if end >= len(line) {
				// Unterminated string, just add it
				result += jsonStringStyle.Render(line[i:])
				break
			}
			continue
		}
		
		// Handle numbers
		if (char >= '0' && char <= '9') || char == '-' {
			start := i
			for i < len(line) && ((line[i] >= '0' && line[i] <= '9') || 
				line[i] == '.' || line[i] == 'e' || line[i] == 'E' || 
				line[i] == '+' || line[i] == '-' || line[i] == 'i' || 
				line[i] == 'n' || line[i] == 'f') {
				i++
			}
			result += jsonNumberStyle.Render(line[start:i])
			continue
		}
		
		// Handle boolean and null
		if strings.HasPrefix(line[i:], "true") {
			result += jsonBoolStyle.Render("true")
			i += 4
			continue
		}
		if strings.HasPrefix(line[i:], "false") {
			result += jsonBoolStyle.Render("false")
			i += 5
			continue
		}
		if strings.HasPrefix(line[i:], "null") {
			result += jsonNullStyle.Render("null")
			i += 4
			continue
		}
		
		// Handle punctuation
		if char == '{' || char == '}' || char == '[' || char == ']' || 
		   char == ',' || char == ':' {
			result += jsonPunctStyle.Render(string(char))
			i++
			continue
		}
		
		// Default: just add the character
		result += string(char)
		i++
	}
	
	return result
}

----
internal/types/command.go
// Package types provides shared types and enums used across the req package.
package types

import "time"

// Verb represents the action verb in a req command.
type Verb string

const (
	VerbRead         Verb = "read"
	VerbSave         Verb = "save"
	VerbSend         Verb = "send"
	VerbUpload       Verb = "upload"
	VerbWatch        Verb = "watch"
	VerbInspect      Verb = "inspect"
	VerbAuthenticate Verb = "authenticate"
	VerbSession      Verb = "session"
)

// Command represents a parsed req command AST.
type Command struct {
	Verb    Verb
	Target  Target
	Clauses []Clause
	// For session verb, subcommand (show, clear, use)
	SessionSubcommand string
}

// Target represents the URL or resource being acted upon.
type Target struct {
	URL string
}

// Clause represents a modifier clause in the command.
// This is a sum type that will be expanded as we add more clause types.
type Clause interface {
	clause()
}

// WithClause represents a "with=" clause for request body.
type WithClause struct {
	Value    string // inline value, file path, or "-" for stdin
	Type     string // json, form, etc. (inferred if empty)
	IsFile   bool   // true if value starts with @
	IsStdin  bool   // true if value is @-
}

func (WithClause) clause() {}

// HeadersClause represents a "headers=" clause.
type HeadersClause struct {
	Headers map[string]string
}

func (HeadersClause) clause() {}

// ParamsClause represents a "params=" clause for query parameters.
type ParamsClause struct {
	Params map[string]string
}

func (ParamsClause) clause() {}

// AsClause represents an "as=" clause for output format.
type AsClause struct {
	Format string // json, csv, text, raw
}

func (AsClause) clause() {}

// ToClause represents a "to=" clause for destination.
type ToClause struct {
	Destination string
}

func (ToClause) clause() {}

// UsingClause represents a "using=" clause for HTTP method override.
type UsingClause struct {
	Method string // GET, POST, PUT, PATCH, DELETE, etc.
}

func (UsingClause) clause() {}

// RetryClause represents a "retry=" clause.
type RetryClause struct {
	Count int
}

func (RetryClause) clause() {}

// BackoffClause represents a "backoff=" clause.
type BackoffClause struct {
	Min time.Duration
	Max time.Duration
}

func (BackoffClause) clause() {}

// TimeoutClause represents a "timeout=" clause.
type TimeoutClause struct {
	Duration time.Duration
}

func (TimeoutClause) clause() {}

// ProxyClause represents a "proxy=" clause.
type ProxyClause struct {
	URL string
}

func (ProxyClause) clause() {}

// PickClause represents a "pick=" clause for JSON path selection.
type PickClause struct {
	Path string // JSONPath expression
}

func (PickClause) clause() {}

// EveryClause represents an "every=" clause for polling.
type EveryClause struct {
	Interval time.Duration
}

func (EveryClause) clause() {}

// UntilClause represents an "until=" clause for conditional polling.
type UntilClause struct {
	Predicate string
}

func (UntilClause) clause() {}

// FieldClause represents a "field=" clause for multipart uploads.
type FieldClause struct {
	Name  string
	Value string
}

func (FieldClause) clause() {}

// VerboseClause represents the "verbose" flag.
type VerboseClause struct{}

func (VerboseClause) clause() {}

// ResumeClause represents the "resume" flag for resumable downloads.
type ResumeClause struct{}

func (ResumeClause) clause() {}

// IncludeClause represents an "include=" clause for headers, params, and cookies.
type IncludeClause struct {
	Items []IncludeItem
}

func (IncludeClause) clause() {}

// IncludeItem represents a single item in an include clause.
type IncludeItem struct {
	Type  string // "header", "param", "cookie", "basic"
	Name  string // header name, param key, or cookie key (empty for basic)
	Value string // header value, param value, cookie value, or username:password for basic
}

// AttachClause represents an "attach=" clause for multipart form data.
type AttachClause struct {
	Parts    []AttachPart
	Boundary string // optional explicit boundary
}

func (AttachClause) clause() {}

// AttachPart represents a single part in an attach clause.
type AttachPart struct {
	Name     string // required
	FilePath string // file=@path (mutually exclusive with Value)
	Value    string // value=... (mutually exclusive with FilePath)
	Filename string // optional filename
	Type     string // optional Content-Type
}

// ExpectClause represents an "expect=" clause for response assertions.
type ExpectClause struct {
	Checks []ExpectCheck
}

func (ExpectClause) clause() {}

// ExpectCheck represents a single assertion check.
type ExpectCheck struct {
	Type  string // "status", "header", "contains", "jsonpath", "matches"
	Name  string // for header checks, the header name
	Value string // the value to check against
	Path  string // for jsonpath, the JSONPath expression
	Regex string // for matches, the regex pattern
}

// FollowClause represents a "follow=" clause for redirect policy.
type FollowClause struct {
	Policy string // "smart" or empty for default
}

func (FollowClause) clause() {}

// UnderClause represents an "under=" clause for timeout or size limit.
type UnderClause struct {
	Duration time.Duration // if it's a duration
	Size     int64         // if it's a size (in bytes)
	IsSize   bool          // true if it's a size limit, false if duration
}

func (UnderClause) clause() {}

// ViaClause represents a "via=" clause for proxy URL.
type ViaClause struct {
	URL string
}

func (ViaClause) clause() {}

// InsecureClause represents an "insecure=" clause (updated to support true/false).
type InsecureClause struct {
	Value bool // true or false
}

func (InsecureClause) clause() {}


----
output.txt
The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encountered. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
.cursor/rules/grammar.mdc
# .cursor/rules/grammar.mdc

# req grammar - v0.1 specification

This documents the language. It is a DSL that reads like a sentence and runs in a shell.

## Command shape

    req <verb> <url> [clauses...]

Clauses are key=value pairs where keys are semantic words, not config words.

Order of clauses is free.

Unknown clause keys are errors.

## Verbs

- read - GET, print to stdout
- save - GET, write to file via to=
- send - default GET, POST if with= present
- upload - POST when attach= or with= present, else error
- watch - GET with SSE or polling
- inspect - HEAD only
- authenticate - login and store session state
- session show, session clear, session use - session management

## Clauses

| Clause     | Meaning                                     | Repeatable | Example                                                                 |
|-----------|---------------------------------------------|------------|-------------------------------------------------------------------------|
| using=    | HTTP method override                         | no         | using=PUT                                                               |
| include=  | Add headers, params, cookies                 | yes        | include='header: Authorization: Bearer token; param: q=search query'     |
| with=     | Request body                                 | no         | with=@user.json or with='{"name":"Adam"}'                               |
| expect=   | Assertions on response                       | no         | expect=status:200, header:Content-Type=application/json, contains:"ok"  |
| as=       | Output format for stdout                     | no         | as=json                                                                 |
| to=       | Destination path                             | no         | to=out.json                                                             |
| retry=    | Retry attempts for transient errors          | no         | retry=3                                                                 |
| under=    | Timeout or size limit                        | no         | under=30s or under=10MB                                                 |
| via=      | Proxy URL                                    | no         | via=http://proxy:8080                                                   |
| attach=   | Multipart parts for upload or send           | yes        | attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'    |
| follow=   | Redirect policy for write verbs              | no         | follow=smart                                                            |
| insecure= | Disable TLS verification for this request    | no         | insecure=true                                                           |

### include= value grammar

- One include clause may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - header: Name: Value
  - param: key=value
  - cookie: key=value
  - basic: username:password

Merging
- Headers: keep all values for multi valued headers, else last wins.
- Params: repeated keys become repeated pairs in insertion order.
- Cookies: last value wins per cookie name.
- Basic Auth: sets Authorization header, overrides any existing Authorization header.

Quoting
- If an item payload contains a semicolon, quote the value.
- Backslash escapes allowed inside quoted values for the quote char and backslash.

Errors
- Unknown tag before the first colon.
- Header without Name colon Value.
- Param or cookie missing equals.
- Basic item missing colon (must be username:password format).
- Unquoted semicolon inside an item payload.

Examples

    include='header: Accept: application/json, application/problem+json; q=0.9'
    include='param: q=search query; param: tag=ai; param: tag=ml'
    include='cookie: session=abc; cookie: prefs="a=1; b=2"'
    include='basic: user:pass; header: Accept: application/json'

### attach= value grammar

- One attach may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - part: name=..., file=@path  or  part: name=..., value=...
  - Optional filename=...
  - Optional type=media/type
  - boundary: TOKEN optional

Validation
- name is required.
- exactly one of file or value is required.
- for file parts, @path must exist at execution time.

Header behavior
- Any attach= forces multipart Content-Type with a generated boundary.
- If user included a manual Content-Type, override it and print a one line note.

Examples

    attach='part: name=avatar, file=@./me.png, filename=me.png, type=image/png'
    attach='part: name=meta, value={"name":"adam"}'
    attach='part: name=file, file=@./a.png; part: name=meta, value=xyz'

### with= body modes

- Inline text or JSON.
- @file to read from file.
- @- to read from stdin.

Content type
- If Content-Type is not set and inline begins with "{" or "[", infer application/json and note on stderr.
- An explicit Content-Type header always overrides inference.

### expect= assertions

Single clause with comma separated checks. All must pass.

Supported checks
- status:200
- header:Content-Type=application/json
- contains:"text"
- jsonpath:"$.items[0].id"
- matches:"^OK\\b"

Exit codes
- 0 success and expectations passed.
- 3 request ok but an expectation failed.

Failure messages must be concise and specific.

### Redirects

- read and save follow up to 5 redirects by default.
- write verbs do not follow by default.
- follow=smart for writes follows only 307 and 308, up to 5 hops.
- On 301, 302, 303 for writes, do not follow and print an advisory.

### Compression

- If user did not set Accept-Encoding, send "Accept-Encoding: gzip, br".
- Auto decompress gzip or br before as= and expect=.
- Print a one line note when decompression occurs.

### TLS

- insecure=true disables certificate verification for this request only.
- Print one line warning on stderr.

### Sessions

authenticate
- Follows redirects.
- Captures Set-Cookie.
- If response is JSON with a top level access_token, store it as a Bearer token.
- Store per host under user state dir with strict perms.

Auto use
- Any request to a host with a stored session auto applies cookies and Authorization unless caller includes those explicitly.
- Print "Using session for <host>" when applied.

session verbs
- session show <host> prints redacted info. as=json prints machine friendly form.
- session clear <host> deletes state.
- session use <host> prints env stub for shell scoping.

### Method defaults

- read GET
- save GET
- send GET by default, POST if with= present
- upload POST when attach= present, else POST if with= present, else error
- watch GET
- inspect HEAD
- authenticate POST if with= present, else require using=

### Multiplicity and ordering

- Singletons: using, with, expect, as, to, retry, under, via, insecure, follow.
- Repeatable: include, attach.
- Clause order is free.
- Explicit include of Authorization or Cookie overrides session.

### Token and quoting model

- Parser consumes argv tokens as provided by the shell.
- Do not re split on spaces.
- Values containing semicolons must be quoted.
- Backslash escapes allowed inside quotes for the quote char and backslash.
- Environment variables are expanded by the shell before argv.

### Errors that must be loud and specific

- Unknown clause key.
- Duplicate singletons.
- include item with unknown tag or malformed payload.
- header item missing Name colon Value.
- param or cookie missing equals.
- basic item missing colon (must be username:password format).
- unquoted semicolon in an item payload.
- attach part missing name, or missing both file and value, or providing both.
- URL parse failure.
- file path not found for with or attach.
- timeout or size limit exceeded.
- TLS error when insecure=false.

### Error message examples

Each error class must produce a specific, actionable message. Examples:

Unknown clause key

    $ req read https://example.com invalid=clause
    Error: parse error at position 2 (token: "invalid"): unknown clause

Duplicate singleton

    $ req read https://example.com with=test with=test2
    Error: parse error at position 3 (token: "with"): duplicate singleton clause 'with' (did you mean "remove duplicate 'with=' clause"?)

Unquoted semicolon in include

    $ req read https://example.com include='param: q=test;value'
    Error: parse error at position 2 (token: "include"): unquoted semicolon in include item

Malformed header (missing Name: Value)

    $ req read https://example.com include='header: InvalidHeader'
    Error: parse error at position 2 (token: "include"): header item missing Name: Value format

Missing equals in param or cookie

    $ req read https://example.com include='param: q'
    Error: parse error at position 2 (token: "include"): param missing equals

Basic item missing colon

    $ req read https://example.com include='basic: userpass'
    Error: parse error at position 2 (token: "include"): basic item must be in format username:password: basic: userpass

Attach part missing name

    $ req upload https://example.com attach='part: file=@test.png'
    Error: parse error at position 2 (token: "attach"): attach part missing name

Attach part with both file and value

    $ req upload https://example.com attach='part: name=test, file=@test.png, value=text'
    Error: parse error at position 2 (token: "attach"): attach part cannot have both file and value

File not found for with

    $ req send https://example.com with=@nonexistent.json
    Error: file not found: nonexistent.json

File not found for attach

    $ req upload https://example.com attach='part: name=file, file=@nonexistent.png'
    Error: file not found: nonexistent.png

### Output contracts

stdout
- Response body, formatted per as=.
- For save, write to file and keep stdout empty unless a specific mode says otherwise.

stderr
- Compact meta block: status, url, duration, bytes, content type.
- Notices: session use, decompression, redirect trace, TLS warning, multipart override note.
- Secrets redacted in meta lines.

### End to end examples

Read with params and header

    req read https://api.example.com/search \
      include='param: q=search query; header: X-Trace: 1' \
      as=json

Write JSON with auth and assertion

    req send https://api.example.com/users \
      using=POST \
      include='header: Authorization: Bearer $TOKEN' \
      with='{"name":"Adam"}' \
      expect=status:201, header:Content-Type=application/json \
      as=json

Multipart upload

    req upload https://api.example.com/upload \
      attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
      as=json

Authenticate then use session

    req authenticate https://api.example.com/login \
      using=POST \
      with='{"user":"adam","pass":"xyz"}'

    req read https://api.example.com/me as=json

Write with safe redirects

    req send https://api.example.com/endpoint \
      using=POST \
      with='{"a":1}' \
      follow=smart \
      expect=status:200

----
.cursor/rules/plan.mdc
---
alwaysApply: true
---
# /.cursor/plan.md

# req project plan - v0.1 to 90 percent curl coverage

This is a strict, test-driven plan. Each task has acceptance criteria. No code here. Use these goals as Cursor prompts.

## 1) Lock the surface grammar
- Enforce command shape: `req <verb> <url> [clauses...]`
- Allowed verbs: read, save, send, upload, watch, inspect, authenticate, session (show|clear|use)
- Allowed clauses: using=, include=, with=, expect=, as=, to=, retry=, under=, via=, attach=, follow=smart, insecure=true
- Clause order independent

Acceptance
- Unknown clause keys hard error with nearest suggestion
- Duplicate singletons hard error with fix hint
- Golden tests for valid and invalid examples
- `req help` prints the grammar summary

## 2) include= value grammar
Goal
- Implement semicolon separated items with explicit tags

Do
- Items: `header: Name: Value`, `param: key=value`, `cookie: key=value`
- Values may be quoted
- Multiple include= clauses allowed

Merging rules
- Headers: keep all for multi valued headers, else last wins
- Params: repeated keys become repeated pairs in order
- Cookies: last value wins

Acceptance
- Unit tests for quoting, embedded semicolons, repeated keys, error cases
- Golden tests for combined include payloads

## 3) attach= multipart grammar
Goal
- Repeatable clause for multipart form data

Do
- Items: `part: ...` and `boundary: ...`
- Part kvs: `name=`, one of `file=@path` or `value=`, optional `filename=`, optional `type=media/type`
- Validate name required, exactly one of file or value
- Any attach= forces `Content-Type: multipart/form-data; boundary=...`
- If user set Content-Type manually, override and print a one line note

Acceptance
- Unit tests for file, text, mixed parts, explicit boundary, malformed descriptors
- Integration test uses echo server to assert parts

## 4) follow=smart and insecure=true
Goal
- Add redirect and TLS toggles

Do
- follow accepts only `smart`
- insecure accepts `true` or `false`

Acceptance
- Unit tests parse both correctly and reject bad values

## 5) with= body modes and light inference
Goal
- Support inline, @file, @-

Do
- If Content-Type is not set and inline begins with `{` or `[`, infer `application/json` and log a one line note on stderr
- Explicit header always overrides inference

Acceptance
- Tests for inference, override, and no inference on file

## 6) expect= assertions
Goal
- Single clause with comma separated checks

Checks
- `status:200`
- `header:Content-Type=application/json`
- `contains:"text"`
- `jsonpath:"$.items[0].id"`
- `matches:"^OK\\b"`

Acceptance
- Exit 3 on any failure, with a concise diff-like message
- Tests for pass and fail cases

## 7) Verb defaults and method validation
Goal
- Map verbs to default methods and validate using=

Defaults
- read GET
- save GET
- send GET by default, POST if with= present
- upload POST if attach= or with= present, else error
- watch GET
- inspect HEAD
- authenticate default POST if with= present

Acceptance
- Tests for defaults and invalid combinations

## 8) Redirect policy
Goal
- Implement safe redirect rules

Rules
- read and save follow up to 5 by default
- write verbs do not follow by default
- follow=smart follows only 307 and 308 for writes, up to 5
- On 301, 302, 303 for writes, do not follow, print advisory

Acceptance
- Integration tests for 301, 302, 303, 307, 308 with and without smart
- Stderr shows compact trace

## 9) Transparent compression
Goal
- gzip and br on by default

Do
- Inject Accept-Encoding unless user set it
- Auto decompress before as= and expect=
- One line stderr note when decompressed

Acceptance
- gz and br tests, expect sees decoded text, user header respected

## 10) TLS control
Goal
- Implement insecure=true

Acceptance
- Self signed server fails normally, succeeds with insecure=true
- One line stderr warning: TLS verification disabled

## 11) Query param merging and URL assembly
Goal
- Merge URL params with include param items

Acceptance
- Repeated keys serialize in insertion order
- Proper percent encoding
- Existing URL params preserved and merged

## 12) Output control with as= and to=
Goal
- Finalize sinks and formatting

Do
- as=json, text, raw, csv
- to=PATH writes file. For save, derive filename from URL if needed
- stdout is body, stderr is compact meta with redaction

Acceptance
- Filename extraction, directory handling, percent decoding, meta block content

## 13) Sessions and authenticate
Goal
- Explicit session model

Do
- authenticate captures Set-Cookie and `access_token` from JSON
- Store per host in user state dir with strict perms
- Auto apply for matching host unless caller includes Authorization or Cookie
- Print `Using session for <host>` on use
- session show, session clear, session use implemented

Acceptance
- Integration tests for login, reuse, override, redaction, permission refusal

## 14) Multipart body construction
Goal
- Build body with generated boundary and proper part headers

Acceptance
- Echo server validates Content-Disposition, Content-Type, filenames and order
- Manual Content-Type overridden with a note

## 15) Errors, hints, exit codes
Goal
- Clear, specific failures

Acceptance
- Exit codes: 0 ok, 3 expect fail, 4 network, 5 grammar
- Hints for unquoted semicolons, missing equals, duplicate singletons, unknown clause, bad attach part

## 16) Help and explain
Goal
- Discoverability tools

Do
- `req help` prints grammar table and examples
- `req explain "<command>"` prints parsed plan without executing

Acceptance
- Golden tests for explain output

## 17) Cross shell quoting doc
Goal
- Portability guidance

Do
- Quoting cheat sheet for bash, zsh, fish, PowerShell
- Curl vs req mapping table for common tasks

Acceptance
- Docs included and examples parse in a simple parser smoke test

## 18) CI, golden, fixtures
Goal
- Stable test harness

Do
- Golden tests for parser and explain
- Local HTTP fixture: echo headers, cookies, query, gzip, br, 30x, multipart
- Run under race detector

Acceptance
- CI green across Go versions you support

## 19) Streaming and watch polish
Goal
- Memory efficient downloads and sensible watch output

Do
- Stream to file for save
- Watch prints timestamps on TTY, raw otherwise

Acceptance
- Large download uses low memory
- Watch behaves per TTY detection

## 20) README refresh
Goal
- Align docs with grammar

Do
- Replace stale examples with include, attach, expect forms
- Document redirect defaults and smart policy
- Add warning about insecure=true and shell history

Acceptance
- Doc snippets pass as golden examples

----
.github/ISSUE_TEMPLATE/bug_report.md
---
name: Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Description

A clear and concise description of what the bug is.

## Reproduction

**Command:**
```bash
req <your-command-here>
```

**Expected Output:**
```
<expected-output>
```

**Actual Output:**
```
<actual-output>
```

## Environment

- OS: [e.g., Linux, macOS, Windows]
- Architecture: [e.g., amd64, arm64]
- Version: [e.g., v0.1.0]
- Go version: [e.g., 1.24]

## Additional Context

Add any other context about the problem here, including:
- Error messages
- Stack traces (if applicable)
- Workarounds you've tried


----
.github/ISSUE_TEMPLATE/feature_request.md
---
name: Feature Request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Summary

A clear and concise description of the feature you'd like to see.

## Motivation

Why is this feature needed? What problem does it solve?

## Detailed Description

Describe the feature in detail:
- What should the command syntax look like?
- What should the output look like?
- Are there any edge cases to consider?

## Example Usage

```bash
req <example-command>
```

## Alternatives Considered

Describe any alternative solutions or features you've considered.

## Additional Context

Add any other context, mockups, or examples about the feature request here.


----
.github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Run tests with race detector
        run: make test
      
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          make vulncheck
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m
  
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-${{ matrix.os }}
          path: bin/req
  
  windows:
    name: Windows Build
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-windows
          path: bin/req.exe

  grammar-drift:
    name: Grammar Drift Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build binary
        run: make build
      
      - name: Run grammar drift tests
        run: go test -v ./tests -run 'TestGrammarDrift|TestBinaryHelpDrift'


----
.gitignore
# Binaries
bin/
req
req.exe

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
*.tar.gz
*.zip


----
.golangci.yml
# golangci-lint configuration with lean modern linter set
run:
  timeout: 5m
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  gocritic:
    enabled-tags:
      - diagnostic
  govet:
    check-shadowing: true
  misspell:
    locale: US
  nolintlint:
    allow-leading-space: true
    allow-unused: false
    require-explanation: false
    require-specific: false

linters:
  disable-all: true
  enable:
    - errcheck
    - gocritic
    - goimports
    - gosimple
    - govet
    - ineffassign
    - misspell
    - nolintlint
    - staticcheck

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
  max-issues-per-linter: 0
  max-same-issues: 0

----
.goreleaser.yml
# GoReleaser configuration for cross-platform releases
project_name: req

before:
  hooks:
    - go mod download

builds:
  - id: req
    main: ./cmd/req
    binary: req
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    goarm:
      - 6
      - 7
    ignore:
      - goos: windows
        goarch: arm64
    env:
      - CGO_ENABLED=0
    flags:
      - -trimpath
      - -ldflags=-s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.buildDate={{.Date}}

archives:
  - id: default
    builds:
      - req
    format_overrides:
      - goos: windows
        format: zip
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    files:
      - LICENSE
      - README.md

checksum:
  name_template: "{{ .ProjectName }}_{{ .Version }}_checksums.txt"

snapshot:
  name_template: "{{ .Tag }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"


----
LICENSE
MIT License

Copyright (c) 2025 Adam Perkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


----
Makefile
.PHONY: build test lint package golden clean help

# Variables
BINARY_NAME=req
MAIN_PATH=./cmd/req
VERSION?=dev
BUILD_DIR=./bin
COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build the req binary
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
ifeq ($(GOOS),windows)
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME).exe $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME).exe"
else
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"
endif

test: ## Run tests with race detector
	@echo "Running tests..."
	@go test -race -cover -v ./...

test-golden: ## Run golden file tests
	@echo "Running golden tests..."
	@go test -v ./tests -run TestGolden

golden: ## Regenerate golden test files
	@echo "Regenerating golden files..."
	@go test ./tests -run TestGolden -update

lint: ## Run golangci-lint
	@echo "Running golangci-lint..."
	@golangci-lint run

lint-fix: ## Run golangci-lint with auto-fix
	@golangci-lint run --fix

vulncheck: ## Run govulncheck
	@echo "Running govulncheck..."
	@govulncheck ./...

package: ## Build release artifacts locally (requires goreleaser)
	@echo "Building release artifacts..."
	@goreleaser build --snapshot --clean

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@go clean -cache

install: build ## Install binary to GOPATH/bin
	@go install $(MAIN_PATH)


----
README.md
# req

A semantic HTTP client written in Go that replaces traditional curl syntax with a natural, intent-based grammar.

## Overview

`req` is an HTTP client tool that focuses on:

- **Human-readable commands** (verbs + clauses)
- **Sensible defaults** (follow redirects, TLS verify, retries)
- **JSON/CSV/text awareness** with intelligent output
- **Watch mode** (poll or stream)
- **Session management** (authenticate and auto-apply)
- **Pretty diagnostics** and dry-run transparency

## Quick Start

```bash
# Read JSON from an API
req read https://api.example.com/users as=json

# Send JSON data
req send https://api.example.com/users with='{"name":"Adam"}'

# Send with headers and assertions
req send https://api.example.com/users \
  using=POST \
  include='header: Authorization: Bearer $TOKEN' \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json \
  as=json

# Save a file
req save https://example.com/file.zip to=file.zip

# Upload multipart form data
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png' \
  as=json

# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Use stored session automatically
req read https://api.example.com/me as=json
```

## Installation

```bash
go install github.com/adammpkins/req/cmd/req@latest
```

Or download a pre-built binary from the [Releases](https://github.com/adammpkins/req/releases) page.

## Grammar

The `req` command follows this grammar:

```
req <verb> <target> [clauses...]
```

### Verbs

- `read` - GET, print to stdout
- `save` - GET, write to file via to=
- `send` - default GET, POST if `with=` is present
- `upload` - POST when `attach=` or `with=` present, else error
- `watch` - GET with SSE or polling
- `inspect` - HEAD only
- `authenticate` - login and store session state
- `session` - session management (show, clear, use)

### Clauses

- `using=<method>` - HTTP method override
- `include=<items>` - Add headers, params, cookies (repeatable)
  - Format: `include='header: Name: Value; param: key=value; cookie: key=value'`
- `with=<body>` - Request body
  - Format: `with=@user.json` or `with='{"name":"Adam"}'`
  - JSON inference: Automatically sets Content-Type for JSON when inline starts with `{` or `[`
- `expect=<checks>` - Assertions on response
  - Format: `expect=status:200, header:Content-Type=application/json, contains:"ok"`
- `as=<format>` - Output format for stdout
- `to=<path>` - Destination path
- `retry=<count>` - Retry attempts for transient errors
- `under=<limit>` - Timeout or size limit
  - Format: `under=30s` or `under=10MB`
- `via=<url>` - Proxy URL
- `attach=<parts>` - Multipart parts for upload or send (repeatable)
  - Format: `attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'`
- `follow=<policy>` - Redirect policy for write verbs
  - Format: `follow=smart`
- `insecure=<bool>` - Disable TLS verification for this request
  - Format: `insecure=true`

## Examples

### Read JSON

```bash
req read https://api.example.com/users as=json
```

### Send JSON Data

```bash
req send https://api.example.com/users with='{"name":"Ada","email":"ada@example.com"}'
```

### Save a File

```bash
# Save with explicit filename
req save https://example.com/file.zip to=file.zip

# Save with auto-detected filename (extracts from URL)
req save https://example.com/file.zip

# Save to directory path
req save https://example.com/file.zip to=/tmp/file.zip
```

### With Headers, Params, and Cookies

```bash
# Using include clause
req read https://api.example.com/search \
  include='header: Authorization: Bearer $TOKEN; param: q=search query; cookie: session=abc123' \
  as=json
```

### With Assertions

```bash
req send https://api.example.com/users \
  using=POST \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json, contains:"id" \
  as=json
```

### Sessions

```bash
# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Session is automatically used for subsequent requests
req read https://api.example.com/me as=json

# Show stored session (redacted)
req session show api.example.com

# Show session in JSON format
req session show api.example.com as=json

# Clear session
req session clear api.example.com
```

### Redirects

```bash
# Read and save follow redirects by default (up to 5)
req read https://example.com/redirect

# Write verbs don't follow by default
req send https://api.example.com/create using=POST with='{"data":"value"}'

# Use smart follow for write verbs (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
```

### With Retry and Timeout

```bash
req read https://api.example.com/users retry=3 under=10s as=json
```

### Edge Cases

```bash
# Header with commas and q values (must be quoted)
req read https://api.example.com/search \
  include='header: Accept: application/json, application/problem+json; q=0.9' \
  as=json

# Cookie value containing semicolons (must be quoted)
req read https://api.example.com/search \
  include='cookie: prefs="a=1; b=2; c=3"' \
  as=json

# Multipart upload with file and text parts (Content-Type automatically overridden)
req upload https://api.example.com/upload \
  include='header: Content-Type: application/json' \
  attach='part: name=file, file=@avatar.png; part: name=meta, value={"name":"test"}' \
  as=json
# Note: Content-Type will be overridden to multipart/form-data

# Smart redirect on write verb (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
# Will follow 307/308 redirects, but not 301/302/303

# Write verb with 303 redirect (advisory printed, not followed)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}'
# If server returns 303, advisory message printed but redirect not followed
```

### Method Override

```bash
# Use PUT instead of POST
req send https://api.example.com/users/1 using=PUT with='{"name":"Updated"}'

# Use PATCH for partial updates
req send https://api.example.com/users/1 using=PATCH with='{"email":"new@example.com"}'

# Use HEAD to check headers without body
req read https://api.example.com/users using=HEAD
```

**Note:** The `using=` clause validates method-verb compatibility. For example, `read using=POST` will fail as `read` only allows GET, HEAD, or OPTIONS.

### Comparison with curl

| Task | curl | req |
|------|------|-----|
| **Basic GET with headers** | `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include='header: Authorization: Bearer $TOKEN'` |
| **Multipart upload** | `curl -F "file=@avatar.png" -F "name=test" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png; part: name=name, value=test'` |
| **Authenticated POST** | `curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users using=POST include='header: Authorization: Bearer $TOKEN' with='{"name":"Adam"}'` |

### Dry Run

```bash
req read https://api.example.com/users as=json --dry-run
```

### Interactive TUI Mode

```bash
# Launch interactive TUI mode
req --tui

# Or run without arguments to launch TUI
req
```

The TUI mode provides:
- Interactive command builder with form-based input
- **Syntax-highlighted JSON output** with color-coded keys, values, and punctuation
- **Scrollable viewport** for long responses with keyboard navigation
- Pretty-printed JSON with automatic indentation
- Real-time command execution and response display

**Keyboard Controls:**
- `↑` / `↓` or `k` / `j` - Scroll line by line
- `pgup` / `pgdown` - Page scrolling
- `home` - Jump to top
- `end` - Jump to bottom
- `ctrl+u` / `ctrl+d` - Half-page scrolling
- `esc` - Quit TUI

## Security

### Shell History

**Warning:** Commands containing secrets (tokens, passwords) are stored in your shell history by default. Use environment variables to avoid exposing secrets:

```bash
# Bad: Token appears in shell history
req read https://api.example.com/users include='header: Authorization: Bearer secret-token-123'

# Good: Use environment variable
TOKEN="secret-token-123"
req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"
```

To prevent secrets from being saved to history:
- **Bash/Zsh:** Prefix command with a space (requires `HISTCONTROL=ignorespace` or `setopt HIST_IGNORE_SPACE`)
- **Fish:** Use `history --delete` after running commands with secrets
- **PowerShell:** Use `Set-PSReadlineOption -HistoryNoDuplicates` and manually edit history

### Session Files

Session files are stored in `~/.config/req/session_<host>.json` with permissions `0600` (owner read/write only).

**Security rules:**
- Session files are created with strict permissions (`0600`)
- If a session file has group or world readable permissions, `req` will refuse to load it
- Session files contain sensitive data (cookies, tokens) and should be protected
- Never commit session files to version control

To check session file permissions:
```bash
ls -l ~/.config/req/session_*.json
```

## Current Status

**v0.1** - Core functionality complete

- ✅ Command parsing with full grammar validation
- ✅ All clauses implemented (include, attach, expect, follow, insecure, etc.)
- ✅ Execution plan generation with verb defaults
- ✅ HTTP request execution with redirect handling
- ✅ Transparent compression (gzip, br)
- ✅ Session management (authenticate, session show/clear/use)
- ✅ Auto-apply sessions for matching hosts
- ✅ File downloads with automatic filename extraction
- ✅ Multipart form data support
- ✅ Response assertions (expect clause)
- ✅ Proper exit codes (0 success, 3 expect fail, 4 network, 5 grammar)
- ✅ Helpful error messages with suggestions
- ✅ Help and explain commands
- ✅ Interactive TUI mode
- ✅ JSON output formatting
- ✅ Stderr meta output with redaction

## Roadmap

- **v0.1** ✅ - Core functionality (current)
- **v0.2** - Watch mode with SSE and polling
- **v0.3** - JSONPath selection and filtering
- **v0.4** - Advanced retry and backoff strategies
- **v1.0** - Stability hardening and release candidates

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

MIT License - see [LICENSE](LICENSE) file for details.


----
cmd/req/main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/adammpkins/req/internal/grammar"
	"github.com/adammpkins/req/internal/output"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
	"github.com/adammpkins/req/internal/tui"
	"github.com/adammpkins/req/internal/types"
)

var (
	version   = "dev"
	commit    = "unknown"
	buildDate = "unknown"
)

func main() {
	var (
		showHelp    = flag.Bool("help", false, "Show help message")
		showVersion = flag.Bool("version", false, "Show version information")
		dryRun      = flag.Bool("dry-run", false, "Print execution plan without executing")
		tuiMode     = flag.Bool("tui", false, "Launch interactive TUI mode")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: req <verb> <target> [clauses...]\n\n")
		fmt.Fprintf(os.Stderr, "Verbs: read, save, send, upload, watch, inspect, authenticate, session\n\n")
		fmt.Fprintf(os.Stderr, "Examples:\n")
		fmt.Fprintf(os.Stderr, "  req read https://api.example.com/users as=json\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users using=PUT with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req save https://example.com/file.zip to=file.zip\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showHelp {
		flag.Usage()
		os.Exit(0)
	}

	if *showVersion {
		fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
		os.Exit(0)
	}

	// Launch TUI mode if requested
	if *tuiMode {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Get remaining args after flags
	args := flag.Args()

	// Remove any remaining flags from args (in case they appear after command args)
	filteredArgs := make([]string, 0, len(args))
	for _, arg := range args {
		if arg == "--help" || arg == "-help" || arg == "-h" {
			flag.Usage()
			os.Exit(0)
		}
		if arg == "--version" || arg == "-version" || arg == "-v" {
			fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
			os.Exit(0)
		}
		if arg == "--dry-run" || arg == "-dry-run" {
			*dryRun = true
			continue
		}
		filteredArgs = append(filteredArgs, arg)
	}
	args = filteredArgs

	// If no args provided, launch TUI mode
	if len(args) == 0 {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Handle help command
	if len(args) > 0 && args[0] == "help" {
		printHelp()
		os.Exit(0)
	}

	// Handle explain command
	if len(args) > 0 && args[0] == "explain" {
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Usage: req explain \"<command>\"\n")
			os.Exit(5)
		}
		command := strings.Join(args[1:], " ")
		if err := explainCommand(command); err != nil {
			printError(err)
			os.Exit(5)
		}
		os.Exit(0)
	}

	// Join args into a single command string
	command := strings.Join(args, " ")

	// Parse the command
	cmd, err := parser.Parse(command)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar error
	}

	// Handle session commands specially
	if cmd.Verb == types.VerbSession {
		if err := handleSessionCommand(cmd); err != nil {
			printError(err)
			os.Exit(5)
		}
		return
	}

	// Plan the execution
	plan, err := planner.Plan(cmd)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar/planning error
	}

	// Output the plan (dry-run mode)
	if *dryRun {
		formatted, err := output.FormatPlan(plan)
		if err != nil {
			printError(fmt.Errorf("failed to format plan: %w", err))
			os.Exit(5)
		}
		fmt.Println(string(formatted))
		return
	}

	// Execute the plan
	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		printError(fmt.Errorf("failed to create executor: %w", err))
		os.Exit(5) // Grammar error
	}

	if err := executor.Execute(plan); err != nil {
		printError(err)
		// Check error type for exit code
		if execErr, ok := err.(*runtime.ExecutionError); ok {
			os.Exit(execErr.Code)
		}
		os.Exit(4) // Network error (default)
	}
}

// printError prints an error with helpful diagnostics.
func printError(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v\n", err)

	// Check if it's a ParseError with suggestions
	if parseErr, ok := err.(*parser.ParseError); ok && parseErr.Suggest != "" {
		fmt.Fprintf(os.Stderr, "Hint: Try using '%s' instead\n", parseErr.Suggest)
	}
}

// printHelp prints the grammar summary.
func printHelp() {
	fmt.Print(grammar.FormatHelp())
}

// explainCommand prints the parsed plan for a command without executing it.
func explainCommand(command string) error {
	cmd, err := parser.Parse(command)
	if err != nil {
		return err
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		return err
	}

	formatted, err := output.FormatPlan(plan)
	if err != nil {
		return fmt.Errorf("failed to format plan: %w", err)
	}

	fmt.Println(string(formatted))
	return nil
}

// handleSessionCommand handles session management commands.
func handleSessionCommand(cmd *types.Command) error {
	host, err := session.ExtractHost(cmd.Target.URL)
	if err != nil {
		return fmt.Errorf("invalid host: %w", err)
	}

	switch cmd.SessionSubcommand {
	case "show":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			fmt.Printf("No session found for %s\n", host)
			return nil
		}

		// Check if JSON output requested
		asJSON := false
		for _, clause := range cmd.Clauses {
			if asClause, ok := clause.(types.AsClause); ok && asClause.Format == "json" {
				asJSON = true
				break
			}
		}

		if asJSON {
			// Machine-friendly JSON output
			data, err := json.MarshalIndent(sess, "", "  ")
			if err != nil {
				return fmt.Errorf("failed to marshal session: %w", err)
			}
			fmt.Println(string(data))
		} else {
			// Human-readable redacted output
			redacted := session.RedactSession(sess)
			fmt.Printf("Session for %s:\n", redacted.Host)
			if len(redacted.Cookies) > 0 {
				fmt.Println("Cookies:")
				for name := range redacted.Cookies {
					fmt.Printf("  %s: ***\n", name)
				}
			}
			if redacted.Authorization != "" {
				fmt.Printf("Authorization: %s\n", redacted.Authorization)
			}
		}
		return nil

	case "clear":
		if err := session.DeleteSession(host); err != nil {
			return fmt.Errorf("failed to delete session: %w", err)
		}
		fmt.Printf("Session cleared for %s\n", host)
		return nil

	case "use":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			return fmt.Errorf("no session found for %s", host)
		}
		// Print environment variable stub for shell scoping
		fmt.Printf("export REQ_SESSION_HOST=%s\n", host)
		return nil

	default:
		return fmt.Errorf("unknown session subcommand: %s", cmd.SessionSubcommand)
	}
}

----
docs/QUOTING.md
# Cross Shell Quoting Guide

This guide provides examples of how to properly quote `req` commands in different shells.

## General Rules

- Values containing semicolons (`;`) must be quoted
- Values containing spaces should be quoted
- Values containing special characters should be quoted
- Environment variables are expanded by the shell before being passed to `req`

## Bash / Zsh

### Single Quotes (Recommended)
Single quotes preserve everything literally:

```bash
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

### Double Quotes
Double quotes allow variable expansion:

```bash
TOKEN="abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

### Escaping
Use backslash to escape special characters:

```bash
req read https://api.example.com/search include='param: q=test\;value' as=json
```

## Fish Shell

Fish uses different quoting rules:

```fish
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in fish:

```fish
set TOKEN "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## PowerShell

PowerShell uses backticks for escaping:

```powershell
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in PowerShell:

```powershell
$TOKEN = "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## Common Patterns

### Include Clause with Multiple Items

```bash
# Bash/Zsh
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# Fish
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# PowerShell
req read https://api.example.com/search `
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' `
  as=json
```

### Expect Clause with Multiple Checks

```bash
req read https://api.example.com/users \
  expect='status:200, header:Content-Type=application/json, contains:"items"' \
  as=json
```

### Attach Clause with File Paths

```bash
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
  as=json
```

## Curl vs req Mapping

| curl command | req equivalent |
|-------------|----------------|
| `curl https://api.example.com/users` | `req read https://api.example.com/users` |
| `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"` |
| `curl -X POST -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users with='{"name":"Adam"}'` |
| `curl -X POST -F "file=@avatar.png" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png'` |
| `curl -b "session=abc123" https://api.example.com/users` | `req read https://api.example.com/users include='cookie: session=abc123'` |
| `curl -L https://example.com` | `req read https://example.com` (follows redirects by default) |
| `curl -k https://self-signed.example.com` | `req read https://self-signed.example.com insecure=true` |
| `curl --proxy http://proxy:8080 https://api.example.com` | `req read https://api.example.com via=http://proxy:8080` |
| `curl -X POST --data-binary @file.json https://api.example.com` | `req send https://api.example.com with=@file.json` |
| `curl -X POST --data @- https://api.example.com` | `echo '{"data":"value"}' \| req send https://api.example.com with=@-` |

## Tips

1. **Always quote include= values** - They often contain semicolons and spaces
2. **Use single quotes for JSON** - Prevents shell from interpreting special characters
3. **Use double quotes when you need variable expansion** - But be careful with nested quotes
4. **Test with `req explain`** - See how your command is parsed before executing:
   ```bash
   req explain "read https://api.example.com/users include='header: Authorization: Bearer token'"
   ```


----
final-attempt.txt
The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encountered. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
.cursor/rules/grammar.mdc
# .cursor/rules/grammar.mdc

# req grammar - v0.1 specification

This documents the language. It is a DSL that reads like a sentence and runs in a shell.

## Command shape

    req <verb> <url> [clauses...]

Clauses are key=value pairs where keys are semantic words, not config words.

Order of clauses is free.

Unknown clause keys are errors.

## Verbs

- read - GET, print to stdout
- save - GET, write to file via to=
- send - default GET, POST if with= present
- upload - POST when attach= or with= present, else error
- watch - GET with SSE or polling
- inspect - HEAD only
- authenticate - login and store session state
- session show, session clear, session use - session management

## Clauses

| Clause     | Meaning                                     | Repeatable | Example                                                                 |
|-----------|---------------------------------------------|------------|-------------------------------------------------------------------------|
| using=    | HTTP method override                         | no         | using=PUT                                                               |
| include=  | Add headers, params, cookies                 | yes        | include='header: Authorization: Bearer token; param: q=search query'     |
| with=     | Request body                                 | no         | with=@user.json or with='{"name":"Adam"}'                               |
| expect=   | Assertions on response                       | no         | expect=status:200, header:Content-Type=application/json, contains:"ok"  |
| as=       | Output format for stdout                     | no         | as=json                                                                 |
| to=       | Destination path                             | no         | to=out.json                                                             |
| retry=    | Retry attempts for transient errors          | no         | retry=3                                                                 |
| under=    | Timeout or size limit                        | no         | under=30s or under=10MB                                                 |
| via=      | Proxy URL                                    | no         | via=http://proxy:8080                                                   |
| attach=   | Multipart parts for upload or send           | yes        | attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'    |
| follow=   | Redirect policy for write verbs              | no         | follow=smart                                                            |
| insecure= | Disable TLS verification for this request    | no         | insecure=true                                                           |

### include= value grammar

- One include clause may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - header: Name: Value
  - param: key=value
  - cookie: key=value

Merging
- Headers: keep all values for multi valued headers, else last wins.
- Params: repeated keys become repeated pairs in insertion order.
- Cookies: last value wins per cookie name.

Quoting
- If an item payload contains a semicolon, quote the value.
- Backslash escapes allowed inside quoted values for the quote char and backslash.

Errors
- Unknown tag before the first colon.
- Header without Name colon Value.
- Param or cookie missing equals.
- Unquoted semicolon inside an item payload.

Examples

    include='header: Accept: application/json, application/problem+json; q=0.9'
    include='param: q=search query; param: tag=ai; param: tag=ml'
    include='cookie: session=abc; cookie: prefs="a=1; b=2"'

### attach= value grammar

- One attach may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - part: name=..., file=@path  or  part: name=..., value=...
  - Optional filename=...
  - Optional type=media/type
  - boundary: TOKEN optional

Validation
- name is required.
- exactly one of file or value is required.
- for file parts, @path must exist at execution time.

Header behavior
- Any attach= forces multipart Content-Type with a generated boundary.
- If user included a manual Content-Type, override it and print a one line note.

Examples

    attach='part: name=avatar, file=@./me.png, filename=me.png, type=image/png'
    attach='part: name=meta, value={"name":"adam"}'
    attach='part: name=file, file=@./a.png; part: name=meta, value=xyz'

### with= body modes

- Inline text or JSON.
- @file to read from file.
- @- to read from stdin.

Content type
- If Content-Type is not set and inline begins with "{" or "[", infer application/json and note on stderr.
- An explicit Content-Type header always overrides inference.

### expect= assertions

Single clause with comma separated checks. All must pass.

Supported checks
- status:200
- header:Content-Type=application/json
- contains:"text"
- jsonpath:"$.items[0].id"
- matches:"^OK\\b"

Exit codes
- 0 success and expectations passed.
- 3 request ok but an expectation failed.

Failure messages must be concise and specific.

### Redirects

- read and save follow up to 5 redirects by default.
- write verbs do not follow by default.
- follow=smart for writes follows only 307 and 308, up to 5 hops.
- On 301, 302, 303 for writes, do not follow and print an advisory.

### Compression

- If user did not set Accept-Encoding, send "Accept-Encoding: gzip, br".
- Auto decompress gzip or br before as= and expect=.
- Print a one line note when decompression occurs.

### TLS

- insecure=true disables certificate verification for this request only.
- Print one line warning on stderr.

### Sessions

authenticate
- Follows redirects.
- Captures Set-Cookie.
- If response is JSON with a top level access_token, store it as a Bearer token.
- Store per host under user state dir with strict perms.

Auto use
- Any request to a host with a stored session auto applies cookies and Authorization unless caller includes those explicitly.
- Print "Using session for <host>" when applied.

session verbs
- session show <host> prints redacted info. as=json prints machine friendly form.
- session clear <host> deletes state.
- session use <host> prints env stub for shell scoping.

### Method defaults

- read GET
- save GET
- send GET by default, POST if with= present
- upload POST when attach= present, else POST if with= present, else error
- watch GET
- inspect HEAD
- authenticate POST if with= present, else require using=

### Multiplicity and ordering

- Singletons: using, with, expect, as, to, retry, under, via, insecure, follow.
- Repeatable: include, attach.
- Clause order is free.
- Explicit include of Authorization or Cookie overrides session.

### Token and quoting model

- Parser consumes argv tokens as provided by the shell.
- Do not re split on spaces.
- Values containing semicolons must be quoted.
- Backslash escapes allowed inside quotes for the quote char and backslash.
- Environment variables are expanded by the shell before argv.

### Errors that must be loud and specific

- Unknown clause key.
- Duplicate singletons.
- include item with unknown tag or malformed payload.
- header item missing Name colon Value.
- param or cookie missing equals.
- unquoted semicolon in an item payload.
- attach part missing name, or missing both file and value, or providing both.
- URL parse failure.
- file path not found for with or attach.
- timeout or size limit exceeded.
- TLS error when insecure=false.

### Error message examples

Each error class must produce a specific, actionable message. Examples:

Unknown clause key

    $ req read https://example.com invalid=clause
    Error: parse error at position 2 (token: "invalid"): unknown clause

Duplicate singleton

    $ req read https://example.com with=test with=test2
    Error: parse error at position 3 (token: "with"): duplicate singleton clause 'with' (did you mean "remove duplicate 'with=' clause"?)

Unquoted semicolon in include

    $ req read https://example.com include='param: q=test;value'
    Error: parse error at position 2 (token: "include"): unquoted semicolon in include item

Malformed header (missing Name: Value)

    $ req read https://example.com include='header: InvalidHeader'
    Error: parse error at position 2 (token: "include"): header item missing Name: Value format

Missing equals in param or cookie

    $ req read https://example.com include='param: q'
    Error: parse error at position 2 (token: "include"): param missing equals

Attach part missing name

    $ req upload https://example.com attach='part: file=@test.png'
    Error: parse error at position 2 (token: "attach"): attach part missing name

Attach part with both file and value

    $ req upload https://example.com attach='part: name=test, file=@test.png, value=text'
    Error: parse error at position 2 (token: "attach"): attach part cannot have both file and value

File not found for with

    $ req send https://example.com with=@nonexistent.json
    Error: file not found: nonexistent.json

File not found for attach

    $ req upload https://example.com attach='part: name=file, file=@nonexistent.png'
    Error: file not found: nonexistent.png

### Output contracts

stdout
- Response body, formatted per as=.
- For save, write to file and keep stdout empty unless a specific mode says otherwise.

stderr
- Compact meta block: status, url, duration, bytes, content type.
- Notices: session use, decompression, redirect trace, TLS warning, multipart override note.
- Secrets redacted in meta lines.

### End to end examples

Read with params and header

    req read https://api.example.com/search \
      include='param: q=search query; header: X-Trace: 1' \
      as=json

Write JSON with auth and assertion

    req send https://api.example.com/users \
      using=POST \
      include='header: Authorization: Bearer $TOKEN' \
      with='{"name":"Adam"}' \
      expect=status:201, header:Content-Type=application/json \
      as=json

Multipart upload

    req upload https://api.example.com/upload \
      attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
      as=json

Authenticate then use session

    req authenticate https://api.example.com/login \
      using=POST \
      with='{"user":"adam","pass":"xyz"}'

    req read https://api.example.com/me as=json

Write with safe redirects

    req send https://api.example.com/endpoint \
      using=POST \
      with='{"a":1}' \
      follow=smart \
      expect=status:200

----
.cursor/rules/plan.mdc
---
alwaysApply: true
---
# /.cursor/plan.md

# req project plan - v0.1 to 90 percent curl coverage

This is a strict, test-driven plan. Each task has acceptance criteria. No code here. Use these goals as Cursor prompts.

## 1) Lock the surface grammar
- Enforce command shape: `req <verb> <url> [clauses...]`
- Allowed verbs: read, save, send, upload, watch, inspect, authenticate, session (show|clear|use)
- Allowed clauses: using=, include=, with=, expect=, as=, to=, retry=, under=, via=, attach=, follow=smart, insecure=true
- Clause order independent

Acceptance
- Unknown clause keys hard error with nearest suggestion
- Duplicate singletons hard error with fix hint
- Golden tests for valid and invalid examples
- `req help` prints the grammar summary

## 2) include= value grammar
Goal
- Implement semicolon separated items with explicit tags

Do
- Items: `header: Name: Value`, `param: key=value`, `cookie: key=value`
- Values may be quoted
- Multiple include= clauses allowed

Merging rules
- Headers: keep all for multi valued headers, else last wins
- Params: repeated keys become repeated pairs in order
- Cookies: last value wins

Acceptance
- Unit tests for quoting, embedded semicolons, repeated keys, error cases
- Golden tests for combined include payloads

## 3) attach= multipart grammar
Goal
- Repeatable clause for multipart form data

Do
- Items: `part: ...` and `boundary: ...`
- Part kvs: `name=`, one of `file=@path` or `value=`, optional `filename=`, optional `type=media/type`
- Validate name required, exactly one of file or value
- Any attach= forces `Content-Type: multipart/form-data; boundary=...`
- If user set Content-Type manually, override and print a one line note

Acceptance
- Unit tests for file, text, mixed parts, explicit boundary, malformed descriptors
- Integration test uses echo server to assert parts

## 4) follow=smart and insecure=true
Goal
- Add redirect and TLS toggles

Do
- follow accepts only `smart`
- insecure accepts `true` or `false`

Acceptance
- Unit tests parse both correctly and reject bad values

## 5) with= body modes and light inference
Goal
- Support inline, @file, @-

Do
- If Content-Type is not set and inline begins with `{` or `[`, infer `application/json` and log a one line note on stderr
- Explicit header always overrides inference

Acceptance
- Tests for inference, override, and no inference on file

## 6) expect= assertions
Goal
- Single clause with comma separated checks

Checks
- `status:200`
- `header:Content-Type=application/json`
- `contains:"text"`
- `jsonpath:"$.items[0].id"`
- `matches:"^OK\\b"`

Acceptance
- Exit 3 on any failure, with a concise diff-like message
- Tests for pass and fail cases

## 7) Verb defaults and method validation
Goal
- Map verbs to default methods and validate using=

Defaults
- read GET
- save GET
- send GET by default, POST if with= present
- upload POST if attach= or with= present, else error
- watch GET
- inspect HEAD
- authenticate default POST if with= present

Acceptance
- Tests for defaults and invalid combinations

## 8) Redirect policy
Goal
- Implement safe redirect rules

Rules
- read and save follow up to 5 by default
- write verbs do not follow by default
- follow=smart follows only 307 and 308 for writes, up to 5
- On 301, 302, 303 for writes, do not follow, print advisory

Acceptance
- Integration tests for 301, 302, 303, 307, 308 with and without smart
- Stderr shows compact trace

## 9) Transparent compression
Goal
- gzip and br on by default

Do
- Inject Accept-Encoding unless user set it
- Auto decompress before as= and expect=
- One line stderr note when decompressed

Acceptance
- gz and br tests, expect sees decoded text, user header respected

## 10) TLS control
Goal
- Implement insecure=true

Acceptance
- Self signed server fails normally, succeeds with insecure=true
- One line stderr warning: TLS verification disabled

## 11) Query param merging and URL assembly
Goal
- Merge URL params with include param items

Acceptance
- Repeated keys serialize in insertion order
- Proper percent encoding
- Existing URL params preserved and merged

## 12) Output control with as= and to=
Goal
- Finalize sinks and formatting

Do
- as=json, text, raw, csv
- to=PATH writes file. For save, derive filename from URL if needed
- stdout is body, stderr is compact meta with redaction

Acceptance
- Filename extraction, directory handling, percent decoding, meta block content

## 13) Sessions and authenticate
Goal
- Explicit session model

Do
- authenticate captures Set-Cookie and `access_token` from JSON
- Store per host in user state dir with strict perms
- Auto apply for matching host unless caller includes Authorization or Cookie
- Print `Using session for <host>` on use
- session show, session clear, session use implemented

Acceptance
- Integration tests for login, reuse, override, redaction, permission refusal

## 14) Multipart body construction
Goal
- Build body with generated boundary and proper part headers

Acceptance
- Echo server validates Content-Disposition, Content-Type, filenames and order
- Manual Content-Type overridden with a note

## 15) Errors, hints, exit codes
Goal
- Clear, specific failures

Acceptance
- Exit codes: 0 ok, 3 expect fail, 4 network, 5 grammar
- Hints for unquoted semicolons, missing equals, duplicate singletons, unknown clause, bad attach part

## 16) Help and explain
Goal
- Discoverability tools

Do
- `req help` prints grammar table and examples
- `req explain "<command>"` prints parsed plan without executing

Acceptance
- Golden tests for explain output

## 17) Cross shell quoting doc
Goal
- Portability guidance

Do
- Quoting cheat sheet for bash, zsh, fish, PowerShell
- Curl vs req mapping table for common tasks

Acceptance
- Docs included and examples parse in a simple parser smoke test

## 18) CI, golden, fixtures
Goal
- Stable test harness

Do
- Golden tests for parser and explain
- Local HTTP fixture: echo headers, cookies, query, gzip, br, 30x, multipart
- Run under race detector

Acceptance
- CI green across Go versions you support

## 19) Streaming and watch polish
Goal
- Memory efficient downloads and sensible watch output

Do
- Stream to file for save
- Watch prints timestamps on TTY, raw otherwise

Acceptance
- Large download uses low memory
- Watch behaves per TTY detection

## 20) README refresh
Goal
- Align docs with grammar

Do
- Replace stale examples with include, attach, expect forms
- Document redirect defaults and smart policy
- Add warning about insecure=true and shell history

Acceptance
- Doc snippets pass as golden examples

----
.github/ISSUE_TEMPLATE/bug_report.md
---
name: Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Description

A clear and concise description of what the bug is.

## Reproduction

**Command:**
```bash
req <your-command-here>
```

**Expected Output:**
```
<expected-output>
```

**Actual Output:**
```
<actual-output>
```

## Environment

- OS: [e.g., Linux, macOS, Windows]
- Architecture: [e.g., amd64, arm64]
- Version: [e.g., v0.1.0]
- Go version: [e.g., 1.23]

## Additional Context

Add any other context about the problem here, including:
- Error messages
- Stack traces (if applicable)
- Workarounds you've tried


----
.github/ISSUE_TEMPLATE/feature_request.md
---
name: Feature Request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Summary

A clear and concise description of the feature you'd like to see.

## Motivation

Why is this feature needed? What problem does it solve?

## Detailed Description

Describe the feature in detail:
- What should the command syntax look like?
- What should the output look like?
- Are there any edge cases to consider?

## Example Usage

```bash
req <example-command>
```

## Alternatives Considered

Describe any alternative solutions or features you've considered.

## Additional Context

Add any other context, mockups, or examples about the feature request here.


----
.github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Run tests with race detector
        run: make test
      
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          make vulncheck
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m
  
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-${{ matrix.os }}
          path: bin/req
  
  windows:
    name: Windows Build
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-windows
          path: bin/req.exe

  grammar-drift:
    name: Grammar Drift Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build binary
        run: make build
      
      - name: Run grammar drift tests
        run: go test -v ./tests -run 'TestGrammarDrift|TestBinaryHelpDrift'


----
.gitignore
# Binaries
bin/
req
req.exe

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
*.tar.gz
*.zip


----
.golangci.yml
# golangci-lint configuration with lean modern linter set
run:
  timeout: 5m
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  gocritic:
    enabled-tags:
      - diagnostic
  govet:
    check-shadowing: true
  misspell:
    locale: US
  nolintlint:
    allow-leading-space: true
    allow-unused: false
    require-explanation: false
    require-specific: false

linters:
  disable-all: true
  enable:
    - errcheck
    - gocritic
    - goimports
    - gosimple
    - govet
    - ineffassign
    - misspell
    - nolintlint
    - staticcheck

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
  max-issues-per-linter: 0
  max-same-issues: 0

----
.goreleaser.yml
# GoReleaser configuration for cross-platform releases
project_name: req

before:
  hooks:
    - go mod download

builds:
  - id: req
    main: ./cmd/req
    binary: req
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    goarm:
      - 6
      - 7
    ignore:
      - goos: windows
        goarch: arm64
    env:
      - CGO_ENABLED=0
    flags:
      - -trimpath
      - -ldflags=-s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.buildDate={{.Date}}

archives:
  - id: default
    builds:
      - req
    format_overrides:
      - goos: windows
        format: zip
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    files:
      - LICENSE
      - README.md

checksum:
  name_template: "{{ .ProjectName }}_{{ .Version }}_checksums.txt"

snapshot:
  name_template: "{{ .Tag }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"


----
LICENSE
MIT License

Copyright (c) 2025 Adam Perkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


----
Makefile
.PHONY: build test lint package golden clean help

# Variables
BINARY_NAME=req
MAIN_PATH=./cmd/req
VERSION?=dev
BUILD_DIR=./bin
COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build the req binary
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
ifeq ($(GOOS),windows)
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME).exe $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME).exe"
else
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"
endif

test: ## Run tests with race detector
	@echo "Running tests..."
	@go test -race -cover -v ./...

test-golden: ## Run golden file tests
	@echo "Running golden tests..."
	@go test -v ./tests -run TestGolden

golden: ## Regenerate golden test files
	@echo "Regenerating golden files..."
	@go test ./tests -run TestGolden -update

lint: ## Run golangci-lint
	@echo "Running golangci-lint..."
	@golangci-lint run

lint-fix: ## Run golangci-lint with auto-fix
	@golangci-lint run --fix

vulncheck: ## Run govulncheck
	@echo "Running govulncheck..."
	@govulncheck ./...

package: ## Build release artifacts locally (requires goreleaser)
	@echo "Building release artifacts..."
	@goreleaser build --snapshot --clean

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@go clean -cache

install: build ## Install binary to GOPATH/bin
	@go install $(MAIN_PATH)


----
README.md
# req

A semantic HTTP client written in Go that replaces traditional curl syntax with a natural, intent-based grammar.

## Overview

`req` is an HTTP client tool that focuses on:

- **Human-readable commands** (verbs + clauses)
- **Sensible defaults** (follow redirects, TLS verify, retries)
- **JSON/CSV/text awareness** with intelligent output
- **Watch mode** (poll or stream)
- **Session management** (authenticate and auto-apply)
- **Pretty diagnostics** and dry-run transparency

## Quick Start

```bash
# Read JSON from an API
req read https://api.example.com/users as=json

# Send JSON data
req send https://api.example.com/users with='{"name":"Adam"}'

# Send with headers and assertions
req send https://api.example.com/users \
  using=POST \
  include='header: Authorization: Bearer $TOKEN' \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json \
  as=json

# Save a file
req save https://example.com/file.zip to=file.zip

# Upload multipart form data
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png' \
  as=json

# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Use stored session automatically
req read https://api.example.com/me as=json
```

## Installation

```bash
go install github.com/adammpkins/req/cmd/req@latest
```

Or download a pre-built binary from the [Releases](https://github.com/adammpkins/req/releases) page.

## Grammar

The `req` command follows this grammar:

```
req <verb> <target> [clauses...]
```

### Verbs

- `read` - GET, print to stdout
- `save` - GET, write to file via to=
- `send` - default GET, POST if `with=` is present
- `upload` - POST when `attach=` or `with=` present, else error
- `watch` - GET with SSE or polling
- `inspect` - HEAD only
- `authenticate` - login and store session state
- `session` - session management (show, clear, use)

### Clauses

- `using=<method>` - HTTP method override
- `include=<items>` - Add headers, params, cookies (repeatable)
  - Format: `include='header: Name: Value; param: key=value; cookie: key=value'`
- `with=<body>` - Request body
  - Format: `with=@user.json` or `with='{"name":"Adam"}'`
  - JSON inference: Automatically sets Content-Type for JSON when inline starts with `{` or `[`
- `expect=<checks>` - Assertions on response
  - Format: `expect=status:200, header:Content-Type=application/json, contains:"ok"`
- `as=<format>` - Output format for stdout
- `to=<path>` - Destination path
- `retry=<count>` - Retry attempts for transient errors
- `under=<limit>` - Timeout or size limit
  - Format: `under=30s` or `under=10MB`
- `via=<url>` - Proxy URL
- `attach=<parts>` - Multipart parts for upload or send (repeatable)
  - Format: `attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'`
- `follow=<policy>` - Redirect policy for write verbs
  - Format: `follow=smart`
- `insecure=<bool>` - Disable TLS verification for this request
  - Format: `insecure=true`

## Examples

### Read JSON

```bash
req read https://api.example.com/users as=json
```

### Send JSON Data

```bash
req send https://api.example.com/users with='{"name":"Ada","email":"ada@example.com"}'
```

### Save a File

```bash
# Save with explicit filename
req save https://example.com/file.zip to=file.zip

# Save with auto-detected filename (extracts from URL)
req save https://example.com/file.zip

# Save to directory path
req save https://example.com/file.zip to=/tmp/file.zip
```

### With Headers, Params, and Cookies

```bash
# Using include clause
req read https://api.example.com/search \
  include='header: Authorization: Bearer $TOKEN; param: q=search query; cookie: session=abc123' \
  as=json
```

### With Assertions

```bash
req send https://api.example.com/users \
  using=POST \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json, contains:"id" \
  as=json
```

### Sessions

```bash
# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Session is automatically used for subsequent requests
req read https://api.example.com/me as=json

# Show stored session (redacted)
req session show api.example.com

# Show session in JSON format
req session show api.example.com as=json

# Clear session
req session clear api.example.com
```

### Redirects

```bash
# Read and save follow redirects by default (up to 5)
req read https://example.com/redirect

# Write verbs don't follow by default
req send https://api.example.com/create using=POST with='{"data":"value"}'

# Use smart follow for write verbs (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
```

### With Retry and Timeout

```bash
req read https://api.example.com/users retry=3 under=10s as=json
```

### Edge Cases

```bash
# Header with commas and q values (must be quoted)
req read https://api.example.com/search \
  include='header: Accept: application/json, application/problem+json; q=0.9' \
  as=json

# Cookie value containing semicolons (must be quoted)
req read https://api.example.com/search \
  include='cookie: prefs="a=1; b=2; c=3"' \
  as=json

# Multipart upload with file and text parts (Content-Type automatically overridden)
req upload https://api.example.com/upload \
  include='header: Content-Type: application/json' \
  attach='part: name=file, file=@avatar.png; part: name=meta, value={"name":"test"}' \
  as=json
# Note: Content-Type will be overridden to multipart/form-data

# Smart redirect on write verb (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
# Will follow 307/308 redirects, but not 301/302/303

# Write verb with 303 redirect (advisory printed, not followed)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}'
# If server returns 303, advisory message printed but redirect not followed
```

### Method Override

```bash
# Use PUT instead of POST
req send https://api.example.com/users/1 using=PUT with='{"name":"Updated"}'

# Use PATCH for partial updates
req send https://api.example.com/users/1 using=PATCH with='{"email":"new@example.com"}'

# Use HEAD to check headers without body
req read https://api.example.com/users using=HEAD
```

**Note:** The `using=` clause validates method-verb compatibility. For example, `read using=POST` will fail as `read` only allows GET, HEAD, or OPTIONS.

### Comparison with curl

| Task | curl | req |
|------|------|-----|
| **Basic GET with headers** | `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include='header: Authorization: Bearer $TOKEN'` |
| **Multipart upload** | `curl -F "file=@avatar.png" -F "name=test" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png; part: name=name, value=test'` |
| **Authenticated POST** | `curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users using=POST include='header: Authorization: Bearer $TOKEN' with='{"name":"Adam"}'` |

### Dry Run

```bash
req read https://api.example.com/users as=json --dry-run
```

### Interactive TUI Mode

```bash
# Launch interactive TUI mode
req --tui

# Or run without arguments to launch TUI
req
```

The TUI mode provides:
- Interactive command builder with form-based input
- **Syntax-highlighted JSON output** with color-coded keys, values, and punctuation
- **Scrollable viewport** for long responses with keyboard navigation
- Pretty-printed JSON with automatic indentation
- Real-time command execution and response display

**Keyboard Controls:**
- `↑` / `↓` or `k` / `j` - Scroll line by line
- `pgup` / `pgdown` - Page scrolling
- `home` - Jump to top
- `end` - Jump to bottom
- `ctrl+u` / `ctrl+d` - Half-page scrolling
- `esc` - Quit TUI

## Security

### Shell History

**Warning:** Commands containing secrets (tokens, passwords) are stored in your shell history by default. Use environment variables to avoid exposing secrets:

```bash
# Bad: Token appears in shell history
req read https://api.example.com/users include='header: Authorization: Bearer secret-token-123'

# Good: Use environment variable
TOKEN="secret-token-123"
req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"
```

To prevent secrets from being saved to history:
- **Bash/Zsh:** Prefix command with a space (requires `HISTCONTROL=ignorespace` or `setopt HIST_IGNORE_SPACE`)
- **Fish:** Use `history --delete` after running commands with secrets
- **PowerShell:** Use `Set-PSReadlineOption -HistoryNoDuplicates` and manually edit history

### Session Files

Session files are stored in `~/.config/req/session_<host>.json` with permissions `0600` (owner read/write only).

**Security rules:**
- Session files are created with strict permissions (`0600`)
- If a session file has group or world readable permissions, `req` will refuse to load it
- Session files contain sensitive data (cookies, tokens) and should be protected
- Never commit session files to version control

To check session file permissions:
```bash
ls -l ~/.config/req/session_*.json
```

## Current Status

**v0.1** - Core functionality complete

- ✅ Command parsing with full grammar validation
- ✅ All clauses implemented (include, attach, expect, follow, insecure, etc.)
- ✅ Execution plan generation with verb defaults
- ✅ HTTP request execution with redirect handling
- ✅ Transparent compression (gzip, br)
- ✅ Session management (authenticate, session show/clear/use)
- ✅ Auto-apply sessions for matching hosts
- ✅ File downloads with automatic filename extraction
- ✅ Multipart form data support
- ✅ Response assertions (expect clause)
- ✅ Proper exit codes (0 success, 3 expect fail, 4 network, 5 grammar)
- ✅ Helpful error messages with suggestions
- ✅ Help and explain commands
- ✅ Interactive TUI mode
- ✅ JSON output formatting
- ✅ Stderr meta output with redaction

## Roadmap

- **v0.1** ✅ - Core functionality (current)
- **v0.2** - Watch mode with SSE and polling
- **v0.3** - JSONPath selection and filtering
- **v0.4** - Advanced retry and backoff strategies
- **v1.0** - Stability hardening and release candidates

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

MIT License - see [LICENSE](LICENSE) file for details.


----
cmd/req/main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/adammpkins/req/internal/grammar"
	"github.com/adammpkins/req/internal/output"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
	"github.com/adammpkins/req/internal/tui"
	"github.com/adammpkins/req/internal/types"
)

var (
	version   = "dev"
	commit    = "unknown"
	buildDate = "unknown"
)

func main() {
	var (
		showHelp    = flag.Bool("help", false, "Show help message")
		showVersion = flag.Bool("version", false, "Show version information")
		dryRun      = flag.Bool("dry-run", false, "Print execution plan without executing")
		tuiMode     = flag.Bool("tui", false, "Launch interactive TUI mode")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: req <verb> <target> [clauses...]\n\n")
		fmt.Fprintf(os.Stderr, "Verbs: read, save, send, upload, watch, inspect, authenticate, session\n\n")
		fmt.Fprintf(os.Stderr, "Examples:\n")
		fmt.Fprintf(os.Stderr, "  req read https://api.example.com/users as=json\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users using=PUT with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req save https://example.com/file.zip to=file.zip\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showHelp {
		flag.Usage()
		os.Exit(0)
	}

	if *showVersion {
		fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
		os.Exit(0)
	}

	// Launch TUI mode if requested
	if *tuiMode {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Get remaining args after flags
	args := flag.Args()

	// Remove any remaining flags from args (in case they appear after command args)
	filteredArgs := make([]string, 0, len(args))
	for _, arg := range args {
		if arg == "--help" || arg == "-help" || arg == "-h" {
			flag.Usage()
			os.Exit(0)
		}
		if arg == "--version" || arg == "-version" || arg == "-v" {
			fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
			os.Exit(0)
		}
		if arg == "--dry-run" || arg == "-dry-run" {
			*dryRun = true
			continue
		}
		filteredArgs = append(filteredArgs, arg)
	}
	args = filteredArgs

	// If no args provided, launch TUI mode
	if len(args) == 0 {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Handle help command
	if len(args) > 0 && args[0] == "help" {
		printHelp()
		os.Exit(0)
	}

	// Handle explain command
	if len(args) > 0 && args[0] == "explain" {
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Usage: req explain \"<command>\"\n")
			os.Exit(5)
		}
		command := strings.Join(args[1:], " ")
		if err := explainCommand(command); err != nil {
			printError(err)
			os.Exit(5)
		}
		os.Exit(0)
	}

	// Join args into a single command string
	command := strings.Join(args, " ")

	// Parse the command
	cmd, err := parser.Parse(command)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar error
	}

	// Handle session commands specially
	if cmd.Verb == types.VerbSession {
		if err := handleSessionCommand(cmd); err != nil {
			printError(err)
			os.Exit(5)
		}
		return
	}

	// Plan the execution
	plan, err := planner.Plan(cmd)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar/planning error
	}

	// Output the plan (dry-run mode)
	if *dryRun {
		formatted, err := output.FormatPlan(plan)
		if err != nil {
			printError(fmt.Errorf("failed to format plan: %w", err))
			os.Exit(5)
		}
		fmt.Println(string(formatted))
		return
	}

	// Execute the plan
	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		printError(fmt.Errorf("failed to create executor: %w", err))
		os.Exit(5) // Grammar error
	}

	if err := executor.Execute(plan); err != nil {
		printError(err)
		// Check error type for exit code
		if execErr, ok := err.(*runtime.ExecutionError); ok {
			os.Exit(execErr.Code)
		}
		os.Exit(4) // Network error (default)
	}
}

// printError prints an error with helpful diagnostics.
func printError(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v\n", err)

	// Check if it's a ParseError with suggestions
	if parseErr, ok := err.(*parser.ParseError); ok && parseErr.Suggest != "" {
		fmt.Fprintf(os.Stderr, "Hint: Try using '%s' instead\n", parseErr.Suggest)
	}
}

// printHelp prints the grammar summary.
func printHelp() {
	fmt.Print(grammar.FormatHelp())
}

// explainCommand prints the parsed plan for a command without executing it.
func explainCommand(command string) error {
	cmd, err := parser.Parse(command)
	if err != nil {
		return err
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		return err
	}

	formatted, err := output.FormatPlan(plan)
	if err != nil {
		return fmt.Errorf("failed to format plan: %w", err)
	}

	fmt.Println(string(formatted))
	return nil
}

// handleSessionCommand handles session management commands.
func handleSessionCommand(cmd *types.Command) error {
	host, err := session.ExtractHost(cmd.Target.URL)
	if err != nil {
		return fmt.Errorf("invalid host: %w", err)
	}

	switch cmd.SessionSubcommand {
	case "show":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			fmt.Printf("No session found for %s\n", host)
			return nil
		}

		// Check if JSON output requested
		asJSON := false
		for _, clause := range cmd.Clauses {
			if asClause, ok := clause.(types.AsClause); ok && asClause.Format == "json" {
				asJSON = true
				break
			}
		}

		if asJSON {
			// Machine-friendly JSON output
			data, err := json.MarshalIndent(sess, "", "  ")
			if err != nil {
				return fmt.Errorf("failed to marshal session: %w", err)
			}
			fmt.Println(string(data))
		} else {
			// Human-readable redacted output
			redacted := session.RedactSession(sess)
			fmt.Printf("Session for %s:\n", redacted.Host)
			if len(redacted.Cookies) > 0 {
				fmt.Println("Cookies:")
				for name := range redacted.Cookies {
					fmt.Printf("  %s: ***\n", name)
				}
			}
			if redacted.Authorization != "" {
				fmt.Printf("Authorization: %s\n", redacted.Authorization)
			}
		}
		return nil

	case "clear":
		if err := session.DeleteSession(host); err != nil {
			return fmt.Errorf("failed to delete session: %w", err)
		}
		fmt.Printf("Session cleared for %s\n", host)
		return nil

	case "use":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			return fmt.Errorf("no session found for %s", host)
		}
		// Print environment variable stub for shell scoping
		fmt.Printf("export REQ_SESSION_HOST=%s\n", host)
		return nil

	default:
		return fmt.Errorf("unknown session subcommand: %s", cmd.SessionSubcommand)
	}
}

----
docs/QUOTING.md
# Cross Shell Quoting Guide

This guide provides examples of how to properly quote `req` commands in different shells.

## General Rules

- Values containing semicolons (`;`) must be quoted
- Values containing spaces should be quoted
- Values containing special characters should be quoted
- Environment variables are expanded by the shell before being passed to `req`

## Bash / Zsh

### Single Quotes (Recommended)
Single quotes preserve everything literally:

```bash
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

### Double Quotes
Double quotes allow variable expansion:

```bash
TOKEN="abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

### Escaping
Use backslash to escape special characters:

```bash
req read https://api.example.com/search include='param: q=test\;value' as=json
```

## Fish Shell

Fish uses different quoting rules:

```fish
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in fish:

```fish
set TOKEN "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## PowerShell

PowerShell uses backticks for escaping:

```powershell
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in PowerShell:

```powershell
$TOKEN = "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## Common Patterns

### Include Clause with Multiple Items

```bash
# Bash/Zsh
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# Fish
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# PowerShell
req read https://api.example.com/search `
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' `
  as=json
```

### Expect Clause with Multiple Checks

```bash
req read https://api.example.com/users \
  expect='status:200, header:Content-Type=application/json, contains:"items"' \
  as=json
```

### Attach Clause with File Paths

```bash
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
  as=json
```

## Curl vs req Mapping

| curl command | req equivalent |
|-------------|----------------|
| `curl https://api.example.com/users` | `req read https://api.example.com/users` |
| `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"` |
| `curl -X POST -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users with='{"name":"Adam"}'` |
| `curl -X POST -F "file=@avatar.png" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png'` |
| `curl -b "session=abc123" https://api.example.com/users` | `req read https://api.example.com/users include='cookie: session=abc123'` |
| `curl -L https://example.com` | `req read https://example.com` (follows redirects by default) |
| `curl -k https://self-signed.example.com` | `req read https://self-signed.example.com insecure=true` |
| `curl --proxy http://proxy:8080 https://api.example.com` | `req read https://api.example.com via=http://proxy:8080` |
| `curl -X POST --data-binary @file.json https://api.example.com` | `req send https://api.example.com with=@file.json` |
| `curl -X POST --data @- https://api.example.com` | `echo '{"data":"value"}' \| req send https://api.example.com with=@-` |

## Tips

1. **Always quote include= values** - They often contain semicolons and spaces
2. **Use single quotes for JSON** - Prevents shell from interpreting special characters
3. **Use double quotes when you need variable expansion** - But be careful with nested quotes
4. **Test with `req explain`** - See how your command is parsed before executing:
   ```bash
   req explain "read https://api.example.com/users include='header: Authorization: Bearer token'"
   ```


----
go.mod
module github.com/adammpkins/req

go 1.24.0

toolchain go1.24.10

require (
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
)

require (
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

----
go.sum
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=

----
internal/grammar/grammar.go
// Package grammar defines the structured grammar data for req commands.
package grammar

import "fmt"

// Verb represents a req command verb.
type Verb struct {
	Name        string
	Description string
}

// Clause represents a req command clause.
type Clause struct {
	Name        string
	Description string
	Repeatable  bool
	Example     string
}

// Grammar contains the complete grammar definition.
type Grammar struct {
	Verbs   []Verb
	Clauses []Clause
}

// GetGrammar returns the canonical grammar definition.
func GetGrammar() Grammar {
	return Grammar{
		Verbs: []Verb{
			{Name: "read", Description: "GET, print to stdout"},
			{Name: "save", Description: "GET, write to file via to="},
			{Name: "send", Description: "default GET, POST if with= present"},
			{Name: "upload", Description: "POST when attach= or with= present, else error"},
			{Name: "watch", Description: "GET with SSE or polling"},
			{Name: "inspect", Description: "HEAD only"},
			{Name: "authenticate", Description: "login and store session state"},
			{Name: "session", Description: "session management (show, clear, use)"},
		},
		Clauses: []Clause{
			{Name: "using=", Description: "HTTP method override", Repeatable: false, Example: "using=PUT"},
			{Name: "include=", Description: "Add headers, params, cookies", Repeatable: true, Example: "include='header: Authorization: Bearer token; param: q=search query'"},
			{Name: "with=", Description: "Request body", Repeatable: false, Example: "with=@user.json or with='{\"name\":\"Adam\"}'"},
			{Name: "expect=", Description: "Assertions on response", Repeatable: false, Example: "expect=status:200, header:Content-Type=application/json, contains:\"ok\""},
			{Name: "as=", Description: "Output format for stdout", Repeatable: false, Example: "as=json"},
			{Name: "to=", Description: "Destination path", Repeatable: false, Example: "to=out.json"},
			{Name: "retry=", Description: "Retry attempts for transient errors", Repeatable: false, Example: "retry=3"},
			{Name: "under=", Description: "Timeout or size limit", Repeatable: false, Example: "under=30s or under=10MB"},
			{Name: "via=", Description: "Proxy URL", Repeatable: false, Example: "via=http://proxy:8080"},
			{Name: "attach=", Description: "Multipart parts for upload or send", Repeatable: true, Example: "attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'"},
			{Name: "follow=", Description: "Redirect policy for write verbs", Repeatable: false, Example: "follow=smart"},
			{Name: "insecure=", Description: "Disable TLS verification for this request", Repeatable: false, Example: "insecure=true"},
		},
	}
}

// FormatHelp formats the grammar as help text.
func FormatHelp() string {
	g := GetGrammar()
	
	var help string
	help += "req - HTTP client DSL\n\n"
	help += "Usage: req <verb> <url> [clauses...]\n\n"
	help += "Verbs:\n"
	
	for _, verb := range g.Verbs {
		help += fmt.Sprintf("  %-13s - %s\n", verb.Name, verb.Description)
	}
	
	help += "\nClauses:\n"
	for _, clause := range g.Clauses {
		help += fmt.Sprintf("  %-13s - %s", clause.Name, clause.Description)
		if clause.Repeatable {
			help += " (repeatable)"
		}
		help += "\n"
		if clause.Example != "" {
			help += fmt.Sprintf("                 Example: %s\n", clause.Example)
		}
	}
	
	help += "\nExamples:\n"
	help += "  req read https://api.example.com/search include='param: q=search query' as=json\n"
	help += "  \n"
	help += "  req send https://api.example.com/users \\\n"
	help += "    using=POST \\\n"
	help += "    include='header: Authorization: Bearer $TOKEN' \\\n"
	help += "    with='{\"name\":\"Adam\"}' \\\n"
	help += "    expect=status:201, header:Content-Type=application/json \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req upload https://api.example.com/upload \\\n"
	help += "    attach='part: name=file, file=@./avatar.png, type=image/png' \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req authenticate https://api.example.com/login \\\n"
	help += "    using=POST \\\n"
	help += "    with='{\"user\":\"adam\",\"pass\":\"xyz\"}'\n"
	help += "  \n"
	help += "  req read https://api.example.com/me as=json\n\n"
	help += "For more information, see the grammar documentation.\n"
	
	return help
}


----
internal/grammar/snapshot.go
package grammar

import "encoding/json"

// Snapshot represents a snapshot of the grammar for drift detection.
type Snapshot struct {
	Verbs   []string `json:"verbs"`
	Clauses []ClauseSnapshot `json:"clauses"`
}

// ClauseSnapshot represents a clause in the snapshot.
type ClauseSnapshot struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Repeatable  bool   `json:"repeatable"`
}

// GetSnapshot returns a JSON-serializable snapshot of the grammar.
func GetSnapshot() Snapshot {
	g := GetGrammar()
	
	verbs := make([]string, len(g.Verbs))
	for i, v := range g.Verbs {
		verbs[i] = v.Name
	}
	
	clauses := make([]ClauseSnapshot, len(g.Clauses))
	for i, c := range g.Clauses {
		clauses[i] = ClauseSnapshot{
			Name:        c.Name,
			Description: c.Description,
			Repeatable:  c.Repeatable,
		}
	}
	
	return Snapshot{
		Verbs:   verbs,
		Clauses: clauses,
	}
}

// GetSnapshotJSON returns the snapshot as JSON bytes.
func GetSnapshotJSON() ([]byte, error) {
	snapshot := GetSnapshot()
	return json.MarshalIndent(snapshot, "", "  ")
}


----
internal/output/format.go
// Package output provides formatting and pretty-printing for execution plans.
package output

import (
	"encoding/json"
	"os"

	"github.com/adammpkins/req/internal/planner"
	"github.com/mattn/go-isatty"
)

// FormatPlan formats an ExecutionPlan as JSON for output.
func FormatPlan(plan *planner.ExecutionPlan) ([]byte, error) {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		// Pretty print when outputting to terminal
		return json.MarshalIndent(plan, "", "  ")
	}
	// Compact JSON when piped
	return json.Marshal(plan)
}


----
internal/parser/parser.go
// Package parser implements a lexer and parser for the req command grammar.
//
// Grammar (EBNF):
//
//	command = verb target [clauses]
//	verb = "read" | "save" | "send" | "upload" | "watch" | "inspect" | "authenticate" | "session"
//	target = url
//	clauses = clause { clause }
//	clause = with_clause | include_clause | attach_clause | expect_clause | as_clause | to_clause |
//	         using_clause | retry_clause | under_clause | via_clause | follow_clause | insecure_clause
//	with_clause = "with=" ( string | "@file" | "@-" )
//	include_clause = "include=" items
//	attach_clause = "attach=" parts
//	expect_clause = "expect=" checks
//	as_clause = "as=" ( "json" | "csv" | "text" | "raw" )
//	to_clause = "to=" path
//	using_clause = "using=" ( "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS" )
//	retry_clause = "retry=" number
//	under_clause = "under=" ( duration | size )
//	via_clause = "via=" url
//	follow_clause = "follow=smart"
//	insecure_clause = "insecure=" ( "true" | "false" )
package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// isValidHTTPMethod checks if a method is a valid HTTP method.
func isValidHTTPMethod(method string) bool {
	validMethods := []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	methodUpper := strings.ToUpper(method)
	for _, valid := range validMethods {
		if methodUpper == valid {
			return true
		}
	}
	return false
}

// ParseError represents a parse error with position information.
type ParseError struct {
	Position int
	Token    string
	Message  string
	Suggest  string
}

func (e *ParseError) Error() string {
	if e.Suggest != "" {
		return fmt.Sprintf("parse error at position %d (token: %q): %s (did you mean %q?)", e.Position, e.Token, e.Message, e.Suggest)
	}
	return fmt.Sprintf("parse error at position %d (token: %q): %s", e.Position, e.Token, e.Message)
}

// Parser parses req commands into AST.
type Parser struct {
	tokens []token
	pos    int
}

// token represents a lexical token.
type token struct {
	typ   tokenType
	value string
	pos   int
}

type tokenType int

const (
	tokenEOF tokenType = iota
	tokenWord
	tokenURL
	tokenEquals
	tokenColon
	tokenDotDot
	tokenString
	tokenNumber
	tokenDuration
	tokenFlag
)

// Parse parses a command string into a Command AST.
func Parse(input string) (*types.Command, error) {
	p := &Parser{}
	p.tokenize(input)
	return p.parseCommand()
}

// tokenize tokenizes the input string.
func (p *Parser) tokenize(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		p.tokens = []token{{typ: tokenEOF, pos: 0}}
		return
	}

	parts := strings.Fields(input)
	tokens := make([]token, 0, len(parts))

	for i, part := range parts {
		pos := i
		// Check if this is a URL first (URLs with query params contain = but are not clauses)
		if looksLikeURL(part) {
			tokens = append(tokens, token{typ: tokenURL, value: part, pos: pos})
		} else if strings.Contains(part, "=") {
			// Handle clauses with equals
			// Split on = but keep the = as a token
			eqIdx := strings.Index(part, "=")
			key := part[:eqIdx]
			value := part[eqIdx+1:]

			tokens = append(tokens, token{typ: tokenWord, value: key, pos: pos})
			tokens = append(tokens, token{typ: tokenEquals, value: "=", pos: pos})
			// Handle typed values like json:...
			if strings.Contains(value, ":") {
				colonIdx := strings.Index(value, ":")
				typeName := value[:colonIdx]
				typeValue := value[colonIdx+1:]
				tokens = append(tokens, token{typ: tokenWord, value: typeName, pos: pos})
				tokens = append(tokens, token{typ: tokenColon, value: ":", pos: pos})
				tokens = append(tokens, token{typ: tokenString, value: typeValue, pos: pos})
			} else if looksLikeURL(value) {
				tokens = append(tokens, token{typ: tokenURL, value: value, pos: pos})
			} else if looksLikeDuration(value) {
				tokens = append(tokens, token{typ: tokenDuration, value: value, pos: pos})
			} else {
				tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
			}
		} else if isFlag(part) {
			tokens = append(tokens, token{typ: tokenFlag, value: part, pos: pos})
		} else {
			tokens = append(tokens, token{typ: tokenWord, value: part, pos: pos})
		}
	}

	tokens = append(tokens, token{typ: tokenEOF, pos: len(parts)})
	p.tokens = tokens
}

// looksLikeURL checks if a string looks like a URL.
func looksLikeURL(s string) bool {
	return strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://")
}

// looksLikeDuration checks if a string looks like a duration.
func looksLikeDuration(s string) bool {
	_, err := parseDuration(s)
	return err == nil
}

// isFlag checks if a string is a flag.
func isFlag(s string) bool {
	return s == "verbose" || s == "resume"
}

// parseCommand parses a command.
func (p *Parser) parseCommand() (*types.Command, error) {
	cmd := &types.Command{}

	// Parse verb
	verb, err := p.parseVerb()
	if err != nil {
		return nil, err
	}
	cmd.Verb = verb

	// Handle session subcommands (show, clear, use)
	if verb == types.VerbSession {
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected session subcommand (show, clear, use)"}
		}
		tok := p.tokens[p.pos]
		if tok.typ == tokenWord {
			subcmd := tok.value
			if subcmd == "show" || subcmd == "clear" || subcmd == "use" {
				cmd.SessionSubcommand = subcmd
				p.pos++
			} else {
				return nil, &ParseError{Position: tok.pos, Token: subcmd, Message: "unknown session subcommand (expected show, clear, or use)"}
			}
		}
	}

	// Parse target
	target, err := p.parseTarget()
	if err != nil {
		return nil, err
	}
	cmd.Target = target

	// Parse clauses
	clauses, err := p.parseClauses()
	if err != nil {
		return nil, err
	}
	cmd.Clauses = clauses

	return cmd, nil
}

// parseVerb parses a verb.
func (p *Parser) parseVerb() (types.Verb, error) {
	if p.pos >= len(p.tokens) {
		return "", &ParseError{Position: p.pos, Token: "", Message: "expected verb"}
	}

	tok := p.tokens[p.pos]
	if tok.typ != tokenWord {
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "expected verb"}
	}

	verb := types.Verb(tok.value)
	switch verb {
	case types.VerbRead, types.VerbSave, types.VerbSend, types.VerbUpload,
		types.VerbWatch, types.VerbInspect, types.VerbAuthenticate, types.VerbSession:
		p.pos++
		return verb, nil
	default:
		suggest := suggestVerb(tok.value)
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "unknown verb", Suggest: suggest}
	}
}

// suggestVerb suggests a similar verb.
func suggestVerb(input string) string {
	verbs := []string{"read", "save", "send", "upload", "watch", "inspect", "authenticate", "session"}
	best := ""
	minDist := 999
	for _, v := range verbs {
		dist := levenshteinDistance(input, v)
		if dist < minDist {
			minDist = dist
			best = v
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// levenshteinDistance calculates the Levenshtein distance between two strings.
func levenshteinDistance(a, b string) int {
	if len(a) == 0 {
		return len(b)
	}
	if len(b) == 0 {
		return len(a)
	}

	matrix := make([][]int, len(a)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(b)+1)
	}

	for i := 0; i <= len(a); i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len(b); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {
			cost := 0
			if a[i-1] != b[j-1] {
				cost = 1
			}
			matrix[i][j] = min(
				matrix[i-1][j]+1,
				matrix[i][j-1]+1,
				matrix[i-1][j-1]+cost,
			)
		}
	}

	return matrix[len(a)][len(b)]
}

func min(a, b, c int) int {
	if a < b && a < c {
		return a
	}
	if b < c {
		return b
	}
	return c
}

// parseTarget parses a target URL.
func (p *Parser) parseTarget() (types.Target, error) {
	if p.pos >= len(p.tokens) {
		return types.Target{}, &ParseError{Position: p.pos, Token: "", Message: "expected target URL or host"}
	}

	tok := p.tokens[p.pos]
	// For session commands, target might be a host instead of full URL
	if tok.typ == tokenURL {
		p.pos++
		return types.Target{URL: tok.value}, nil
	} else if tok.typ == tokenWord {
		// Might be a host name for session commands
		// Try to parse as URL, if it fails, treat as host
		if strings.Contains(tok.value, ".") || strings.Contains(tok.value, ":") {
			// Looks like a host, construct URL
			urlStr := "https://" + tok.value
			p.pos++
			return types.Target{URL: urlStr}, nil
		}
	}

	return types.Target{}, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected URL or host"}
}

// parseClauses parses zero or more clauses.
func (p *Parser) parseClauses() ([]types.Clause, error) {
	var clauses []types.Clause
	singletonSeen := make(map[string]bool)

	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}

		clause, err := p.parseClause()
		if err != nil {
			return nil, err
		}

		// Check for duplicate singletons
		if singletonKey := getSingletonKey(clause); singletonKey != "" {
			if singletonSeen[singletonKey] {
				return nil, &ParseError{
					Position: tok.pos,
					Token:    tok.value,
					Message:  fmt.Sprintf("duplicate singleton clause '%s'", singletonKey),
					Suggest:  fmt.Sprintf("remove duplicate '%s=' clause", singletonKey),
				}
			}
			singletonSeen[singletonKey] = true
		}

		clauses = append(clauses, clause)
	}

	return clauses, nil
}

// getSingletonKey returns the key name for singleton clauses, or empty string for repeatable clauses.
func getSingletonKey(clause types.Clause) string {
	switch clause.(type) {
	case types.UsingClause:
		return "using"
	case types.WithClause:
		return "with"
	case types.ExpectClause:
		return "expect"
	case types.AsClause:
		return "as"
	case types.ToClause:
		return "to"
	case types.RetryClause:
		return "retry"
	case types.UnderClause:
		return "under"
	case types.ViaClause:
		return "via"
	case types.InsecureClause:
		return "insecure"
	case types.FollowClause:
		return "follow"
	case types.TimeoutClause:
		return "timeout"
	case types.BackoffClause:
		return "backoff"
	case types.PickClause:
		return "pick"
	case types.EveryClause:
		return "every"
	case types.UntilClause:
		return "until"
	case types.ProxyClause:
		return "proxy"
	case types.FieldClause:
		return "field"
	case types.VerboseClause:
		return "verbose"
	case types.ResumeClause:
		return "resume"
	// Repeatable clauses return empty string
	case types.IncludeClause, types.AttachClause:
		return ""
	default:
		return ""
	}
}

// parseClause parses a single clause.
func (p *Parser) parseClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected clause"}
	}

	tok := p.tokens[p.pos]

	// Handle flags (insecure is now a clause with =, but keep verbose and resume as flags)
	if tok.typ == tokenFlag {
		p.pos++
		switch tok.value {
		case "verbose":
			return types.VerboseClause{}, nil
		case "resume":
			return types.ResumeClause{}, nil
		}
	}

	// Handle clauses with equals
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
		key := tok.value
		p.pos += 2 // skip key and =

		switch key {
		case "with":
			return p.parseWithClause()
		case "include":
			return p.parseIncludeClause()
		case "attach":
			return p.parseAttachClause()
		case "expect":
			return p.parseExpectClause()
		case "headers":
			return p.parseHeadersClause()
		case "params":
			return p.parseParamsClause()
		case "as":
			return p.parseAsClause()
		case "to":
			return p.parseToClause()
		case "using":
			return p.parseUsingClause()
		case "retry":
			return p.parseRetryClause()
		case "backoff":
			return p.parseBackoffClause()
		case "timeout":
			return p.parseTimeoutClause()
		case "under":
			return p.parseUnderClause()
		case "proxy":
			return p.parseProxyClause()
		case "via":
			return p.parseViaClause()
		case "follow":
			return p.parseFollowClause()
		case "insecure":
			return p.parseInsecureClause()
		case "pick":
			return p.parsePickClause()
		case "every":
			return p.parseEveryClause()
		case "until":
			return p.parseUntilClause()
		case "field":
			return p.parseFieldClause()
		default:
			suggest := suggestClause(key)
			return nil, &ParseError{Position: tok.pos, Token: key, Message: "unknown clause", Suggest: suggest}
		}
	}

	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected clause"}
}

// suggestClause suggests a similar clause name.
func suggestClause(input string) string {
	clauses := []string{"with", "include", "attach", "expect", "headers", "params", "as", "to", "using", "retry", "backoff", "timeout", "under", "proxy", "via", "follow", "insecure", "pick", "every", "until", "field"}
	best := ""
	minDist := 999
	for _, c := range clauses {
		dist := levenshteinDistance(input, c)
		if dist < minDist {
			minDist = dist
			best = c
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// parseWithClause parses a "with=" clause.
func (p *Parser) parseWithClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	tok := p.tokens[p.pos]
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenColon {
		// typed value like json:...
		typeName := tok.value
		p.pos += 2 // skip type and :
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
		}
		valueTok := p.tokens[p.pos]
		p.pos++
		value := valueTok.value
		isFile := strings.HasPrefix(value, "@") && value != "@-"
		isStdin := value == "@-"
		if isFile {
			value = value[1:] // Remove @ prefix
		}
		return types.WithClause{Type: typeName, Value: value, IsFile: isFile, IsStdin: isStdin}, nil
	}

	// plain value - check for @file or @-
	valueTok := p.tokens[p.pos]
	p.pos++
	value := valueTok.value
	isFile := strings.HasPrefix(value, "@") && value != "@-"
	isStdin := value == "@-"
	if isFile {
		value = value[1:] // Remove @ prefix
	}
	
	// Infer JSON type if value starts with { or [
	typeInferred := ""
	if !isFile && !isStdin {
		trimmed := strings.TrimSpace(value)
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			typeInferred = "json"
		}
	}
	
	return types.WithClause{Value: value, Type: typeInferred, IsFile: isFile, IsStdin: isStdin}, nil
}

// parseHeadersClause parses a "headers=" clause (simplified for v0.1.0).
func (p *Parser) parseHeadersClause() (types.Clause, error) {
	// Simplified: just parse a single key:value pair for now
	// Full object parsing will come later
	return types.HeadersClause{Headers: make(map[string]string)}, nil
}

// parseParamsClause parses a "params=" clause (simplified for v0.1.0).
func (p *Parser) parseParamsClause() (types.Clause, error) {
	// Simplified: just parse a single key=value pair for now
	return types.ParamsClause{Params: make(map[string]string)}, nil
}

// parseAsClause parses an "as=" clause.
func (p *Parser) parseAsClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected format"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.AsClause{Format: tok.value}, nil
}

// parseToClause parses a "to=" clause.
func (p *Parser) parseToClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected destination"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ToClause{Destination: tok.value}, nil
}

// parseUsingClause parses a "using=" clause.
func (p *Parser) parseUsingClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected HTTP method"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	method := strings.ToUpper(tok.value)
	
	if !isValidHTTPMethod(method) {
		return nil, &ParseError{
			Position: tok.pos,
			Token:    tok.value,
			Message:  fmt.Sprintf("invalid HTTP method: %s (valid methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS)", tok.value),
		}
	}
	
	return types.UsingClause{Method: method}, nil
}

// parseRetryClause parses a "retry=" clause.
func (p *Parser) parseRetryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected retry count"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	// Parse number (simplified)
	count := 3 // default
	if tok.typ == tokenNumber {
		// In a real implementation, parse the number
		// For now, just use default
	}
	return types.RetryClause{Count: count}, nil
}

// parseBackoffClause parses a "backoff=" clause.
func (p *Parser) parseBackoffClause() (types.Clause, error) {
	// Format: backoff=200ms..5s
	if p.pos+2 >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected backoff range"}
	}

	minTok := p.tokens[p.pos]
	p.pos++
	if p.tokens[p.pos].typ != tokenDotDot {
		return nil, &ParseError{Position: p.pos, Token: p.tokens[p.pos].value, Message: "expected .."}
	}
	p.pos++
	maxTok := p.tokens[p.pos]
	p.pos++

	minDur, err := parseDuration(minTok.value)
	if err != nil {
		return nil, &ParseError{Position: minTok.pos, Token: minTok.value, Message: "invalid duration"}
	}
	maxDur, err := parseDuration(maxTok.value)
	if err != nil {
		return nil, &ParseError{Position: maxTok.pos, Token: maxTok.value, Message: "invalid duration"}
	}

	return types.BackoffClause{Min: minDur, Max: maxDur}, nil
}

// parseDuration parses a duration string.
func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

// parseTimeoutClause parses a "timeout=" clause.
func (p *Parser) parseTimeoutClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected timeout duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.TimeoutClause{Duration: dur}, nil
}

// parseProxyClause parses a "proxy=" clause.
func (p *Parser) parseProxyClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected proxy URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ProxyClause{URL: tok.value}, nil
}

// parsePickClause parses a "pick=" clause.
func (p *Parser) parsePickClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected JSONPath expression"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.PickClause{Path: tok.value}, nil
}

// parseEveryClause parses an "every=" clause.
func (p *Parser) parseEveryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected interval duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.EveryClause{Interval: dur}, nil
}

// parseUntilClause parses an "until=" clause.
func (p *Parser) parseUntilClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected predicate"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.UntilClause{Predicate: tok.value}, nil
}

// parseFieldClause parses a "field=" clause.
func (p *Parser) parseFieldClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field name"}
	}

	nameTok := p.tokens[p.pos]
	p.pos++
	if p.pos >= len(p.tokens) || p.tokens[p.pos].typ != tokenEquals {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected ="}
	}
	p.pos++
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field value"}
	}
	valueTok := p.tokens[p.pos]
	p.pos++

	return types.FieldClause{Name: nameTok.value, Value: valueTok.value}, nil
}

// parseIncludeClause parses an "include=" clause.
// Format: include='header: Name: Value; param: key=value; cookie: key=value'
func (p *Parser) parseIncludeClause() (types.Clause, error) {
	// Collect tokens until we have a complete include value
	// The value may contain colons, semicolons, and spaces
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected include value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}

	items, err := parseIncludeItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.IncludeClause{Items: items}, nil
}

// parseIncludeItems parses semicolon-separated include items.
func parseIncludeItems(value string) ([]types.IncludeItem, error) {
	var items []types.IncludeItem
	
	// Split by semicolons, but respect quoted strings
	parts := splitRespectingQuotes(value, ';')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		item, err := parseIncludeItem(part)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	
	return items, nil
}

// parseIncludeItem parses a single include item (header:, param:, cookie:).
func parseIncludeItem(part string) (types.IncludeItem, error) {
	// Find the first colon to determine the type
	colonIdx := strings.Index(part, ":")
	if colonIdx == -1 {
		return types.IncludeItem{}, fmt.Errorf("missing colon in include item: %s", part)
	}
	
	typeTag := strings.TrimSpace(part[:colonIdx])
	rest := strings.TrimSpace(part[colonIdx+1:])
	
	switch typeTag {
	case "header":
		// Format: header: Name: Value
		headerColonIdx := strings.Index(rest, ":")
		if headerColonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("header item missing Name colon Value: %s", part)
		}
		name := strings.TrimSpace(rest[:headerColonIdx])
		value := strings.TrimSpace(rest[headerColonIdx+1:])
		// Unquote if needed
		name = unquoteString(name)
		value = unquoteString(value)
		return types.IncludeItem{Type: "header", Name: name, Value: value}, nil
		
	case "param":
		// Format: param: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("param item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "param", Name: key, Value: value}, nil
		
	case "cookie":
		// Format: cookie: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("cookie item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "cookie", Name: key, Value: value}, nil
		
	default:
		return types.IncludeItem{}, fmt.Errorf("unknown include item tag: %s (expected header, param, or cookie)", typeTag)
	}
}

// splitRespectingQuotes splits a string by a delimiter while respecting quoted strings.
func splitRespectingQuotes(s string, delim rune) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	escape := false
	
	for _, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}
		
		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}
		
		if r == '\'' || r == '"' {
			inQuotes = !inQuotes
			current.WriteRune(r)
			continue
		}
		
		if r == delim && !inQuotes {
			parts = append(parts, current.String())
			current.Reset()
			continue
		}
		
		current.WriteRune(r)
	}
	
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	
	return parts
}

// unquoteString removes surrounding quotes if present and handles escapes.
func unquoteString(s string) string {
	if len(s) >= 2 && ((s[0] == '\'' && s[len(s)-1] == '\'') || (s[0] == '"' && s[len(s)-1] == '"')) {
		s = s[1 : len(s)-1]
		// Handle escapes
		var result strings.Builder
		escape := false
		for _, r := range s {
			if escape {
				if r == '\\' || r == '\'' || r == '"' {
					result.WriteRune(r)
				} else {
					result.WriteRune('\\')
					result.WriteRune(r)
				}
				escape = false
			} else if r == '\\' {
				escape = true
			} else {
				result.WriteRune(r)
			}
		}
		if escape {
			result.WriteRune('\\')
		}
		return result.String()
	}
	return s
}

// parseAttachClause parses an "attach=" clause.
// Format: attach='part: name=..., file=@path; part: name=..., value=...'
func (p *Parser) parseAttachClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected attach value"}
	}

	tok := p.tokens[p.pos]
	p.pos++

	value := tok.value
	parts, boundary, err := parseAttachItems(value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: err.Error()}
	}

	return types.AttachClause{Parts: parts, Boundary: boundary}, nil
}

// parseAttachItems parses semicolon-separated attach items.
func parseAttachItems(value string) ([]types.AttachPart, string, error) {
	var parts []types.AttachPart
	var boundary string
	
	// Split by semicolons, respecting quotes
	items := splitRespectingQuotes(value, ';')
	
	for _, item := range items {
		item = strings.TrimSpace(item)
		if item == "" {
			continue
		}
		
		// Check if it's a boundary specification
		if strings.HasPrefix(item, "boundary:") {
			boundary = strings.TrimSpace(strings.TrimPrefix(item, "boundary:"))
			boundary = unquoteString(boundary)
			continue
		}
		
		// Parse part: specification
		if !strings.HasPrefix(item, "part:") {
			return nil, "", fmt.Errorf("expected 'part:' or 'boundary:', got: %s", item)
		}
		
		partSpec := strings.TrimSpace(strings.TrimPrefix(item, "part:"))
		part, err := parseAttachPart(partSpec)
		if err != nil {
			return nil, "", err
		}
		parts = append(parts, part)
	}
	
	return parts, boundary, nil
}

// parseAttachPart parses a single attach part specification.
// Format: name=..., file=@path or value=..., optional filename=..., optional type=...
func parseAttachPart(spec string) (types.AttachPart, error) {
	var part types.AttachPart
	
	// Parse comma-separated key=value pairs
	pairs := splitRespectingQuotes(spec, ',')
	
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		eqIdx := strings.Index(pair, "=")
		if eqIdx == -1 {
			return types.AttachPart{}, fmt.Errorf("missing equals in attach part: %s", pair)
		}
		
		key := strings.TrimSpace(pair[:eqIdx])
		value := strings.TrimSpace(pair[eqIdx+1:])
		value = unquoteString(value)
		
		switch key {
		case "name":
			part.Name = value
		case "file":
			if strings.HasPrefix(value, "@") {
				part.FilePath = value[1:] // Remove @
			} else {
				part.FilePath = value
			}
		case "value":
			part.Value = value
		case "filename":
			part.Filename = value
		case "type":
			part.Type = value
		default:
			return types.AttachPart{}, fmt.Errorf("unknown attach part key: %s", key)
		}
	}
	
	// Validate: name is required
	if part.Name == "" {
		return types.AttachPart{}, fmt.Errorf("attach part missing required 'name='")
	}
	
	// Validate: exactly one of file or value
	hasFile := part.FilePath != ""
	hasValue := part.Value != ""
	if hasFile && hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part cannot have both 'file=' and 'value='")
	}
	if !hasFile && !hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part must have either 'file=' or 'value='")
	}
	
	return part, nil
}

// parseExpectClause parses an "expect=" clause.
// Format: expect=status:200, header:Content-Type=application/json, contains:"text"
func (p *Parser) parseExpectClause() (types.Clause, error) {
	// Collect tokens until we have a complete expect value
	// The value may contain colons and commas, so we need to collect multiple tokens
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected expect value"}
	}

	// Join tokens, but handle colons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon and current isn't a colon
			if valueParts[i-1] != ":" && part != ":" {
				value += " "
			}
		}
		value += part
	}
	
	checks, err := parseExpectChecks(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.ExpectClause{Checks: checks}, nil
}

// parseExpectChecks parses comma-separated expect checks.
func parseExpectChecks(value string) ([]types.ExpectCheck, error) {
	var checks []types.ExpectCheck
	
	// Split by commas, respecting quotes
	parts := splitRespectingQuotes(value, ',')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		check, err := parseExpectCheck(part)
		if err != nil {
			return nil, err
		}
		checks = append(checks, check)
	}
	
	return checks, nil
}

// parseExpectCheck parses a single expect check.
func parseExpectCheck(part string) (types.ExpectCheck, error) {
	// Unquote if needed first
	unquoted := unquoteString(part)
	
	// Check types: status:, header:, contains:, jsonpath:, matches:
	if strings.HasPrefix(unquoted, "status:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "status:"))
		return types.ExpectCheck{Type: "status", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "header:") {
		rest := strings.TrimSpace(strings.TrimPrefix(unquoted, "header:"))
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.ExpectCheck{}, fmt.Errorf("header check missing equals: %s", part)
		}
		name := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		value = unquoteString(value)
		return types.ExpectCheck{Type: "header", Name: name, Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "contains:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "contains:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "contains", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "jsonpath:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "jsonpath:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "jsonpath", Path: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "matches:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "matches:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "matches", Regex: value}, nil
	}
	
	return types.ExpectCheck{}, fmt.Errorf("unknown expect check type: %s", part)
}

// parseFollowClause parses a "follow=" clause.
func (p *Parser) parseFollowClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected follow value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "smart" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "follow accepts only 'smart'"}
	}
	
	return types.FollowClause{Policy: "smart"}, nil
}

// parseUnderClause parses an "under=" clause (duration or size).
func (p *Parser) parseUnderClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected under value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.TrimSpace(tok.value)
	
	// Try parsing as duration first
	if dur, err := parseDuration(value); err == nil {
		return types.UnderClause{Duration: dur, IsSize: false}, nil
	}
	
	// Try parsing as size (e.g., "10MB", "1GB")
	if size, err := parseSize(value); err == nil {
		return types.UnderClause{Size: size, IsSize: true}, nil
	}
	
	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "under value must be a duration (e.g., 30s) or size (e.g., 10MB)"}
}

// parseSize parses a size string like "10MB", "1GB", etc.
func parseSize(s string) (int64, error) {
	s = strings.TrimSpace(s)
	s = strings.ToUpper(s)
	
	multipliers := map[string]int64{
		"B":  1,
		"KB": 1024,
		"MB": 1024 * 1024,
		"GB": 1024 * 1024 * 1024,
		"TB": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, mult := range multipliers {
		if strings.HasSuffix(s, suffix) {
			numStr := strings.TrimSuffix(s, suffix)
			var num float64
			if _, err := fmt.Sscanf(numStr, "%f", &num); err != nil {
				return 0, err
			}
			return int64(num * float64(mult)), nil
		}
	}
	
	return 0, fmt.Errorf("unknown size suffix")
}

// parseViaClause parses a "via=" clause.
func (p *Parser) parseViaClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected via URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ViaClause{URL: tok.value}, nil
}

// parseInsecureClause parses an "insecure=" clause.
func (p *Parser) parseInsecureClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected insecure value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "true" && value != "false" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "insecure accepts only 'true' or 'false'"}
	}
	
	return types.InsecureClause{Value: value == "true"}, nil
}

----
internal/planner/plan.go
// Package planner applies defaults, validates commands, and produces execution plans.
package planner

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// ExecutionPlan represents a fully resolved execution plan ready for HTTP runtime.
type ExecutionPlan struct {
	Verb        types.Verb         `json:"verb"`
	Method      string             `json:"method"`
	URL         string             `json:"url"`
	Headers     map[string]string  `json:"headers,omitempty"`
	QueryParams map[string]string  `json:"query_params,omitempty"`
	Cookies     map[string]string  `json:"cookies,omitempty"`
	Body        *BodyPlan          `json:"body,omitempty"`
	Output      *OutputPlan        `json:"output,omitempty"`
	Retry       *RetryPlan         `json:"retry,omitempty"`
	Timeout     *time.Duration    `json:"timeout,omitempty"`
	SizeLimit   *int64            `json:"size_limit,omitempty"`
	Proxy       string             `json:"proxy,omitempty"`
	Insecure    bool               `json:"insecure,omitempty"`
	Verbose     bool               `json:"verbose,omitempty"`
	Resume      bool               `json:"resume,omitempty"`
	Follow      string             `json:"follow,omitempty"` // "smart" or empty
	Expect      []types.ExpectCheck `json:"expect,omitempty"`
}

// BodyPlan represents the request body configuration.
type BodyPlan struct {
	Type     string                `json:"type"` // json, form, multipart, raw
	Content  string                `json:"content,omitempty"`
	FilePath string                `json:"file_path,omitempty"`
	Field    string                `json:"field,omitempty"` // for multipart
	AttachParts []types.AttachPart `json:"attach_parts,omitempty"` // for multipart
	Boundary string                `json:"boundary,omitempty"` // for multipart
}

// OutputPlan represents the output configuration.
type OutputPlan struct {
	Format      string `json:"format"` // json, csv, text, raw
	Destination string `json:"destination,omitempty"`
	Pick        string `json:"pick,omitempty"` // JSONPath expression
}

// RetryPlan represents retry configuration.
type RetryPlan struct {
	Count  int           `json:"count"`
	Backoff BackoffRange `json:"backoff"`
}

// BackoffRange represents a backoff range with min and max durations.
type BackoffRange struct {
	Min time.Duration `json:"min"`
	Max time.Duration `json:"max"`
}

// Plan creates an ExecutionPlan from a parsed Command.
func Plan(cmd *types.Command) (*ExecutionPlan, error) {
	plan := &ExecutionPlan{
		Verb:        cmd.Verb,
		URL:         cmd.Target.URL,
		Headers:     make(map[string]string),
		QueryParams: make(map[string]string),
		Cookies:     make(map[string]string),
	}

	// Apply verb-specific defaults
	if err := applyVerbDefaults(cmd.Verb, plan); err != nil {
		return nil, err
	}

	// Process clauses
	for _, clause := range cmd.Clauses {
		if err := applyClause(clause, plan, cmd.Verb); err != nil {
			return nil, err
		}
	}

	// Post-process: extract filename for save verb if destination not provided or is a directory
	if cmd.Verb == types.VerbSave && plan.Output != nil {
		if plan.Output.Destination == "" {
			// No destination provided, extract from URL
			filename := extractFilenameFromURL(plan.URL)
			if filename != "" {
				plan.Output.Destination = filename
			}
		} else {
			// Destination provided - check if it's a directory
			if isDirectory(plan.Output.Destination) {
				// It's a directory, append filename from URL
				filename := extractFilenameFromURL(plan.URL)
				if filename != "" {
					plan.Output.Destination = filepath.Join(plan.Output.Destination, filename)
				}
			}
			// If it's a file path (like /tmp/file.zip), use it as-is
		}
	}

	// Validate plan
	if err := validatePlan(plan); err != nil {
		return nil, err
	}

	return plan, nil
}

// applyVerbDefaults applies default settings based on the verb.
func applyVerbDefaults(verb types.Verb, plan *ExecutionPlan) error {
	switch verb {
	case types.VerbRead:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSave:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "raw"}
	case types.VerbSend:
		// Default to GET, will be changed to POST if with= is present
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbUpload:
		// Default to POST, but will error if no attach= or with= present
		plan.Method = http.MethodPost
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbWatch:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbInspect:
		plan.Method = http.MethodHead
		plan.Output = &OutputPlan{Format: "json"}
	case types.VerbAuthenticate:
		// Default to POST if with= is present, otherwise require using=
		// We'll check this in validatePlan
		plan.Method = http.MethodPost // tentative, may be overridden
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSession:
		// Session verbs are handled separately in main
		plan.Method = http.MethodGet // placeholder
		plan.Output = &OutputPlan{Format: "auto"}
	default:
		return fmt.Errorf("unsupported verb: %s", verb)
	}
	return nil
}

// validateUsingClause validates that the HTTP method is compatible with the verb.
func validateUsingClause(verb types.Verb, method string) error {
	allowedMethods := map[types.Verb][]string{
		types.VerbRead:    {"GET", "HEAD", "OPTIONS"},
		types.VerbSave:    {"GET", "POST"},
		types.VerbSend:   {"POST", "PUT", "PATCH"},
		types.VerbUpload: {"POST", "PUT"},
		types.VerbWatch:  {"GET"},
		types.VerbInspect: {"HEAD", "GET", "OPTIONS"},
	}
	
	allowed, ok := allowedMethods[verb]
	if !ok {
		// If verb not in map, allow any method (for future verbs like delete)
		return nil
	}
	
	for _, allowedMethod := range allowed {
		if method == allowedMethod {
			return nil
		}
	}
	
	return fmt.Errorf("verb '%s' is incompatible with method '%s'", verb, method)
}

// applyClause applies a clause to the execution plan.
func applyClause(clause types.Clause, plan *ExecutionPlan, verb types.Verb) error {
	switch c := clause.(type) {
	case types.UsingClause:
		// Validate compatibility before applying
		if err := validateUsingClause(verb, c.Method); err != nil {
			return err
		}
		// Normalize to uppercase (defensive, should already be normalized in parser)
		plan.Method = strings.ToUpper(c.Method)
	case types.HeadersClause:
		for k, v := range c.Headers {
			plan.Headers[k] = v
		}
	case types.ParamsClause:
		for k, v := range c.Params {
			plan.QueryParams[k] = v
		}
	case types.WithClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		
		// Handle file or stdin
		if c.IsFile {
			plan.Body.FilePath = c.Value
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for files
			}
		} else if c.IsStdin {
			plan.Body.FilePath = "-" // Special marker for stdin
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for stdin
			}
		} else {
			plan.Body.Content = c.Value
			plan.Body.Type = c.Type
			// If type was inferred as JSON, we'll note it in runtime
			if plan.Body.Type == "json" {
				// JSON inference will be logged in runtime
			}
		}
		
		// If method is still GET and we have a body, default to POST
		if plan.Method == http.MethodGet {
			plan.Method = http.MethodPost
		}
	case types.AsClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Format = c.Format
	case types.ToClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Destination = c.Destination
	case types.RetryClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{
				Backoff: BackoffRange{
					Min: 200 * time.Millisecond,
					Max: 5 * time.Second,
				},
			}
		}
		plan.Retry.Count = c.Count
	case types.BackoffClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{Count: 3}
		}
		plan.Retry.Backoff = BackoffRange{
			Min: c.Min,
			Max: c.Max,
		}
	case types.TimeoutClause:
		plan.Timeout = &c.Duration
	case types.ProxyClause:
		plan.Proxy = c.URL
	case types.PickClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Pick = c.Path
	case types.InsecureClause:
		plan.Insecure = c.Value
	case types.ViaClause:
		plan.Proxy = c.URL
	case types.IncludeClause:
		// Merge include items into headers, params, or cookies
		for _, item := range c.Items {
			switch item.Type {
			case "header":
				// For multi-valued headers, we'd need to track arrays, but for now last wins
				// TODO: Support multi-valued headers properly
				plan.Headers[item.Name] = item.Value
			case "param":
				// Params can be repeated, so we append to query params
				// The runtime will handle serialization
				plan.QueryParams[item.Name] = item.Value
			case "cookie":
				// Cookies: last value wins
				plan.Cookies[item.Name] = item.Value
			}
		}
	case types.AttachClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		plan.Body.Type = "multipart"
		plan.Body.AttachParts = c.Parts
		if c.Boundary != "" {
			plan.Body.Boundary = c.Boundary
		}
	case types.ExpectClause:
		plan.Expect = c.Checks
	case types.FollowClause:
		plan.Follow = c.Policy
	case types.UnderClause:
		if c.IsSize {
			plan.SizeLimit = &c.Size
		} else {
			plan.Timeout = &c.Duration
		}
	case types.VerboseClause:
		plan.Verbose = true
	case types.ResumeClause:
		plan.Resume = true
	default:
		return fmt.Errorf("unsupported clause type: %T", clause)
	}
	return nil
}

// validatePlan validates the execution plan.
func validatePlan(plan *ExecutionPlan) error {
	if plan.Method == "" {
		return fmt.Errorf("method is required")
	}
	if plan.URL == "" {
		return fmt.Errorf("URL is required")
	}
	
	// Validate upload verb: must have attach= or with=
	// This check will be done after clauses are processed, so we check here
	// Actually, we need to check this in Plan() after processing clauses
	// For now, we'll do basic validation
	
	return nil
}

// extractFilenameFromURL extracts a filename from a URL.
func extractFilenameFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Get the path
	path := u.Path
	if path == "" || path == "/" {
		// Try to get from query or fragment
		return "download"
	}

	// Remove leading slash
	path = strings.TrimPrefix(path, "/")

	// Get the last segment
	parts := strings.Split(path, "/")
	if len(parts) == 0 {
		return "download"
	}

	filename := parts[len(parts)-1]

	// URL decode the filename (handle both path and query encoding)
	filename, err = url.PathUnescape(filename)
	if err != nil {
		// If PathUnescape fails, try QueryUnescape
		filename, err = url.QueryUnescape(filename)
		if err != nil {
			// If decoding fails, use the original
			filename = parts[len(parts)-1]
		}
	}

	// If filename is empty or doesn't have an extension, use a default
	if filename == "" || !strings.Contains(filename, ".") {
		filename = "download"
	}

	// Clean the filename (remove any path separators)
	filename = filepath.Base(filename)

	return filename
}

// isDirectory checks if a path is a directory.
func isDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}


----
internal/runtime/executor.go
// Package runtime executes HTTP requests based on execution plans.
package runtime

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
	"github.com/adammpkins/req/internal/session"
)

// Executor executes HTTP requests.
type Executor struct {
	client *http.Client
}

// NewExecutor creates a new executor.
func NewExecutor(plan *planner.ExecutionPlan) (*Executor, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create cookie jar: %w", err)
	}

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{},
	}

	// Configure TLS if insecure
	if plan.Insecure {
		transport.TLSClientConfig = getInsecureTLSConfig()
		fmt.Fprintf(os.Stderr, "Warning: TLS verification disabled\n")
	}

	// Configure proxy if specified
	if plan.Proxy != "" {
		proxyURL, err := url.Parse(plan.Proxy)
		if err != nil {
			return nil, fmt.Errorf("invalid proxy URL: %w", err)
		}
		transport.Proxy = http.ProxyURL(proxyURL)
	}

	client := &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
		Jar:       jar,
	}

	if plan.Timeout != nil {
		client.Timeout = *plan.Timeout
	}

	return &Executor{client: client}, nil
}

// Execute executes an HTTP request based on the plan.
func (e *Executor) Execute(plan *planner.ExecutionPlan) error {
	// Build request URL with query parameters (preserving order)
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("invalid URL: %v", err)}
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to build body: %v", err)}
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to create request: %v", err)}
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Auto-apply session if available and not explicitly set
	e.autoApplySession(req, plan)

	// Add Accept-Encoding if not set by user
	if req.Header.Get("Accept-Encoding") == "" {
		req.Header.Set("Accept-Encoding", "gzip, br")
	}

	// Execute request with redirect handling
	resp, redirectTrace, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
	}
	defer resp.Body.Close()

	// Print redirect trace to stderr
	if len(redirectTrace) > 0 {
		for _, trace := range redirectTrace {
			fmt.Fprintf(os.Stderr, "%s\n", trace)
		}
	}

	// Read and decompress response body
	bodyBytes, decompressed, err := e.readAndDecompress(resp)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("failed to read response: %v", err)}
	}

	if decompressed {
		fmt.Fprintf(os.Stderr, "Decompressed response\n")
	}

	// Print meta to stderr
	e.printMeta(resp, reqURL, len(bodyBytes), decompressed)

	// Capture session for authenticate verb
	if plan.Verb == types.VerbAuthenticate {
		host, err := session.ExtractHost(plan.URL)
		if err == nil {
			setCookies := resp.Header.Values("Set-Cookie")
			updatedSession, err := session.UpdateSessionFromResponse(host, setCookies, bodyBytes)
			if err == nil && updatedSession != nil {
				if err := session.SaveSession(updatedSession); err == nil {
					fmt.Fprintf(os.Stderr, "Session saved for %s\n", host)
				}
			}
		}
	}

	// Run expect checks
	if len(plan.Expect) > 0 {
		if err := e.runExpectChecks(resp, bodyBytes, plan.Expect); err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			return &ExecutionError{Code: 3, Message: "expectation failed"}
		}
	} else {
		// If no expect checks, fail on non-2xx status codes
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("HTTP %d %s", resp.StatusCode, resp.Status)}
		}
	}

	// Handle output based on plan
	if plan.Output != nil && plan.Output.Destination != "" {
		// Save to file - uses io.Copy for efficient writing
		// TODO: Optimize to stream directly from resp.Body when no expect checks
		return e.saveToFile(bytes.NewReader(bodyBytes), plan.Output.Destination)
	}

	// Handle watch verb with TTY detection
	if plan.Verb == types.VerbWatch {
		// TODO: Implement TTY detection
		// TTY: timestamped lines
		// Non-TTY: raw lines
		return e.writeOutput(bodyBytes, plan.Output)
	}

	// Format and write output
	return e.writeOutput(bodyBytes, plan.Output)
}

// ExecutionError represents an execution error with exit code.
type ExecutionError struct {
	Code    int
	Message string
}

func (e *ExecutionError) Error() string {
	return e.Message
}

// buildURL builds the request URL with query parameters, preserving order.
func (e *Executor) buildURL(plan *planner.ExecutionPlan) (string, error) {
	u, err := url.Parse(plan.URL)
	if err != nil {
		return "", err
	}

	// Merge existing query params with new ones
	existingParams := u.Query()
	for k, v := range plan.QueryParams {
		// Append to preserve order for repeated keys
		existingParams.Add(k, v)
	}
	u.RawQuery = existingParams.Encode()

	return u.String(), nil
}

// buildBody builds the request body.
func (e *Executor) buildBody(plan *planner.ExecutionPlan) (io.Reader, string, error) {
	if plan.Body == nil {
		return nil, "", nil
	}

	// Handle multipart
	if plan.Body.Type == "multipart" {
		return e.buildMultipartBody(plan.Body)
	}

	// Handle file or stdin
	if plan.Body.FilePath != "" {
		if plan.Body.FilePath == "-" {
			// Read from stdin
			data, err := io.ReadAll(os.Stdin)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read stdin: %w", err)
			}
			plan.Body.Content = string(data)
		} else {
			// Read from file
			data, err := os.ReadFile(plan.Body.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", plan.Body.FilePath, err)
			}
			plan.Body.Content = string(data)
		}
	}

	// Determine content type
	contentType := ""
	if plan.Body.Type == "json" {
		contentType = "application/json"
		// Log JSON inference if it was inferred
		if strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "{") || strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "[") {
			fmt.Fprintf(os.Stderr, "Inferred Content-Type: application/json\n")
		}
	} else if plan.Body.Type == "form" {
		contentType = "application/x-www-form-urlencoded"
	}

	return strings.NewReader(plan.Body.Content), contentType, nil
}

// buildMultipartBody builds a multipart/form-data body.
func (e *Executor) buildMultipartBody(bodyPlan *planner.BodyPlan) (io.Reader, string, error) {
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	boundary := bodyPlan.Boundary
	if boundary == "" {
		boundary = writer.Boundary()
	} else {
		writer.SetBoundary(boundary)
	}

	for _, part := range bodyPlan.AttachParts {
		var partWriter io.Writer
		var err error

		// Create form field
		if part.Filename != "" {
			partWriter, err = writer.CreateFormFile(part.Name, part.Filename)
		} else {
			partWriter, err = writer.CreateFormField(part.Name)
		}
		if err != nil {
			return nil, "", fmt.Errorf("failed to create form field: %w", err)
		}

		// Write part content
		if part.FilePath != "" {
			// Read file
			data, err := os.ReadFile(part.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", part.FilePath, err)
			}
			if _, err := partWriter.Write(data); err != nil {
				return nil, "", fmt.Errorf("failed to write file data: %w", err)
			}
		} else {
			// Write value
			if _, err := partWriter.Write([]byte(part.Value)); err != nil {
				return nil, "", fmt.Errorf("failed to write value: %w", err)
			}
		}
	}

	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
	return &buf, contentType, nil
}

// setHeaders sets request headers.
func (e *Executor) setHeaders(req *http.Request, plan *planner.ExecutionPlan, contentType string) {
	// Set user headers first
	for k, v := range plan.Headers {
		req.Header.Set(k, v)
	}

	// Override Content-Type if multipart (user may have set it manually)
	if plan.Body != nil && plan.Body.Type == "multipart" {
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
			// Check if user had set Content-Type manually
			if _, wasSet := plan.Headers["Content-Type"]; wasSet {
				fmt.Fprintf(os.Stderr, "Note: Content-Type overridden for multipart\n")
			}
		}
	} else if contentType != "" && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", contentType)
	}
}

// setCookies sets request cookies.
func (e *Executor) setCookies(req *http.Request, plan *planner.ExecutionPlan) {
	for name, value := range plan.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}
}

// autoApplySession automatically applies a stored session if available.
func (e *Executor) autoApplySession(req *http.Request, plan *planner.ExecutionPlan) {
	// Don't auto-apply if Authorization or Cookie headers are explicitly set
	hasAuth := req.Header.Get("Authorization") != ""
	hasCookie := false
	for name := range plan.Cookies {
		if name != "" {
			hasCookie = true
			break
		}
	}
	if hasAuth || hasCookie {
		return
	}

	// Extract host from URL
	host, err := session.ExtractHost(plan.URL)
	if err != nil {
		return
	}

	// Load session
	sess, err := session.LoadSession(host)
	if err != nil || sess == nil {
		return
	}

	// Apply authorization if available
	if sess.Authorization != "" {
		req.Header.Set("Authorization", sess.Authorization)
	}

	// Apply cookies
	for name, value := range sess.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}

	fmt.Fprintf(os.Stderr, "Using session for %s\n", host)
}

// executeWithRedirects executes the request with redirect handling.
func (e *Executor) executeWithRedirects(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, error) {
	maxRedirects := 5
	var redirectTrace []string

	// Determine redirect policy based on verb
	shouldFollow := false
	isWriteVerb := plan.Method == "POST" || plan.Method == "PUT" || plan.Method == "PATCH" || plan.Method == "DELETE"

	if plan.Follow == "smart" {
		// Smart follow: only follow 307/308 for write verbs
		shouldFollow = true
	} else {
		// Default: read and save follow, write verbs don't
		if plan.Verb == types.VerbRead || plan.Verb == types.VerbSave {
			shouldFollow = true
		} else if isWriteVerb {
			shouldFollow = false
		} else {
			// Other verbs (watch, inspect) don't follow by default
			shouldFollow = false
		}
	}

	if !shouldFollow {
		resp, err := e.client.Do(req)
		if err == nil && isWriteVerb && (resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303) {
			redirectTrace = append(redirectTrace, fmt.Sprintf("Advisory: %d redirect for write verb, not following", resp.StatusCode))
		}
		return resp, redirectTrace, err
	}

	// Follow redirects
	redirects := 0
	client := *e.client
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if redirects >= maxRedirects {
			return fmt.Errorf("stopped after %d redirects", maxRedirects)
		}

		// For smart follow with write verbs, only follow 307/308
		if plan.Follow == "smart" && isWriteVerb {
			statusCode := via[len(via)-1].Response.StatusCode
			if statusCode != 307 && statusCode != 308 {
				return fmt.Errorf("write verb: not following %d redirect (use 307/308)", statusCode)
			}
		}

		redirects++
		statusCode := via[len(via)-1].Response.StatusCode
		redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", statusCode, req.Method, req.URL.String()))
		return nil
	}

	resp, err := client.Do(req)
	return resp, redirectTrace, err
}

// readAndDecompress reads and decompresses the response body.
func (e *Executor) readAndDecompress(resp *http.Response) ([]byte, bool, error) {
	body := resp.Body
	decompressed := false

	// Check if compressed
	encoding := resp.Header.Get("Content-Encoding")
	if encoding == "gzip" {
		reader, err := gzip.NewReader(body)
		if err != nil {
			return nil, false, fmt.Errorf("failed to create gzip reader: %w", err)
		}
		defer reader.Close()
		body = reader
		decompressed = true
	} else if encoding == "br" {
		// Brotli decompression would require a library
		// For now, just read as-is
		// TODO: Add brotli support
	}

	data, err := io.ReadAll(body)
	return data, decompressed, err
}

// runExpectChecks runs expectation checks on the response.
func (e *Executor) runExpectChecks(resp *http.Response, body []byte, checks []types.ExpectCheck) error {
	for _, check := range checks {
		if err := e.runExpectCheck(resp, body, check); err != nil {
			return err
		}
	}
	return nil
}

// runExpectCheck runs a single expectation check.
func (e *Executor) runExpectCheck(resp *http.Response, body []byte, check types.ExpectCheck) error {
	switch check.Type {
	case "status":
		expected := check.Value
		actual := fmt.Sprintf("%d", resp.StatusCode)
		if actual != expected {
			return fmt.Errorf("expected status %s, got %s", expected, actual)
		}

	case "header":
		actual := resp.Header.Get(check.Name)
		if actual != check.Value {
			return fmt.Errorf("expected header %s=%s, got %s", check.Name, check.Value, actual)
		}

	case "contains":
		if !strings.Contains(string(body), check.Value) {
			return fmt.Errorf("expected body to contain %q", check.Value)
		}

	case "jsonpath":
		// Simple JSON path extraction (basic implementation)
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			return fmt.Errorf("failed to parse JSON: %w", err)
		}
		// TODO: Implement proper JSONPath evaluation
		// For now, just check if JSON is valid
		_ = data

	case "matches":
		matched, err := regexp.MatchString(check.Regex, string(body))
		if err != nil {
			return fmt.Errorf("invalid regex: %w", err)
		}
		if !matched {
			return fmt.Errorf("body does not match regex %q", check.Regex)
		}

	default:
		return fmt.Errorf("unknown expect check type: %s", check.Type)
	}

	return nil
}

// printMeta prints metadata to stderr.
func (e *Executor) printMeta(resp *http.Response, url string, bodySize int, decompressed bool) {
	fmt.Fprintf(os.Stderr, "HTTP %d\n", resp.StatusCode)
	fmt.Fprintf(os.Stderr, "URL: %s\n", url)
	fmt.Fprintf(os.Stderr, "Size: %d bytes\n", bodySize)
	if ct := resp.Header.Get("Content-Type"); ct != "" {
		fmt.Fprintf(os.Stderr, "Content-Type: %s\n", ct)
	}
}

// writeOutput formats and writes output to stdout.
func (e *Executor) writeOutput(body []byte, output *planner.OutputPlan) error {
	if output == nil {
		// Default: raw output
		_, err := os.Stdout.Write(body)
		return err
	}

	switch output.Format {
	case "json":
		// Pretty print JSON
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			// Not JSON, output as-is
			_, err := os.Stdout.Write(body)
			return err
		}
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)

	case "text":
		// Output as text
		_, err := os.Stdout.Write(body)
		return err

	case "raw":
		// Raw output
		_, err := os.Stdout.Write(body)
		return err

	case "csv":
		// CSV output (basic - would need proper CSV parsing)
		_, err := os.Stdout.Write(body)
		return err

	default:
		// Default: raw
		_, err := os.Stdout.Write(body)
		return err
	}
}

// saveToFile saves the response body to a file.
func (e *Executor) saveToFile(body io.Reader, destination string) error {
	// Create directory if needed
	dir := filepath.Dir(destination)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Create file
	file, err := os.Create(destination)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Copy response body to file
	_, err = io.Copy(file, body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// getInsecureTLSConfig returns an insecure TLS config.
func getInsecureTLSConfig() *tls.Config {
	return &tls.Config{
		InsecureSkipVerify: true,
	}
}

// ExecuteWithResponse executes an HTTP request and returns the response body as a string.
// This is useful for TUI mode where we need to capture and format the response.
func (e *Executor) ExecuteWithResponse(plan *planner.ExecutionPlan) (string, error) {
	// Build request URL with query parameters
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return "", fmt.Errorf("failed to build body: %w", err)
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Execute request
	resp, _, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and decompress response body
	bodyBytes, _, err := e.readAndDecompress(resp)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(bodyBytes), nil
}

----
internal/session/session.go
// Package session manages HTTP sessions (cookies and tokens) per host.
package session

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Session represents a stored session for a host.
type Session struct {
	Host          string            `json:"host"`
	Cookies       map[string]string `json:"cookies,omitempty"`
	Authorization string            `json:"authorization,omitempty"` // Bearer token
}

var (
	stateDir     string
	stateDirOnce sync.Once
)

// getStateDir returns the user state directory for storing sessions.
func getStateDir() string {
	stateDirOnce.Do(func() {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to current directory
			stateDir = ".req"
			return
		}
		stateDir = filepath.Join(homeDir, ".config", "req")
	})
	return stateDir
}

// ensureStateDir ensures the state directory exists with proper permissions.
func ensureStateDir() error {
	dir := getStateDir()
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}
	return nil
}

// getSessionPath returns the file path for a host's session.
func getSessionPath(host string) (string, error) {
	if err := ensureStateDir(); err != nil {
		return "", err
	}
	// Sanitize host name for filename
	safeHost := strings.ReplaceAll(host, ":", "_")
	safeHost = strings.ReplaceAll(safeHost, "/", "_")
	return filepath.Join(getStateDir(), fmt.Sprintf("session_%s.json", safeHost)), nil
}

// LoadSession loads a session for the given host.
func LoadSession(host string) (*Session, error) {
	path, err := getSessionPath(host)
	if err != nil {
		return nil, err
	}

	// Check file permissions - refuse to load if group or world readable
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // No session exists
		}
		return nil, fmt.Errorf("failed to stat session file: %w", err)
	}

	mode := info.Mode().Perm()
	// Check if group or others have read permission (044, 004, or any combination)
	if mode&0044 != 0 {
		return nil, fmt.Errorf("session file %s has insecure permissions (%s): group or world readable, refusing to load", path, mode.String())
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read session: %w", err)
	}

	var session Session
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, fmt.Errorf("failed to parse session: %w", err)
	}

	return &session, nil
}

// SaveSession saves a session for the given host.
func SaveSession(session *Session) error {
	path, err := getSessionPath(session.Host)
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal session: %w", err)
	}

	// Write with strict permissions (0600)
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write session: %w", err)
	}

	return nil
}

// DeleteSession deletes a session for the given host.
func DeleteSession(host string) error {
	path, err := getSessionPath(host)
	if err != nil {
		return err
	}

	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil // Already deleted
		}
		return fmt.Errorf("failed to delete session: %w", err)
	}

	return nil
}

// ExtractHost extracts the host from a URL.
func ExtractHost(urlStr string) (string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}
	return u.Host, nil
}

// UpdateSessionFromResponse updates a session from an HTTP response.
// Captures Set-Cookie headers and access_token from JSON body.
func UpdateSessionFromResponse(host string, setCookies []string, body []byte) (*Session, error) {
	session, err := LoadSession(host)
	if err != nil {
		return nil, err
	}

	if session == nil {
		session = &Session{
			Host:    host,
			Cookies: make(map[string]string),
		}
	}

	// Parse Set-Cookie headers
	for _, cookieHeader := range setCookies {
		// Simple cookie parsing (just get name=value part)
		parts := strings.Split(cookieHeader, ";")
		if len(parts) > 0 {
			cookiePart := strings.TrimSpace(parts[0])
			eqIdx := strings.Index(cookiePart, "=")
			if eqIdx > 0 {
				name := cookiePart[:eqIdx]
				value := cookiePart[eqIdx+1:]
				session.Cookies[name] = value
			}
		}
	}

	// Try to extract access_token from JSON body
	if len(body) > 0 {
		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err == nil {
			if token, ok := jsonData["access_token"].(string); ok && token != "" {
				session.Authorization = "Bearer " + token
			}
		}
	}

	return session, nil
}

// ListSessions lists all stored sessions.
func ListSessions() ([]string, error) {
	dir := getStateDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read state directory: %w", err)
	}

	var hosts []string
	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "session_") && strings.HasSuffix(entry.Name(), ".json") {
			// Extract host from filename
			host := strings.TrimPrefix(entry.Name(), "session_")
			host = strings.TrimSuffix(host, ".json")
			host = strings.ReplaceAll(host, "_", ":")
			hosts = append(hosts, host)
		}
	}

	return hosts, nil
}

// RedactSession creates a redacted version of a session for display.
func RedactSession(session *Session) *Session {
	redacted := &Session{
		Host:          session.Host,
		Cookies:       make(map[string]string),
		Authorization: "",
	}

	// Redact cookies (show only names)
	for name := range session.Cookies {
		redacted.Cookies[name] = "***"
	}

	// Redact authorization
	if session.Authorization != "" {
		redacted.Authorization = "Bearer ***"
	}

	return redacted
}


----
internal/tui/app.go
// Package tui provides an interactive terminal user interface for req.
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/adammpkins/req/internal/tui/views"
)

// Launch starts the TUI application.
func Launch() error {
	p := tea.NewProgram(NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run TUI: %w", err)
	}
	return nil
}

// Model represents the application state.
type Model struct {
	view View
}

// NewModel creates a new TUI model.
func NewModel() Model {
	return Model{
		view: views.NewBuilderView(),
	}
}

// Init initializes the model.
func (m Model) Init() tea.Cmd {
	// WindowSizeMsg will be sent automatically by bubbletea
	return m.view.Init()
}

// Update handles messages and updates the model.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		// Pass window size to view
		var cmd tea.Cmd
		m.view, cmd = m.view.Update(msg)
		return m, cmd
	}

	var cmd tea.Cmd
	m.view, cmd = m.view.Update(msg)
	return m, cmd
}

// View renders the current view.
func (m Model) View() string {
	return m.view.View()
}

// View represents a TUI view (exported from views package).
type View = views.View


----
internal/tui/views/builder.go
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("62")).
			Padding(1, 2)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Padding(1, 2).
			Width(80)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46")).
			Padding(1, 2).
			Width(80)

	commandStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252")).
			Padding(1, 2).
			Width(80)

	// JSON syntax highlighting styles
	jsonKeyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true)

	jsonStringStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46"))

	jsonNumberStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("220"))

	jsonBoolStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("213"))

	jsonNullStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			Italic(true)

	jsonPunctStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252"))

	outputStyle = lipgloss.NewStyle().
			Padding(1, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("62"))
)

// View represents a TUI view interface.
type View interface {
	Init() tea.Cmd
	Update(msg tea.Msg) (View, tea.Cmd)
	View() string
}

// BuilderView is an interactive command builder.
type BuilderView struct {
	form         *huh.Form
	executed     bool
	response     string
	responseBody string
	formattedBody string
	err          error
	verb         string
	url          string
	execute      bool
	width        int
	height       int
	viewport     viewport.Model
}

// NewBuilderView creates a new builder view.
func NewBuilderView() View {
	vp := viewport.New(80, 20) // default width and height
	b := &BuilderView{
		width:    80, // default width
		height:   20, // default height
		viewport: vp,
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Verb").
				Description("Select the action to perform").
				Options(
					huh.NewOption("read - Read a resource (GET)", "read"),
					huh.NewOption("save - Save a resource to file (GET)", "save"),
					huh.NewOption("send - Send data (POST)", "send"),
				).
				Value(&b.verb).
				Key("verb"),

			huh.NewInput().
				Title("URL").
				Description("Enter the target URL").
				Placeholder("https://api.example.com/users").
				Value(&b.url).
				Key("url"),

			huh.NewConfirm().
				Title("Execute immediately?").
				Description("Execute the command when form is complete").
				Value(&b.execute).
				Key("execute"),
		),
	)

	b.form = form
	return b
}

// Init initializes the view.
func (b *BuilderView) Init() tea.Cmd {
	return b.form.Init()
}

// Update handles messages.
func (b *BuilderView) Update(msg tea.Msg) (View, tea.Cmd) {
	var cmds []tea.Cmd

	// Handle window size messages first
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		b.width = msg.Width
		b.height = msg.Height
		if b.width == 0 {
			b.width = 80 // default width
		}
		if b.height == 0 {
			b.height = 20 // default height
		}
		// Update viewport size
		b.updateViewportSize()
	}

	// Handle keyboard input
	switch msg := msg.(type) {
	case tea.KeyMsg:
		key := msg.String()
		
		// If we have output to scroll, handle scrolling keys first
		if b.formattedBody != "" {
			// Check if it's a scrolling key
			switch key {
			case "up", "k", "pgup":
				b.viewport.LineUp(1)
				return b, nil
			case "down", "j", "pgdown":
				b.viewport.LineDown(1)
				return b, nil
			case "home":
				b.viewport.GotoTop()
				return b, nil
			case "end":
				b.viewport.GotoBottom()
				return b, nil
			case "ctrl+u":
				b.viewport.LineUp(b.viewport.Height / 2)
				return b, nil
			case "ctrl+d":
				b.viewport.LineDown(b.viewport.Height / 2)
				return b, nil
			case "esc":
				return b, tea.Quit
			}
		} else {
			// No output, just handle quit
			switch key {
			case "esc":
				return b, tea.Quit
			}
		}
	}

	// Update form (only if not a scrolling key when we have output)
	form, cmd := b.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		b.form = f
		cmds = append(cmds, cmd)
	}

	// Handle messages from command execution
	switch msg := msg.(type) {
	case ErrorMsg:
		b.err = msg.Err
		b.executed = false
		b.responseBody = ""
		b.formattedBody = ""
		b.viewport.SetContent("")
	case SuccessMsg:
		b.response = msg.Message
		b.responseBody = msg.ResponseBody
		b.err = nil
		// Format the response body
		b.updateFormattedBody()
	}
	
	// Handle viewport updates for other messages (like mouse wheel, etc.)
	if b.formattedBody != "" {
		vp, cmd := b.viewport.Update(msg)
		b.viewport = vp
		if cmd != nil {
			cmds = append(cmds, cmd)
		}
	}

	// Check if form is complete and should execute
	if b.form.State == huh.StateCompleted {
		if !b.executed && b.verb != "" && b.url != "" {
			// Values are already bound to b.verb, b.url, and b.execute via Value() in form creation
			// The bound variables are updated automatically when form fields change
			if b.execute {
				b.executed = true
				cmds = append(cmds, b.executeCommand())
			} else {
				// Form completed but execute was false - show message
				b.response = "Command built but not executed. Press 'esc' to exit."
			}
		}
	}

	return b, tea.Batch(cmds...)
}

// executeCommand executes the built command.
func (b *BuilderView) executeCommand() tea.Cmd {
	return func() tea.Msg {
		// Build command string
		cmdStr := fmt.Sprintf("%s %s", b.verb, b.url)
		
		// Parse command
		cmd, err := parser.Parse(cmdStr)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Plan execution
		plan, err := planner.Plan(cmd)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Execute
		executor, err := runtime.NewExecutor(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Capture response body for TUI display
		responseBody, err := executor.ExecuteWithResponse(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		return SuccessMsg{
			Message:      "Command executed successfully",
			ResponseBody: responseBody,
		}
	}
}

// View renders the view.
func (b *BuilderView) View() string {
	var s strings.Builder

	s.WriteString(titleStyle.Render("req - Interactive Command Builder"))
	s.WriteString("\n\n")

	if b.err != nil {
		s.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", b.err)))
		s.WriteString("\n\n")
	}

	if b.response != "" {
		s.WriteString(successStyle.Render(b.response))
		s.WriteString("\n\n")
	}

	// Display response body with formatting (using viewport for scrolling)
	if b.formattedBody != "" {
		// Calculate available width and height for viewport
		contentWidth := b.width - 6 // Account for border and padding
		if contentWidth < 20 {
			contentWidth = 20 // Minimum width
		}
		
		// Calculate available height (account for header, success message, form, command line, instructions)
		// Rough estimate: title ~3, success ~2, form ~varies, command ~2, instructions ~1 = ~8-10 lines
		// Reserve some space for the form and other UI elements
		availableHeight := b.height - 15 // Reserve space for other UI elements
		if availableHeight < 5 {
			availableHeight = 5 // Minimum height
		}
		
		// Update viewport dimensions if needed
		b.updateViewportSize()
		
		// Render viewport with border
		// The viewport handles its own height, so we just need to wrap it with the border style
		viewportContent := b.viewport.View()
		// Use the viewport's actual dimensions for the border
		s.WriteString(outputStyle.Width(contentWidth + 4).Render(viewportContent))
		s.WriteString("\n\n")
	}

	s.WriteString(b.form.View())
	
	// Show current values when form is completed
	if b.form.State == huh.StateCompleted {
		s.WriteString("\n\n")
		if b.verb != "" && b.url != "" {
			cmdText := fmt.Sprintf("Command: %s %s", b.verb, b.url)
			// Wrap the command text to fit terminal width
			width := b.width
			if width == 0 {
				width = 80 // default width
			}
			wrapped := wrapText(cmdText, width)
			s.WriteString(commandStyle.Render(wrapped))
			s.WriteString("\n")
			if b.response != "" {
				s.WriteString("\n")
			}
		}
	}
	
	s.WriteString("\n")
	if b.formattedBody != "" {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit, ↑/↓ to scroll, pgup/pgdn for page scroll\n")
	} else {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit\n")
	}

	return s.String()
}

// ErrorMsg represents an error message.
type ErrorMsg struct {
	Err error
}

// SuccessMsg represents a success message.
type SuccessMsg struct {
	Message      string
	ResponseBody string
}

// wrapText wraps text to the specified width, breaking at word boundaries.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}
	
	var result strings.Builder
	words := strings.Fields(text)
	currentLine := ""
	
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		if len(testLine) > width {
			if currentLine != "" {
				result.WriteString(currentLine)
				result.WriteString("\n")
				currentLine = word
			} else {
				// Word is longer than width, just add it
				result.WriteString(word)
				result.WriteString("\n")
				currentLine = ""
			}
		} else {
			currentLine = testLine
		}
	}
	
	if currentLine != "" {
		result.WriteString(currentLine)
	}
	
	return result.String()
}

// updateFormattedBody formats the response body and updates the viewport content.
func (b *BuilderView) updateFormattedBody() {
	if b.responseBody == "" {
		b.formattedBody = ""
		b.viewport.SetContent("")
		return
	}
	
	// Calculate available width for content
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	// Format the response
	formatted := formatResponse(b.responseBody, contentWidth)
	b.formattedBody = formatted
	
	// Update viewport content
	b.viewport.SetContent(formatted)
	b.viewport.GotoTop() // Start at the top
}

// updateViewportSize updates the viewport dimensions based on available space.
func (b *BuilderView) updateViewportSize() {
	if b.responseBody == "" {
		return
	}
	
	// Calculate available width and height
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	availableHeight := b.height - 15 // Reserve space for other UI elements
	if availableHeight < 5 {
		availableHeight = 5 // Minimum height
	}
	
	// Update viewport dimensions
	b.viewport.Width = contentWidth
	b.viewport.Height = availableHeight
	
	// If content is already set, ensure it's properly sized
	if b.formattedBody != "" {
		b.viewport.SetContent(b.formattedBody)
	}
}

// formatResponse formats the response body with syntax highlighting for JSON.
func formatResponse(body string, width int) string {
	// Try to parse as JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(body), &jsonData); err == nil {
		// It's valid JSON, format it with syntax highlighting
		return formatJSON(body, width)
	}

	// Not JSON, return as-is with word wrapping
	return wrapText(body, width)
}

// formatJSON formats JSON with syntax highlighting using lipgloss.
func formatJSON(jsonStr string, width int) string {
	// First, pretty-print the JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(jsonStr), &jsonData); err != nil {
		return jsonStr // Return original if parsing fails
	}

	prettyJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return jsonStr // Return original if formatting fails
	}

	// Now apply syntax highlighting
	lines := strings.Split(string(prettyJSON), "\n")
	var formattedLines []string

	for _, line := range lines {
		formattedLine := highlightJSONLine(line)
		formattedLines = append(formattedLines, formattedLine)
	}

	return strings.Join(formattedLines, "\n")
}

// highlightJSONLine applies syntax highlighting to a single line of JSON.
func highlightJSONLine(line string) string {
	// This is a simple JSON highlighter that handles common cases
	// For a more robust solution, consider using a proper JSON tokenizer
	
	result := ""
	i := 0
	
	for i < len(line) {
		char := line[i]
		
		// Skip whitespace
		if char == ' ' || char == '\t' {
			result += string(char)
			i++
			continue
		}
		
		// Handle string literals
		if char == '"' {
			end := i + 1
			escaped := false
			for end < len(line) {
				if line[end] == '\\' && !escaped {
					escaped = true
					end++
				} else if line[end] == '"' && !escaped {
					end++
					// Check if this is a key (followed by :)
					isKey := end < len(line) && line[end] == ':'
					str := line[i:end]
					if isKey {
						result += jsonKeyStyle.Render(str)
					} else {
						result += jsonStringStyle.Render(str)
					}
					i = end
					break
				} else {
					escaped = false
					end++
				}
			}
			if end >= len(line) {
				// Unterminated string, just add it
				result += jsonStringStyle.Render(line[i:])
				break
			}
			continue
		}
		
		// Handle numbers
		if (char >= '0' && char <= '9') || char == '-' {
			start := i
			for i < len(line) && ((line[i] >= '0' && line[i] <= '9') || 
				line[i] == '.' || line[i] == 'e' || line[i] == 'E' || 
				line[i] == '+' || line[i] == '-' || line[i] == 'i' || 
				line[i] == 'n' || line[i] == 'f') {
				i++
			}
			result += jsonNumberStyle.Render(line[start:i])
			continue
		}
		
		// Handle boolean and null
		if strings.HasPrefix(line[i:], "true") {
			result += jsonBoolStyle.Render("true")
			i += 4
			continue
		}
		if strings.HasPrefix(line[i:], "false") {
			result += jsonBoolStyle.Render("false")
			i += 5
			continue
		}
		if strings.HasPrefix(line[i:], "null") {
			result += jsonNullStyle.Render("null")
			i += 4
			continue
		}
		
		// Handle punctuation
		if char == '{' || char == '}' || char == '[' || char == ']' || 
		   char == ',' || char == ':' {
			result += jsonPunctStyle.Render(string(char))
			i++
			continue
		}
		
		// Default: just add the character
		result += string(char)
		i++
	}
	
	return result
}

----
internal/types/command.go
// Package types provides shared types and enums used across the req package.
package types

import "time"

// Verb represents the action verb in a req command.
type Verb string

const (
	VerbRead         Verb = "read"
	VerbSave         Verb = "save"
	VerbSend         Verb = "send"
	VerbUpload       Verb = "upload"
	VerbWatch        Verb = "watch"
	VerbInspect      Verb = "inspect"
	VerbAuthenticate Verb = "authenticate"
	VerbSession      Verb = "session"
)

// Command represents a parsed req command AST.
type Command struct {
	Verb    Verb
	Target  Target
	Clauses []Clause
	// For session verb, subcommand (show, clear, use)
	SessionSubcommand string
}

// Target represents the URL or resource being acted upon.
type Target struct {
	URL string
}

// Clause represents a modifier clause in the command.
// This is a sum type that will be expanded as we add more clause types.
type Clause interface {
	clause()
}

// WithClause represents a "with=" clause for request body.
type WithClause struct {
	Value    string // inline value, file path, or "-" for stdin
	Type     string // json, form, etc. (inferred if empty)
	IsFile   bool   // true if value starts with @
	IsStdin  bool   // true if value is @-
}

func (WithClause) clause() {}

// HeadersClause represents a "headers=" clause.
type HeadersClause struct {
	Headers map[string]string
}

func (HeadersClause) clause() {}

// ParamsClause represents a "params=" clause for query parameters.
type ParamsClause struct {
	Params map[string]string
}

func (ParamsClause) clause() {}

// AsClause represents an "as=" clause for output format.
type AsClause struct {
	Format string // json, csv, text, raw
}

func (AsClause) clause() {}

// ToClause represents a "to=" clause for destination.
type ToClause struct {
	Destination string
}

func (ToClause) clause() {}

// UsingClause represents a "using=" clause for HTTP method override.
type UsingClause struct {
	Method string // GET, POST, PUT, PATCH, DELETE, etc.
}

func (UsingClause) clause() {}

// RetryClause represents a "retry=" clause.
type RetryClause struct {
	Count int
}

func (RetryClause) clause() {}

// BackoffClause represents a "backoff=" clause.
type BackoffClause struct {
	Min time.Duration
	Max time.Duration
}

func (BackoffClause) clause() {}

// TimeoutClause represents a "timeout=" clause.
type TimeoutClause struct {
	Duration time.Duration
}

func (TimeoutClause) clause() {}

// ProxyClause represents a "proxy=" clause.
type ProxyClause struct {
	URL string
}

func (ProxyClause) clause() {}

// PickClause represents a "pick=" clause for JSON path selection.
type PickClause struct {
	Path string // JSONPath expression
}

func (PickClause) clause() {}

// EveryClause represents an "every=" clause for polling.
type EveryClause struct {
	Interval time.Duration
}

func (EveryClause) clause() {}

// UntilClause represents an "until=" clause for conditional polling.
type UntilClause struct {
	Predicate string
}

func (UntilClause) clause() {}

// FieldClause represents a "field=" clause for multipart uploads.
type FieldClause struct {
	Name  string
	Value string
}

func (FieldClause) clause() {}

// VerboseClause represents the "verbose" flag.
type VerboseClause struct{}

func (VerboseClause) clause() {}

// ResumeClause represents the "resume" flag for resumable downloads.
type ResumeClause struct{}

func (ResumeClause) clause() {}

// IncludeClause represents an "include=" clause for headers, params, and cookies.
type IncludeClause struct {
	Items []IncludeItem
}

func (IncludeClause) clause() {}

// IncludeItem represents a single item in an include clause.
type IncludeItem struct {
	Type  string // "header", "param", "cookie"
	Name  string // header name, param key, or cookie key
	Value string // header value, param value, or cookie value
}

// AttachClause represents an "attach=" clause for multipart form data.
type AttachClause struct {
	Parts    []AttachPart
	Boundary string // optional explicit boundary
}

func (AttachClause) clause() {}

// AttachPart represents a single part in an attach clause.
type AttachPart struct {
	Name     string // required
	FilePath string // file=@path (mutually exclusive with Value)
	Value    string // value=... (mutually exclusive with FilePath)
	Filename string // optional filename
	Type     string // optional Content-Type
}

// ExpectClause represents an "expect=" clause for response assertions.
type ExpectClause struct {
	Checks []ExpectCheck
}

func (ExpectClause) clause() {}

// ExpectCheck represents a single assertion check.
type ExpectCheck struct {
	Type  string // "status", "header", "contains", "jsonpath", "matches"
	Name  string // for header checks, the header name
	Value string // the value to check against
	Path  string // for jsonpath, the JSONPath expression
	Regex string // for matches, the regex pattern
}

// FollowClause represents a "follow=" clause for redirect policy.
type FollowClause struct {
	Policy string // "smart" or empty for default
}

func (FollowClause) clause() {}

// UnderClause represents an "under=" clause for timeout or size limit.
type UnderClause struct {
	Duration time.Duration // if it's a duration
	Size     int64         // if it's a size (in bytes)
	IsSize   bool          // true if it's a size limit, false if duration
}

func (UnderClause) clause() {}

// ViaClause represents a "via=" clause for proxy URL.
type ViaClause struct {
	URL string
}

func (ViaClause) clause() {}

// InsecureClause represents an "insecure=" clause (updated to support true/false).
type InsecureClause struct {
	Value bool // true or false
}

func (InsecureClause) clause() {}


----
output.txt
The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encountered. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
.cursor/rules/grammar.mdc
# .cursor/rules/grammar.mdc

# req grammar - v0.1 specification

This documents the language. It is a DSL that reads like a sentence and runs in a shell.

## Command shape

    req <verb> <url> [clauses...]

Clauses are key=value pairs where keys are semantic words, not config words.

Order of clauses is free.

Unknown clause keys are errors.

## Verbs

- read - GET, print to stdout
- save - GET, write to file via to=
- send - default GET, POST if with= present
- upload - POST when attach= or with= present, else error
- watch - GET with SSE or polling
- inspect - HEAD only
- authenticate - login and store session state
- session show, session clear, session use - session management

## Clauses

| Clause     | Meaning                                     | Repeatable | Example                                                                 |
|-----------|---------------------------------------------|------------|-------------------------------------------------------------------------|
| using=    | HTTP method override                         | no         | using=PUT                                                               |
| include=  | Add headers, params, cookies                 | yes        | include='header: Authorization: Bearer token; param: q=search query'     |
| with=     | Request body                                 | no         | with=@user.json or with='{"name":"Adam"}'                               |
| expect=   | Assertions on response                       | no         | expect=status:200, header:Content-Type=application/json, contains:"ok"  |
| as=       | Output format for stdout                     | no         | as=json                                                                 |
| to=       | Destination path                             | no         | to=out.json                                                             |
| retry=    | Retry attempts for transient errors          | no         | retry=3                                                                 |
| under=    | Timeout or size limit                        | no         | under=30s or under=10MB                                                 |
| via=      | Proxy URL                                    | no         | via=http://proxy:8080                                                   |
| attach=   | Multipart parts for upload or send           | yes        | attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'    |
| follow=   | Redirect policy for write verbs              | no         | follow=smart                                                            |
| insecure= | Disable TLS verification for this request    | no         | insecure=true                                                           |

### include= value grammar

- One include clause may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - header: Name: Value
  - param: key=value
  - cookie: key=value

Merging
- Headers: keep all values for multi valued headers, else last wins.
- Params: repeated keys become repeated pairs in insertion order.
- Cookies: last value wins per cookie name.

Quoting
- If an item payload contains a semicolon, quote the value.
- Backslash escapes allowed inside quoted values for the quote char and backslash.

Errors
- Unknown tag before the first colon.
- Header without Name colon Value.
- Param or cookie missing equals.
- Unquoted semicolon inside an item payload.

Examples

    include='header: Accept: application/json, application/problem+json; q=0.9'
    include='param: q=search query; param: tag=ai; param: tag=ml'
    include='cookie: session=abc; cookie: prefs="a=1; b=2"'

### attach= value grammar

- One attach may contain multiple items separated by semicolons that are not inside quotes.
- Allowed item tags:
  - part: name=..., file=@path  or  part: name=..., value=...
  - Optional filename=...
  - Optional type=media/type
  - boundary: TOKEN optional

Validation
- name is required.
- exactly one of file or value is required.
- for file parts, @path must exist at execution time.

Header behavior
- Any attach= forces multipart Content-Type with a generated boundary.
- If user included a manual Content-Type, override it and print a one line note.

Examples

    attach='part: name=avatar, file=@./me.png, filename=me.png, type=image/png'
    attach='part: name=meta, value={"name":"adam"}'
    attach='part: name=file, file=@./a.png; part: name=meta, value=xyz'

### with= body modes

- Inline text or JSON.
- @file to read from file.
- @- to read from stdin.

Content type
- If Content-Type is not set and inline begins with "{" or "[", infer application/json and note on stderr.
- An explicit Content-Type header always overrides inference.

### expect= assertions

Single clause with comma separated checks. All must pass.

Supported checks
- status:200
- header:Content-Type=application/json
- contains:"text"
- jsonpath:"$.items[0].id"
- matches:"^OK\\b"

Exit codes
- 0 success and expectations passed.
- 3 request ok but an expectation failed.

Failure messages must be concise and specific.

### Redirects

- read and save follow up to 5 redirects by default.
- write verbs do not follow by default.
- follow=smart for writes follows only 307 and 308, up to 5 hops.
- On 301, 302, 303 for writes, do not follow and print an advisory.

### Compression

- If user did not set Accept-Encoding, send "Accept-Encoding: gzip, br".
- Auto decompress gzip or br before as= and expect=.
- Print a one line note when decompression occurs.

### TLS

- insecure=true disables certificate verification for this request only.
- Print one line warning on stderr.

### Sessions

authenticate
- Follows redirects.
- Captures Set-Cookie.
- If response is JSON with a top level access_token, store it as a Bearer token.
- Store per host under user state dir with strict perms.

Auto use
- Any request to a host with a stored session auto applies cookies and Authorization unless caller includes those explicitly.
- Print "Using session for <host>" when applied.

session verbs
- session show <host> prints redacted info. as=json prints machine friendly form.
- session clear <host> deletes state.
- session use <host> prints env stub for shell scoping.

### Method defaults

- read GET
- save GET
- send GET by default, POST if with= present
- upload POST when attach= present, else POST if with= present, else error
- watch GET
- inspect HEAD
- authenticate POST if with= present, else require using=

### Multiplicity and ordering

- Singletons: using, with, expect, as, to, retry, under, via, insecure, follow.
- Repeatable: include, attach.
- Clause order is free.
- Explicit include of Authorization or Cookie overrides session.

### Token and quoting model

- Parser consumes argv tokens as provided by the shell.
- Do not re split on spaces.
- Values containing semicolons must be quoted.
- Backslash escapes allowed inside quotes for the quote char and backslash.
- Environment variables are expanded by the shell before argv.

### Errors that must be loud and specific

- Unknown clause key.
- Duplicate singletons.
- include item with unknown tag or malformed payload.
- header item missing Name colon Value.
- param or cookie missing equals.
- unquoted semicolon in an item payload.
- attach part missing name, or missing both file and value, or providing both.
- URL parse failure.
- file path not found for with or attach.
- timeout or size limit exceeded.
- TLS error when insecure=false.

### Error message examples

Each error class must produce a specific, actionable message. Examples:

Unknown clause key

    $ req read https://example.com invalid=clause
    Error: parse error at position 2 (token: "invalid"): unknown clause

Duplicate singleton

    $ req read https://example.com with=test with=test2
    Error: parse error at position 3 (token: "with"): duplicate singleton clause 'with' (did you mean "remove duplicate 'with=' clause"?)

Unquoted semicolon in include

    $ req read https://example.com include='param: q=test;value'
    Error: parse error at position 2 (token: "include"): unquoted semicolon in include item

Malformed header (missing Name: Value)

    $ req read https://example.com include='header: InvalidHeader'
    Error: parse error at position 2 (token: "include"): header item missing Name: Value format

Missing equals in param or cookie

    $ req read https://example.com include='param: q'
    Error: parse error at position 2 (token: "include"): param missing equals

Attach part missing name

    $ req upload https://example.com attach='part: file=@test.png'
    Error: parse error at position 2 (token: "attach"): attach part missing name

Attach part with both file and value

    $ req upload https://example.com attach='part: name=test, file=@test.png, value=text'
    Error: parse error at position 2 (token: "attach"): attach part cannot have both file and value

File not found for with

    $ req send https://example.com with=@nonexistent.json
    Error: file not found: nonexistent.json

File not found for attach

    $ req upload https://example.com attach='part: name=file, file=@nonexistent.png'
    Error: file not found: nonexistent.png

### Output contracts

stdout
- Response body, formatted per as=.
- For save, write to file and keep stdout empty unless a specific mode says otherwise.

stderr
- Compact meta block: status, url, duration, bytes, content type.
- Notices: session use, decompression, redirect trace, TLS warning, multipart override note.
- Secrets redacted in meta lines.

### End to end examples

Read with params and header

    req read https://api.example.com/search \
      include='param: q=search query; header: X-Trace: 1' \
      as=json

Write JSON with auth and assertion

    req send https://api.example.com/users \
      using=POST \
      include='header: Authorization: Bearer $TOKEN' \
      with='{"name":"Adam"}' \
      expect=status:201, header:Content-Type=application/json \
      as=json

Multipart upload

    req upload https://api.example.com/upload \
      attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
      as=json

Authenticate then use session

    req authenticate https://api.example.com/login \
      using=POST \
      with='{"user":"adam","pass":"xyz"}'

    req read https://api.example.com/me as=json

Write with safe redirects

    req send https://api.example.com/endpoint \
      using=POST \
      with='{"a":1}' \
      follow=smart \
      expect=status:200

----
.cursor/rules/plan.mdc
---
alwaysApply: true
---
# /.cursor/plan.md

# req project plan - v0.1 to 90 percent curl coverage

This is a strict, test-driven plan. Each task has acceptance criteria. No code here. Use these goals as Cursor prompts.

## 1) Lock the surface grammar
- Enforce command shape: `req <verb> <url> [clauses...]`
- Allowed verbs: read, save, send, upload, watch, inspect, authenticate, session (show|clear|use)
- Allowed clauses: using=, include=, with=, expect=, as=, to=, retry=, under=, via=, attach=, follow=smart, insecure=true
- Clause order independent

Acceptance
- Unknown clause keys hard error with nearest suggestion
- Duplicate singletons hard error with fix hint
- Golden tests for valid and invalid examples
- `req help` prints the grammar summary

## 2) include= value grammar
Goal
- Implement semicolon separated items with explicit tags

Do
- Items: `header: Name: Value`, `param: key=value`, `cookie: key=value`
- Values may be quoted
- Multiple include= clauses allowed

Merging rules
- Headers: keep all for multi valued headers, else last wins
- Params: repeated keys become repeated pairs in order
- Cookies: last value wins

Acceptance
- Unit tests for quoting, embedded semicolons, repeated keys, error cases
- Golden tests for combined include payloads

## 3) attach= multipart grammar
Goal
- Repeatable clause for multipart form data

Do
- Items: `part: ...` and `boundary: ...`
- Part kvs: `name=`, one of `file=@path` or `value=`, optional `filename=`, optional `type=media/type`
- Validate name required, exactly one of file or value
- Any attach= forces `Content-Type: multipart/form-data; boundary=...`
- If user set Content-Type manually, override and print a one line note

Acceptance
- Unit tests for file, text, mixed parts, explicit boundary, malformed descriptors
- Integration test uses echo server to assert parts

## 4) follow=smart and insecure=true
Goal
- Add redirect and TLS toggles

Do
- follow accepts only `smart`
- insecure accepts `true` or `false`

Acceptance
- Unit tests parse both correctly and reject bad values

## 5) with= body modes and light inference
Goal
- Support inline, @file, @-

Do
- If Content-Type is not set and inline begins with `{` or `[`, infer `application/json` and log a one line note on stderr
- Explicit header always overrides inference

Acceptance
- Tests for inference, override, and no inference on file

## 6) expect= assertions
Goal
- Single clause with comma separated checks

Checks
- `status:200`
- `header:Content-Type=application/json`
- `contains:"text"`
- `jsonpath:"$.items[0].id"`
- `matches:"^OK\\b"`

Acceptance
- Exit 3 on any failure, with a concise diff-like message
- Tests for pass and fail cases

## 7) Verb defaults and method validation
Goal
- Map verbs to default methods and validate using=

Defaults
- read GET
- save GET
- send GET by default, POST if with= present
- upload POST if attach= or with= present, else error
- watch GET
- inspect HEAD
- authenticate default POST if with= present

Acceptance
- Tests for defaults and invalid combinations

## 8) Redirect policy
Goal
- Implement safe redirect rules

Rules
- read and save follow up to 5 by default
- write verbs do not follow by default
- follow=smart follows only 307 and 308 for writes, up to 5
- On 301, 302, 303 for writes, do not follow, print advisory

Acceptance
- Integration tests for 301, 302, 303, 307, 308 with and without smart
- Stderr shows compact trace

## 9) Transparent compression
Goal
- gzip and br on by default

Do
- Inject Accept-Encoding unless user set it
- Auto decompress before as= and expect=
- One line stderr note when decompressed

Acceptance
- gz and br tests, expect sees decoded text, user header respected

## 10) TLS control
Goal
- Implement insecure=true

Acceptance
- Self signed server fails normally, succeeds with insecure=true
- One line stderr warning: TLS verification disabled

## 11) Query param merging and URL assembly
Goal
- Merge URL params with include param items

Acceptance
- Repeated keys serialize in insertion order
- Proper percent encoding
- Existing URL params preserved and merged

## 12) Output control with as= and to=
Goal
- Finalize sinks and formatting

Do
- as=json, text, raw, csv
- to=PATH writes file. For save, derive filename from URL if needed
- stdout is body, stderr is compact meta with redaction

Acceptance
- Filename extraction, directory handling, percent decoding, meta block content

## 13) Sessions and authenticate
Goal
- Explicit session model

Do
- authenticate captures Set-Cookie and `access_token` from JSON
- Store per host in user state dir with strict perms
- Auto apply for matching host unless caller includes Authorization or Cookie
- Print `Using session for <host>` on use
- session show, session clear, session use implemented

Acceptance
- Integration tests for login, reuse, override, redaction, permission refusal

## 14) Multipart body construction
Goal
- Build body with generated boundary and proper part headers

Acceptance
- Echo server validates Content-Disposition, Content-Type, filenames and order
- Manual Content-Type overridden with a note

## 15) Errors, hints, exit codes
Goal
- Clear, specific failures

Acceptance
- Exit codes: 0 ok, 3 expect fail, 4 network, 5 grammar
- Hints for unquoted semicolons, missing equals, duplicate singletons, unknown clause, bad attach part

## 16) Help and explain
Goal
- Discoverability tools

Do
- `req help` prints grammar table and examples
- `req explain "<command>"` prints parsed plan without executing

Acceptance
- Golden tests for explain output

## 17) Cross shell quoting doc
Goal
- Portability guidance

Do
- Quoting cheat sheet for bash, zsh, fish, PowerShell
- Curl vs req mapping table for common tasks

Acceptance
- Docs included and examples parse in a simple parser smoke test

## 18) CI, golden, fixtures
Goal
- Stable test harness

Do
- Golden tests for parser and explain
- Local HTTP fixture: echo headers, cookies, query, gzip, br, 30x, multipart
- Run under race detector

Acceptance
- CI green across Go versions you support

## 19) Streaming and watch polish
Goal
- Memory efficient downloads and sensible watch output

Do
- Stream to file for save
- Watch prints timestamps on TTY, raw otherwise

Acceptance
- Large download uses low memory
- Watch behaves per TTY detection

## 20) README refresh
Goal
- Align docs with grammar

Do
- Replace stale examples with include, attach, expect forms
- Document redirect defaults and smart policy
- Add warning about insecure=true and shell history

Acceptance
- Doc snippets pass as golden examples

----
.github/ISSUE_TEMPLATE/bug_report.md
---
name: Bug Report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Description

A clear and concise description of what the bug is.

## Reproduction

**Command:**
```bash
req <your-command-here>
```

**Expected Output:**
```
<expected-output>
```

**Actual Output:**
```
<actual-output>
```

## Environment

- OS: [e.g., Linux, macOS, Windows]
- Architecture: [e.g., amd64, arm64]
- Version: [e.g., v0.1.0]
- Go version: [e.g., 1.23]

## Additional Context

Add any other context about the problem here, including:
- Error messages
- Stack traces (if applicable)
- Workarounds you've tried


----
.github/ISSUE_TEMPLATE/feature_request.md
---
name: Feature Request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Summary

A clear and concise description of the feature you'd like to see.

## Motivation

Why is this feature needed? What problem does it solve?

## Detailed Description

Describe the feature in detail:
- What should the command syntax look like?
- What should the output look like?
- Are there any edge cases to consider?

## Example Usage

```bash
req <example-command>
```

## Alternatives Considered

Describe any alternative solutions or features you've considered.

## Additional Context

Add any other context, mockups, or examples about the feature request here.


----
.github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Run tests with race detector
        run: make test
      
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          make vulncheck
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          args: --timeout=5m
  
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24']
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-${{ matrix.os }}
          path: bin/req
  
  windows:
    name: Windows Build
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build
        run: make build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: req-windows
          path: bin/req.exe

  grammar-drift:
    name: Grammar Drift Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      
      - name: Build binary
        run: make build
      
      - name: Run grammar drift tests
        run: go test -v ./tests -run 'TestGrammarDrift|TestBinaryHelpDrift'


----
.gitignore
# Binaries
bin/
req
req.exe

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
*.tar.gz
*.zip


----
.golangci.yml
# golangci-lint configuration with lean modern linter set
run:
  timeout: 5m
  tests: true

linters-settings:
  errcheck:
    check-type-assertions: true
    check-blank: true
  gocritic:
    enabled-tags:
      - diagnostic
  govet:
    check-shadowing: true
  misspell:
    locale: US
  nolintlint:
    allow-leading-space: true
    allow-unused: false
    require-explanation: false
    require-specific: false

linters:
  disable-all: true
  enable:
    - errcheck
    - gocritic
    - goimports
    - gosimple
    - govet
    - ineffassign
    - misspell
    - nolintlint
    - staticcheck

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
  max-issues-per-linter: 0
  max-same-issues: 0

----
.goreleaser.yml
# GoReleaser configuration for cross-platform releases
project_name: req

before:
  hooks:
    - go mod download

builds:
  - id: req
    main: ./cmd/req
    binary: req
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    goarm:
      - 6
      - 7
    ignore:
      - goos: windows
        goarch: arm64
    env:
      - CGO_ENABLED=0
    flags:
      - -trimpath
      - -ldflags=-s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.buildDate={{.Date}}

archives:
  - id: default
    builds:
      - req
    format_overrides:
      - goos: windows
        format: zip
    name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    files:
      - LICENSE
      - README.md

checksum:
  name_template: "{{ .ProjectName }}_{{ .Version }}_checksums.txt"

snapshot:
  name_template: "{{ .Tag }}-next"

changelog:
  sort: asc
  filters:
    exclude:
      - "^docs:"
      - "^test:"


----
LICENSE
MIT License

Copyright (c) 2025 Adam Perkins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


----
Makefile
.PHONY: build test lint package golden clean help

# Variables
BINARY_NAME=req
MAIN_PATH=./cmd/req
VERSION?=dev
BUILD_DIR=./bin
COMMIT=$(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE=$(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build the req binary
	@echo "Building $(BINARY_NAME)..."
	@mkdir -p $(BUILD_DIR)
ifeq ($(GOOS),windows)
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME).exe $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME).exe"
else
	@go build -trimpath -ldflags="-s -w -X main.version=$(VERSION) -X main.commit=$(COMMIT) -X main.buildDate=$(DATE)" -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_PATH)
	@echo "Binary built: $(BUILD_DIR)/$(BINARY_NAME)"
endif

test: ## Run tests with race detector
	@echo "Running tests..."
	@go test -race -cover -v ./...

test-golden: ## Run golden file tests
	@echo "Running golden tests..."
	@go test -v ./tests -run TestGolden

golden: ## Regenerate golden test files
	@echo "Regenerating golden files..."
	@go test ./tests -run TestGolden -update

lint: ## Run golangci-lint
	@echo "Running golangci-lint..."
	@golangci-lint run

lint-fix: ## Run golangci-lint with auto-fix
	@golangci-lint run --fix

vulncheck: ## Run govulncheck
	@echo "Running govulncheck..."
	@govulncheck ./...

package: ## Build release artifacts locally (requires goreleaser)
	@echo "Building release artifacts..."
	@goreleaser build --snapshot --clean

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@rm -rf $(BUILD_DIR)
	@go clean -cache

install: build ## Install binary to GOPATH/bin
	@go install $(MAIN_PATH)


----
README.md
# req

A semantic HTTP client written in Go that replaces traditional curl syntax with a natural, intent-based grammar.

## Overview

`req` is an HTTP client tool that focuses on:

- **Human-readable commands** (verbs + clauses)
- **Sensible defaults** (follow redirects, TLS verify, retries)
- **JSON/CSV/text awareness** with intelligent output
- **Watch mode** (poll or stream)
- **Session management** (authenticate and auto-apply)
- **Pretty diagnostics** and dry-run transparency

## Quick Start

```bash
# Read JSON from an API
req read https://api.example.com/users as=json

# Send JSON data
req send https://api.example.com/users with='{"name":"Adam"}'

# Send with headers and assertions
req send https://api.example.com/users \
  using=POST \
  include='header: Authorization: Bearer $TOKEN' \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json \
  as=json

# Save a file
req save https://example.com/file.zip to=file.zip

# Upload multipart form data
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png' \
  as=json

# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Use stored session automatically
req read https://api.example.com/me as=json
```

## Installation

```bash
go install github.com/adammpkins/req/cmd/req@latest
```

Or download a pre-built binary from the [Releases](https://github.com/adammpkins/req/releases) page.

## Grammar

The `req` command follows this grammar:

```
req <verb> <target> [clauses...]
```

### Verbs

- `read` - GET, print to stdout
- `save` - GET, write to file via to=
- `send` - default GET, POST if `with=` is present
- `upload` - POST when `attach=` or `with=` present, else error
- `watch` - GET with SSE or polling
- `inspect` - HEAD only
- `authenticate` - login and store session state
- `session` - session management (show, clear, use)

### Clauses

- `using=<method>` - HTTP method override
- `include=<items>` - Add headers, params, cookies (repeatable)
  - Format: `include='header: Name: Value; param: key=value; cookie: key=value'`
- `with=<body>` - Request body
  - Format: `with=@user.json` or `with='{"name":"Adam"}'`
  - JSON inference: Automatically sets Content-Type for JSON when inline starts with `{` or `[`
- `expect=<checks>` - Assertions on response
  - Format: `expect=status:200, header:Content-Type=application/json, contains:"ok"`
- `as=<format>` - Output format for stdout
- `to=<path>` - Destination path
- `retry=<count>` - Retry attempts for transient errors
- `under=<limit>` - Timeout or size limit
  - Format: `under=30s` or `under=10MB`
- `via=<url>` - Proxy URL
- `attach=<parts>` - Multipart parts for upload or send (repeatable)
  - Format: `attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'`
- `follow=<policy>` - Redirect policy for write verbs
  - Format: `follow=smart`
- `insecure=<bool>` - Disable TLS verification for this request
  - Format: `insecure=true`

## Examples

### Read JSON

```bash
req read https://api.example.com/users as=json
```

### Send JSON Data

```bash
req send https://api.example.com/users with='{"name":"Ada","email":"ada@example.com"}'
```

### Save a File

```bash
# Save with explicit filename
req save https://example.com/file.zip to=file.zip

# Save with auto-detected filename (extracts from URL)
req save https://example.com/file.zip

# Save to directory path
req save https://example.com/file.zip to=/tmp/file.zip
```

### With Headers, Params, and Cookies

```bash
# Using include clause
req read https://api.example.com/search \
  include='header: Authorization: Bearer $TOKEN; param: q=search query; cookie: session=abc123' \
  as=json
```

### With Assertions

```bash
req send https://api.example.com/users \
  using=POST \
  with='{"name":"Adam"}' \
  expect=status:201, header:Content-Type=application/json, contains:"id" \
  as=json
```

### Sessions

```bash
# Authenticate and store session
req authenticate https://api.example.com/login \
  using=POST \
  with='{"user":"adam","pass":"xyz"}'

# Session is automatically used for subsequent requests
req read https://api.example.com/me as=json

# Show stored session (redacted)
req session show api.example.com

# Show session in JSON format
req session show api.example.com as=json

# Clear session
req session clear api.example.com
```

### Redirects

```bash
# Read and save follow redirects by default (up to 5)
req read https://example.com/redirect

# Write verbs don't follow by default
req send https://api.example.com/create using=POST with='{"data":"value"}'

# Use smart follow for write verbs (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
```

### With Retry and Timeout

```bash
req read https://api.example.com/users retry=3 under=10s as=json
```

### Edge Cases

```bash
# Header with commas and q values (must be quoted)
req read https://api.example.com/search \
  include='header: Accept: application/json, application/problem+json; q=0.9' \
  as=json

# Cookie value containing semicolons (must be quoted)
req read https://api.example.com/search \
  include='cookie: prefs="a=1; b=2; c=3"' \
  as=json

# Multipart upload with file and text parts (Content-Type automatically overridden)
req upload https://api.example.com/upload \
  include='header: Content-Type: application/json' \
  attach='part: name=file, file=@avatar.png; part: name=meta, value={"name":"test"}' \
  as=json
# Note: Content-Type will be overridden to multipart/form-data

# Smart redirect on write verb (only follows 307/308)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}' \
  follow=smart
# Will follow 307/308 redirects, but not 301/302/303

# Write verb with 303 redirect (advisory printed, not followed)
req send https://api.example.com/create \
  using=POST \
  with='{"data":"value"}'
# If server returns 303, advisory message printed but redirect not followed
```

### Method Override

```bash
# Use PUT instead of POST
req send https://api.example.com/users/1 using=PUT with='{"name":"Updated"}'

# Use PATCH for partial updates
req send https://api.example.com/users/1 using=PATCH with='{"email":"new@example.com"}'

# Use HEAD to check headers without body
req read https://api.example.com/users using=HEAD
```

**Note:** The `using=` clause validates method-verb compatibility. For example, `read using=POST` will fail as `read` only allows GET, HEAD, or OPTIONS.

### Comparison with curl

| Task | curl | req |
|------|------|-----|
| **Basic GET with headers** | `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include='header: Authorization: Bearer $TOKEN'` |
| **Multipart upload** | `curl -F "file=@avatar.png" -F "name=test" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png; part: name=name, value=test'` |
| **Authenticated POST** | `curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $TOKEN" -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users using=POST include='header: Authorization: Bearer $TOKEN' with='{"name":"Adam"}'` |

### Dry Run

```bash
req read https://api.example.com/users as=json --dry-run
```

### Interactive TUI Mode

```bash
# Launch interactive TUI mode
req --tui

# Or run without arguments to launch TUI
req
```

The TUI mode provides:
- Interactive command builder with form-based input
- **Syntax-highlighted JSON output** with color-coded keys, values, and punctuation
- **Scrollable viewport** for long responses with keyboard navigation
- Pretty-printed JSON with automatic indentation
- Real-time command execution and response display

**Keyboard Controls:**
- `↑` / `↓` or `k` / `j` - Scroll line by line
- `pgup` / `pgdown` - Page scrolling
- `home` - Jump to top
- `end` - Jump to bottom
- `ctrl+u` / `ctrl+d` - Half-page scrolling
- `esc` - Quit TUI

## Security

### Shell History

**Warning:** Commands containing secrets (tokens, passwords) are stored in your shell history by default. Use environment variables to avoid exposing secrets:

```bash
# Bad: Token appears in shell history
req read https://api.example.com/users include='header: Authorization: Bearer secret-token-123'

# Good: Use environment variable
TOKEN="secret-token-123"
req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"
```

To prevent secrets from being saved to history:
- **Bash/Zsh:** Prefix command with a space (requires `HISTCONTROL=ignorespace` or `setopt HIST_IGNORE_SPACE`)
- **Fish:** Use `history --delete` after running commands with secrets
- **PowerShell:** Use `Set-PSReadlineOption -HistoryNoDuplicates` and manually edit history

### Session Files

Session files are stored in `~/.config/req/session_<host>.json` with permissions `0600` (owner read/write only).

**Security rules:**
- Session files are created with strict permissions (`0600`)
- If a session file has group or world readable permissions, `req` will refuse to load it
- Session files contain sensitive data (cookies, tokens) and should be protected
- Never commit session files to version control

To check session file permissions:
```bash
ls -l ~/.config/req/session_*.json
```

## Current Status

**v0.1** - Core functionality complete

- ✅ Command parsing with full grammar validation
- ✅ All clauses implemented (include, attach, expect, follow, insecure, etc.)
- ✅ Execution plan generation with verb defaults
- ✅ HTTP request execution with redirect handling
- ✅ Transparent compression (gzip, br)
- ✅ Session management (authenticate, session show/clear/use)
- ✅ Auto-apply sessions for matching hosts
- ✅ File downloads with automatic filename extraction
- ✅ Multipart form data support
- ✅ Response assertions (expect clause)
- ✅ Proper exit codes (0 success, 3 expect fail, 4 network, 5 grammar)
- ✅ Helpful error messages with suggestions
- ✅ Help and explain commands
- ✅ Interactive TUI mode
- ✅ JSON output formatting
- ✅ Stderr meta output with redaction

## Roadmap

- **v0.1** ✅ - Core functionality (current)
- **v0.2** - Watch mode with SSE and polling
- **v0.3** - JSONPath selection and filtering
- **v0.4** - Advanced retry and backoff strategies
- **v1.0** - Stability hardening and release candidates

## Contributing

Contributions are welcome! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

MIT License - see [LICENSE](LICENSE) file for details.


----
cmd/req/main.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/adammpkins/req/internal/grammar"
	"github.com/adammpkins/req/internal/output"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
	"github.com/adammpkins/req/internal/tui"
	"github.com/adammpkins/req/internal/types"
)

var (
	version   = "dev"
	commit    = "unknown"
	buildDate = "unknown"
)

func main() {
	var (
		showHelp    = flag.Bool("help", false, "Show help message")
		showVersion = flag.Bool("version", false, "Show version information")
		dryRun      = flag.Bool("dry-run", false, "Print execution plan without executing")
		tuiMode     = flag.Bool("tui", false, "Launch interactive TUI mode")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: req <verb> <target> [clauses...]\n\n")
		fmt.Fprintf(os.Stderr, "Verbs: read, save, send, upload, watch, inspect, authenticate, session\n\n")
		fmt.Fprintf(os.Stderr, "Examples:\n")
		fmt.Fprintf(os.Stderr, "  req read https://api.example.com/users as=json\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req send https://api.example.com/users using=PUT with='{\"name\":\"Ada\"}'\n")
		fmt.Fprintf(os.Stderr, "  req save https://example.com/file.zip to=file.zip\n\n")
		fmt.Fprintf(os.Stderr, "Flags:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	if *showHelp {
		flag.Usage()
		os.Exit(0)
	}

	if *showVersion {
		fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
		os.Exit(0)
	}

	// Launch TUI mode if requested
	if *tuiMode {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Get remaining args after flags
	args := flag.Args()

	// Remove any remaining flags from args (in case they appear after command args)
	filteredArgs := make([]string, 0, len(args))
	for _, arg := range args {
		if arg == "--help" || arg == "-help" || arg == "-h" {
			flag.Usage()
			os.Exit(0)
		}
		if arg == "--version" || arg == "-version" || arg == "-v" {
			fmt.Printf("req version %s (commit: %s, built: %s)\n", version, commit, buildDate)
			os.Exit(0)
		}
		if arg == "--dry-run" || arg == "-dry-run" {
			*dryRun = true
			continue
		}
		filteredArgs = append(filteredArgs, arg)
	}
	args = filteredArgs

	// If no args provided, launch TUI mode
	if len(args) == 0 {
		if err := tui.Launch(); err != nil {
			printError(err)
			os.Exit(1)
		}
		return
	}

	// Handle help command
	if len(args) > 0 && args[0] == "help" {
		printHelp()
		os.Exit(0)
	}

	// Handle explain command
	if len(args) > 0 && args[0] == "explain" {
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Usage: req explain \"<command>\"\n")
			os.Exit(5)
		}
		command := strings.Join(args[1:], " ")
		if err := explainCommand(command); err != nil {
			printError(err)
			os.Exit(5)
		}
		os.Exit(0)
	}

	// Join args into a single command string
	command := strings.Join(args, " ")

	// Parse the command
	cmd, err := parser.Parse(command)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar error
	}

	// Handle session commands specially
	if cmd.Verb == types.VerbSession {
		if err := handleSessionCommand(cmd); err != nil {
			printError(err)
			os.Exit(5)
		}
		return
	}

	// Plan the execution
	plan, err := planner.Plan(cmd)
	if err != nil {
		printError(err)
		os.Exit(5) // Grammar/planning error
	}

	// Output the plan (dry-run mode)
	if *dryRun {
		formatted, err := output.FormatPlan(plan)
		if err != nil {
			printError(fmt.Errorf("failed to format plan: %w", err))
			os.Exit(5)
		}
		fmt.Println(string(formatted))
		return
	}

	// Execute the plan
	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		printError(fmt.Errorf("failed to create executor: %w", err))
		os.Exit(5) // Grammar error
	}

	if err := executor.Execute(plan); err != nil {
		printError(err)
		// Check error type for exit code
		if execErr, ok := err.(*runtime.ExecutionError); ok {
			os.Exit(execErr.Code)
		}
		os.Exit(4) // Network error (default)
	}
}

// printError prints an error with helpful diagnostics.
func printError(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v\n", err)

	// Check if it's a ParseError with suggestions
	if parseErr, ok := err.(*parser.ParseError); ok && parseErr.Suggest != "" {
		fmt.Fprintf(os.Stderr, "Hint: Try using '%s' instead\n", parseErr.Suggest)
	}
}

// printHelp prints the grammar summary.
func printHelp() {
	fmt.Print(grammar.FormatHelp())
}

// explainCommand prints the parsed plan for a command without executing it.
func explainCommand(command string) error {
	cmd, err := parser.Parse(command)
	if err != nil {
		return err
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		return err
	}

	formatted, err := output.FormatPlan(plan)
	if err != nil {
		return fmt.Errorf("failed to format plan: %w", err)
	}

	fmt.Println(string(formatted))
	return nil
}

// handleSessionCommand handles session management commands.
func handleSessionCommand(cmd *types.Command) error {
	host, err := session.ExtractHost(cmd.Target.URL)
	if err != nil {
		return fmt.Errorf("invalid host: %w", err)
	}

	switch cmd.SessionSubcommand {
	case "show":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			fmt.Printf("No session found for %s\n", host)
			return nil
		}

		// Check if JSON output requested
		asJSON := false
		for _, clause := range cmd.Clauses {
			if asClause, ok := clause.(types.AsClause); ok && asClause.Format == "json" {
				asJSON = true
				break
			}
		}

		if asJSON {
			// Machine-friendly JSON output
			data, err := json.MarshalIndent(sess, "", "  ")
			if err != nil {
				return fmt.Errorf("failed to marshal session: %w", err)
			}
			fmt.Println(string(data))
		} else {
			// Human-readable redacted output
			redacted := session.RedactSession(sess)
			fmt.Printf("Session for %s:\n", redacted.Host)
			if len(redacted.Cookies) > 0 {
				fmt.Println("Cookies:")
				for name := range redacted.Cookies {
					fmt.Printf("  %s: ***\n", name)
				}
			}
			if redacted.Authorization != "" {
				fmt.Printf("Authorization: %s\n", redacted.Authorization)
			}
		}
		return nil

	case "clear":
		if err := session.DeleteSession(host); err != nil {
			return fmt.Errorf("failed to delete session: %w", err)
		}
		fmt.Printf("Session cleared for %s\n", host)
		return nil

	case "use":
		sess, err := session.LoadSession(host)
		if err != nil {
			return fmt.Errorf("failed to load session: %w", err)
		}
		if sess == nil {
			return fmt.Errorf("no session found for %s", host)
		}
		// Print environment variable stub for shell scoping
		fmt.Printf("export REQ_SESSION_HOST=%s\n", host)
		return nil

	default:
		return fmt.Errorf("unknown session subcommand: %s", cmd.SessionSubcommand)
	}
}

----
docs/QUOTING.md
# Cross Shell Quoting Guide

This guide provides examples of how to properly quote `req` commands in different shells.

## General Rules

- Values containing semicolons (`;`) must be quoted
- Values containing spaces should be quoted
- Values containing special characters should be quoted
- Environment variables are expanded by the shell before being passed to `req`

## Bash / Zsh

### Single Quotes (Recommended)
Single quotes preserve everything literally:

```bash
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

### Double Quotes
Double quotes allow variable expansion:

```bash
TOKEN="abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

### Escaping
Use backslash to escape special characters:

```bash
req read https://api.example.com/search include='param: q=test\;value' as=json
```

## Fish Shell

Fish uses different quoting rules:

```fish
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in fish:

```fish
set TOKEN "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## PowerShell

PowerShell uses backticks for escaping:

```powershell
req read https://api.example.com/search include='header: Authorization: Bearer token; param: q=search query' as=json
```

For variables in PowerShell:

```powershell
$TOKEN = "abc123"
req send https://api.example.com/users include="header: Authorization: Bearer $TOKEN" with='{"name":"Adam"}'
```

## Common Patterns

### Include Clause with Multiple Items

```bash
# Bash/Zsh
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# Fish
req read https://api.example.com/search \
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' \
  as=json

# PowerShell
req read https://api.example.com/search `
  include='header: Accept: application/json; param: q=test; cookie: session=abc123' `
  as=json
```

### Expect Clause with Multiple Checks

```bash
req read https://api.example.com/users \
  expect='status:200, header:Content-Type=application/json, contains:"items"' \
  as=json
```

### Attach Clause with File Paths

```bash
req upload https://api.example.com/upload \
  attach='part: name=file, file=@./avatar.png, type=image/png; part: name=meta, value={"name":"adam"}' \
  as=json
```

## Curl vs req Mapping

| curl command | req equivalent |
|-------------|----------------|
| `curl https://api.example.com/users` | `req read https://api.example.com/users` |
| `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/users` | `req read https://api.example.com/users include="header: Authorization: Bearer $TOKEN"` |
| `curl -X POST -d '{"name":"Adam"}' https://api.example.com/users` | `req send https://api.example.com/users with='{"name":"Adam"}'` |
| `curl -X POST -F "file=@avatar.png" https://api.example.com/upload` | `req upload https://api.example.com/upload attach='part: name=file, file=@avatar.png'` |
| `curl -b "session=abc123" https://api.example.com/users` | `req read https://api.example.com/users include='cookie: session=abc123'` |
| `curl -L https://example.com` | `req read https://example.com` (follows redirects by default) |
| `curl -k https://self-signed.example.com` | `req read https://self-signed.example.com insecure=true` |
| `curl --proxy http://proxy:8080 https://api.example.com` | `req read https://api.example.com via=http://proxy:8080` |
| `curl -X POST --data-binary @file.json https://api.example.com` | `req send https://api.example.com with=@file.json` |
| `curl -X POST --data @- https://api.example.com` | `echo '{"data":"value"}' \| req send https://api.example.com with=@-` |

## Tips

1. **Always quote include= values** - They often contain semicolons and spaces
2. **Use single quotes for JSON** - Prevents shell from interpreting special characters
3. **Use double quotes when you need variable expansion** - But be careful with nested quotes
4. **Test with `req explain`** - See how your command is parsed before executing:
   ```bash
   req explain "read https://api.example.com/users include='header: Authorization: Bearer token'"
   ```


----
go.mod
module github.com/adammpkins/req

go 1.24.0

toolchain go1.24.10

require (
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
)

require (
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

----
go.sum
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=

----
internal/grammar/grammar.go
// Package grammar defines the structured grammar data for req commands.
package grammar

import "fmt"

// Verb represents a req command verb.
type Verb struct {
	Name        string
	Description string
}

// Clause represents a req command clause.
type Clause struct {
	Name        string
	Description string
	Repeatable  bool
	Example     string
}

// Grammar contains the complete grammar definition.
type Grammar struct {
	Verbs   []Verb
	Clauses []Clause
}

// GetGrammar returns the canonical grammar definition.
func GetGrammar() Grammar {
	return Grammar{
		Verbs: []Verb{
			{Name: "read", Description: "GET, print to stdout"},
			{Name: "save", Description: "GET, write to file via to="},
			{Name: "send", Description: "default GET, POST if with= present"},
			{Name: "upload", Description: "POST when attach= or with= present, else error"},
			{Name: "watch", Description: "GET with SSE or polling"},
			{Name: "inspect", Description: "HEAD only"},
			{Name: "authenticate", Description: "login and store session state"},
			{Name: "session", Description: "session management (show, clear, use)"},
		},
		Clauses: []Clause{
			{Name: "using=", Description: "HTTP method override", Repeatable: false, Example: "using=PUT"},
			{Name: "include=", Description: "Add headers, params, cookies", Repeatable: true, Example: "include='header: Authorization: Bearer token; param: q=search query'"},
			{Name: "with=", Description: "Request body", Repeatable: false, Example: "with=@user.json or with='{\"name\":\"Adam\"}'"},
			{Name: "expect=", Description: "Assertions on response", Repeatable: false, Example: "expect=status:200, header:Content-Type=application/json, contains:\"ok\""},
			{Name: "as=", Description: "Output format for stdout", Repeatable: false, Example: "as=json"},
			{Name: "to=", Description: "Destination path", Repeatable: false, Example: "to=out.json"},
			{Name: "retry=", Description: "Retry attempts for transient errors", Repeatable: false, Example: "retry=3"},
			{Name: "under=", Description: "Timeout or size limit", Repeatable: false, Example: "under=30s or under=10MB"},
			{Name: "via=", Description: "Proxy URL", Repeatable: false, Example: "via=http://proxy:8080"},
			{Name: "attach=", Description: "Multipart parts for upload or send", Repeatable: true, Example: "attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'"},
			{Name: "follow=", Description: "Redirect policy for write verbs", Repeatable: false, Example: "follow=smart"},
			{Name: "insecure=", Description: "Disable TLS verification for this request", Repeatable: false, Example: "insecure=true"},
		},
	}
}

// FormatHelp formats the grammar as help text.
func FormatHelp() string {
	g := GetGrammar()
	
	var help string
	help += "req - HTTP client DSL\n\n"
	help += "Usage: req <verb> <url> [clauses...]\n\n"
	help += "Verbs:\n"
	
	for _, verb := range g.Verbs {
		help += fmt.Sprintf("  %-13s - %s\n", verb.Name, verb.Description)
	}
	
	help += "\nClauses:\n"
	for _, clause := range g.Clauses {
		help += fmt.Sprintf("  %-13s - %s", clause.Name, clause.Description)
		if clause.Repeatable {
			help += " (repeatable)"
		}
		help += "\n"
		if clause.Example != "" {
			help += fmt.Sprintf("                 Example: %s\n", clause.Example)
		}
	}
	
	help += "\nExamples:\n"
	help += "  req read https://api.example.com/search include='param: q=search query' as=json\n"
	help += "  \n"
	help += "  req send https://api.example.com/users \\\n"
	help += "    using=POST \\\n"
	help += "    include='header: Authorization: Bearer $TOKEN' \\\n"
	help += "    with='{\"name\":\"Adam\"}' \\\n"
	help += "    expect=status:201, header:Content-Type=application/json \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req upload https://api.example.com/upload \\\n"
	help += "    attach='part: name=file, file=@./avatar.png, type=image/png' \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req authenticate https://api.example.com/login \\\n"
	help += "    using=POST \\\n"
	help += "    with='{\"user\":\"adam\",\"pass\":\"xyz\"}'\n"
	help += "  \n"
	help += "  req read https://api.example.com/me as=json\n\n"
	help += "For more information, see the grammar documentation.\n"
	
	return help
}


----
internal/grammar/snapshot.go
package grammar

import "encoding/json"

// Snapshot represents a snapshot of the grammar for drift detection.
type Snapshot struct {
	Verbs   []string `json:"verbs"`
	Clauses []ClauseSnapshot `json:"clauses"`
}

// ClauseSnapshot represents a clause in the snapshot.
type ClauseSnapshot struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Repeatable  bool   `json:"repeatable"`
}

// GetSnapshot returns a JSON-serializable snapshot of the grammar.
func GetSnapshot() Snapshot {
	g := GetGrammar()
	
	verbs := make([]string, len(g.Verbs))
	for i, v := range g.Verbs {
		verbs[i] = v.Name
	}
	
	clauses := make([]ClauseSnapshot, len(g.Clauses))
	for i, c := range g.Clauses {
		clauses[i] = ClauseSnapshot{
			Name:        c.Name,
			Description: c.Description,
			Repeatable:  c.Repeatable,
		}
	}
	
	return Snapshot{
		Verbs:   verbs,
		Clauses: clauses,
	}
}

// GetSnapshotJSON returns the snapshot as JSON bytes.
func GetSnapshotJSON() ([]byte, error) {
	snapshot := GetSnapshot()
	return json.MarshalIndent(snapshot, "", "  ")
}


----
internal/output/format.go
// Package output provides formatting and pretty-printing for execution plans.
package output

import (
	"encoding/json"
	"os"

	"github.com/adammpkins/req/internal/planner"
	"github.com/mattn/go-isatty"
)

// FormatPlan formats an ExecutionPlan as JSON for output.
func FormatPlan(plan *planner.ExecutionPlan) ([]byte, error) {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		// Pretty print when outputting to terminal
		return json.MarshalIndent(plan, "", "  ")
	}
	// Compact JSON when piped
	return json.Marshal(plan)
}


----
internal/parser/parser.go
// Package parser implements a lexer and parser for the req command grammar.
//
// Grammar (EBNF):
//
//	command = verb target [clauses]
//	verb = "read" | "save" | "send" | "upload" | "watch" | "inspect" | "authenticate" | "session"
//	target = url
//	clauses = clause { clause }
//	clause = with_clause | include_clause | attach_clause | expect_clause | as_clause | to_clause |
//	         using_clause | retry_clause | under_clause | via_clause | follow_clause | insecure_clause
//	with_clause = "with=" ( string | "@file" | "@-" )
//	include_clause = "include=" items
//	attach_clause = "attach=" parts
//	expect_clause = "expect=" checks
//	as_clause = "as=" ( "json" | "csv" | "text" | "raw" )
//	to_clause = "to=" path
//	using_clause = "using=" ( "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS" )
//	retry_clause = "retry=" number
//	under_clause = "under=" ( duration | size )
//	via_clause = "via=" url
//	follow_clause = "follow=smart"
//	insecure_clause = "insecure=" ( "true" | "false" )
package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// isValidHTTPMethod checks if a method is a valid HTTP method.
func isValidHTTPMethod(method string) bool {
	validMethods := []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	methodUpper := strings.ToUpper(method)
	for _, valid := range validMethods {
		if methodUpper == valid {
			return true
		}
	}
	return false
}

// ParseError represents a parse error with position information.
type ParseError struct {
	Position int
	Token    string
	Message  string
	Suggest  string
}

func (e *ParseError) Error() string {
	if e.Suggest != "" {
		return fmt.Sprintf("parse error at position %d (token: %q): %s (did you mean %q?)", e.Position, e.Token, e.Message, e.Suggest)
	}
	return fmt.Sprintf("parse error at position %d (token: %q): %s", e.Position, e.Token, e.Message)
}

// Parser parses req commands into AST.
type Parser struct {
	tokens []token
	pos    int
}

// token represents a lexical token.
type token struct {
	typ   tokenType
	value string
	pos   int
}

type tokenType int

const (
	tokenEOF tokenType = iota
	tokenWord
	tokenURL
	tokenEquals
	tokenColon
	tokenDotDot
	tokenString
	tokenNumber
	tokenDuration
	tokenFlag
)

// Parse parses a command string into a Command AST.
func Parse(input string) (*types.Command, error) {
	p := &Parser{}
	p.tokenize(input)
	return p.parseCommand()
}

// tokenize tokenizes the input string.
func (p *Parser) tokenize(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		p.tokens = []token{{typ: tokenEOF, pos: 0}}
		return
	}

	parts := strings.Fields(input)
	tokens := make([]token, 0, len(parts))

	for i, part := range parts {
		pos := i
		// Check if this is a URL first (URLs with query params contain = but are not clauses)
		if looksLikeURL(part) {
			tokens = append(tokens, token{typ: tokenURL, value: part, pos: pos})
		} else if strings.Contains(part, "=") {
			// Handle clauses with equals
			// Split on = but keep the = as a token
			eqIdx := strings.Index(part, "=")
			key := part[:eqIdx]
			value := part[eqIdx+1:]

			tokens = append(tokens, token{typ: tokenWord, value: key, pos: pos})
			tokens = append(tokens, token{typ: tokenEquals, value: "=", pos: pos})
			// Handle typed values like json:...
			if strings.Contains(value, ":") {
				colonIdx := strings.Index(value, ":")
				typeName := value[:colonIdx]
				typeValue := value[colonIdx+1:]
				tokens = append(tokens, token{typ: tokenWord, value: typeName, pos: pos})
				tokens = append(tokens, token{typ: tokenColon, value: ":", pos: pos})
				tokens = append(tokens, token{typ: tokenString, value: typeValue, pos: pos})
			} else if looksLikeURL(value) {
				tokens = append(tokens, token{typ: tokenURL, value: value, pos: pos})
			} else if looksLikeDuration(value) {
				tokens = append(tokens, token{typ: tokenDuration, value: value, pos: pos})
			} else {
				tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
			}
		} else if isFlag(part) {
			tokens = append(tokens, token{typ: tokenFlag, value: part, pos: pos})
		} else {
			tokens = append(tokens, token{typ: tokenWord, value: part, pos: pos})
		}
	}

	tokens = append(tokens, token{typ: tokenEOF, pos: len(parts)})
	p.tokens = tokens
}

// looksLikeURL checks if a string looks like a URL.
func looksLikeURL(s string) bool {
	return strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://")
}

// looksLikeDuration checks if a string looks like a duration.
func looksLikeDuration(s string) bool {
	_, err := parseDuration(s)
	return err == nil
}

// isFlag checks if a string is a flag.
func isFlag(s string) bool {
	return s == "verbose" || s == "resume"
}

// parseCommand parses a command.
func (p *Parser) parseCommand() (*types.Command, error) {
	cmd := &types.Command{}

	// Parse verb
	verb, err := p.parseVerb()
	if err != nil {
		return nil, err
	}
	cmd.Verb = verb

	// Handle session subcommands (show, clear, use)
	if verb == types.VerbSession {
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected session subcommand (show, clear, use)"}
		}
		tok := p.tokens[p.pos]
		if tok.typ == tokenWord {
			subcmd := tok.value
			if subcmd == "show" || subcmd == "clear" || subcmd == "use" {
				cmd.SessionSubcommand = subcmd
				p.pos++
			} else {
				return nil, &ParseError{Position: tok.pos, Token: subcmd, Message: "unknown session subcommand (expected show, clear, or use)"}
			}
		}
	}

	// Parse target
	target, err := p.parseTarget()
	if err != nil {
		return nil, err
	}
	cmd.Target = target

	// Parse clauses
	clauses, err := p.parseClauses()
	if err != nil {
		return nil, err
	}
	cmd.Clauses = clauses

	return cmd, nil
}

// parseVerb parses a verb.
func (p *Parser) parseVerb() (types.Verb, error) {
	if p.pos >= len(p.tokens) {
		return "", &ParseError{Position: p.pos, Token: "", Message: "expected verb"}
	}

	tok := p.tokens[p.pos]
	if tok.typ != tokenWord {
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "expected verb"}
	}

	verb := types.Verb(tok.value)
	switch verb {
	case types.VerbRead, types.VerbSave, types.VerbSend, types.VerbUpload,
		types.VerbWatch, types.VerbInspect, types.VerbAuthenticate, types.VerbSession:
		p.pos++
		return verb, nil
	default:
		suggest := suggestVerb(tok.value)
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "unknown verb", Suggest: suggest}
	}
}

// suggestVerb suggests a similar verb.
func suggestVerb(input string) string {
	verbs := []string{"read", "save", "send", "upload", "watch", "inspect", "authenticate", "session"}
	best := ""
	minDist := 999
	for _, v := range verbs {
		dist := levenshteinDistance(input, v)
		if dist < minDist {
			minDist = dist
			best = v
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// levenshteinDistance calculates the Levenshtein distance between two strings.
func levenshteinDistance(a, b string) int {
	if len(a) == 0 {
		return len(b)
	}
	if len(b) == 0 {
		return len(a)
	}

	matrix := make([][]int, len(a)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(b)+1)
	}

	for i := 0; i <= len(a); i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len(b); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {
			cost := 0
			if a[i-1] != b[j-1] {
				cost = 1
			}
			matrix[i][j] = min(
				matrix[i-1][j]+1,
				matrix[i][j-1]+1,
				matrix[i-1][j-1]+cost,
			)
		}
	}

	return matrix[len(a)][len(b)]
}

func min(a, b, c int) int {
	if a < b && a < c {
		return a
	}
	if b < c {
		return b
	}
	return c
}

// parseTarget parses a target URL.
func (p *Parser) parseTarget() (types.Target, error) {
	if p.pos >= len(p.tokens) {
		return types.Target{}, &ParseError{Position: p.pos, Token: "", Message: "expected target URL or host"}
	}

	tok := p.tokens[p.pos]
	// For session commands, target might be a host instead of full URL
	if tok.typ == tokenURL {
		p.pos++
		return types.Target{URL: tok.value}, nil
	} else if tok.typ == tokenWord {
		// Might be a host name for session commands
		// Try to parse as URL, if it fails, treat as host
		if strings.Contains(tok.value, ".") || strings.Contains(tok.value, ":") {
			// Looks like a host, construct URL
			urlStr := "https://" + tok.value
			p.pos++
			return types.Target{URL: urlStr}, nil
		}
	}

	return types.Target{}, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected URL or host"}
}

// parseClauses parses zero or more clauses.
func (p *Parser) parseClauses() ([]types.Clause, error) {
	var clauses []types.Clause
	singletonSeen := make(map[string]bool)

	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}

		clause, err := p.parseClause()
		if err != nil {
			return nil, err
		}

		// Check for duplicate singletons
		if singletonKey := getSingletonKey(clause); singletonKey != "" {
			if singletonSeen[singletonKey] {
				return nil, &ParseError{
					Position: tok.pos,
					Token:    tok.value,
					Message:  fmt.Sprintf("duplicate singleton clause '%s'", singletonKey),
					Suggest:  fmt.Sprintf("remove duplicate '%s=' clause", singletonKey),
				}
			}
			singletonSeen[singletonKey] = true
		}

		clauses = append(clauses, clause)
	}

	return clauses, nil
}

// getSingletonKey returns the key name for singleton clauses, or empty string for repeatable clauses.
func getSingletonKey(clause types.Clause) string {
	switch clause.(type) {
	case types.UsingClause:
		return "using"
	case types.WithClause:
		return "with"
	case types.ExpectClause:
		return "expect"
	case types.AsClause:
		return "as"
	case types.ToClause:
		return "to"
	case types.RetryClause:
		return "retry"
	case types.UnderClause:
		return "under"
	case types.ViaClause:
		return "via"
	case types.InsecureClause:
		return "insecure"
	case types.FollowClause:
		return "follow"
	case types.TimeoutClause:
		return "timeout"
	case types.BackoffClause:
		return "backoff"
	case types.PickClause:
		return "pick"
	case types.EveryClause:
		return "every"
	case types.UntilClause:
		return "until"
	case types.ProxyClause:
		return "proxy"
	case types.FieldClause:
		return "field"
	case types.VerboseClause:
		return "verbose"
	case types.ResumeClause:
		return "resume"
	// Repeatable clauses return empty string
	case types.IncludeClause, types.AttachClause:
		return ""
	default:
		return ""
	}
}

// parseClause parses a single clause.
func (p *Parser) parseClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected clause"}
	}

	tok := p.tokens[p.pos]

	// Handle flags (insecure is now a clause with =, but keep verbose and resume as flags)
	if tok.typ == tokenFlag {
		p.pos++
		switch tok.value {
		case "verbose":
			return types.VerboseClause{}, nil
		case "resume":
			return types.ResumeClause{}, nil
		}
	}

	// Handle clauses with equals
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
		key := tok.value
		p.pos += 2 // skip key and =

		switch key {
		case "with":
			return p.parseWithClause()
		case "include":
			return p.parseIncludeClause()
		case "attach":
			return p.parseAttachClause()
		case "expect":
			return p.parseExpectClause()
		case "headers":
			return p.parseHeadersClause()
		case "params":
			return p.parseParamsClause()
		case "as":
			return p.parseAsClause()
		case "to":
			return p.parseToClause()
		case "using":
			return p.parseUsingClause()
		case "retry":
			return p.parseRetryClause()
		case "backoff":
			return p.parseBackoffClause()
		case "timeout":
			return p.parseTimeoutClause()
		case "under":
			return p.parseUnderClause()
		case "proxy":
			return p.parseProxyClause()
		case "via":
			return p.parseViaClause()
		case "follow":
			return p.parseFollowClause()
		case "insecure":
			return p.parseInsecureClause()
		case "pick":
			return p.parsePickClause()
		case "every":
			return p.parseEveryClause()
		case "until":
			return p.parseUntilClause()
		case "field":
			return p.parseFieldClause()
		default:
			suggest := suggestClause(key)
			return nil, &ParseError{Position: tok.pos, Token: key, Message: "unknown clause", Suggest: suggest}
		}
	}

	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected clause"}
}

// suggestClause suggests a similar clause name.
func suggestClause(input string) string {
	clauses := []string{"with", "include", "attach", "expect", "headers", "params", "as", "to", "using", "retry", "backoff", "timeout", "under", "proxy", "via", "follow", "insecure", "pick", "every", "until", "field"}
	best := ""
	minDist := 999
	for _, c := range clauses {
		dist := levenshteinDistance(input, c)
		if dist < minDist {
			minDist = dist
			best = c
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// parseWithClause parses a "with=" clause.
func (p *Parser) parseWithClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	tok := p.tokens[p.pos]
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenColon {
		// typed value like json:...
		typeName := tok.value
		p.pos += 2 // skip type and :
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
		}
		valueTok := p.tokens[p.pos]
		p.pos++
		value := valueTok.value
		isFile := strings.HasPrefix(value, "@") && value != "@-"
		isStdin := value == "@-"
		if isFile {
			value = value[1:] // Remove @ prefix
		}
		return types.WithClause{Type: typeName, Value: value, IsFile: isFile, IsStdin: isStdin}, nil
	}

	// plain value - check for @file or @-
	valueTok := p.tokens[p.pos]
	p.pos++
	value := valueTok.value
	isFile := strings.HasPrefix(value, "@") && value != "@-"
	isStdin := value == "@-"
	if isFile {
		value = value[1:] // Remove @ prefix
	}
	
	// Infer JSON type if value starts with { or [
	typeInferred := ""
	if !isFile && !isStdin {
		trimmed := strings.TrimSpace(value)
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			typeInferred = "json"
		}
	}
	
	return types.WithClause{Value: value, Type: typeInferred, IsFile: isFile, IsStdin: isStdin}, nil
}

// parseHeadersClause parses a "headers=" clause (simplified for v0.1.0).
func (p *Parser) parseHeadersClause() (types.Clause, error) {
	// Simplified: just parse a single key:value pair for now
	// Full object parsing will come later
	return types.HeadersClause{Headers: make(map[string]string)}, nil
}

// parseParamsClause parses a "params=" clause (simplified for v0.1.0).
func (p *Parser) parseParamsClause() (types.Clause, error) {
	// Simplified: just parse a single key=value pair for now
	return types.ParamsClause{Params: make(map[string]string)}, nil
}

// parseAsClause parses an "as=" clause.
func (p *Parser) parseAsClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected format"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.AsClause{Format: tok.value}, nil
}

// parseToClause parses a "to=" clause.
func (p *Parser) parseToClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected destination"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ToClause{Destination: tok.value}, nil
}

// parseUsingClause parses a "using=" clause.
func (p *Parser) parseUsingClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected HTTP method"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	method := strings.ToUpper(tok.value)
	
	if !isValidHTTPMethod(method) {
		return nil, &ParseError{
			Position: tok.pos,
			Token:    tok.value,
			Message:  fmt.Sprintf("invalid HTTP method: %s (valid methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS)", tok.value),
		}
	}
	
	return types.UsingClause{Method: method}, nil
}

// parseRetryClause parses a "retry=" clause.
func (p *Parser) parseRetryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected retry count"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	// Parse number (simplified)
	count := 3 // default
	if tok.typ == tokenNumber {
		// In a real implementation, parse the number
		// For now, just use default
	}
	return types.RetryClause{Count: count}, nil
}

// parseBackoffClause parses a "backoff=" clause.
func (p *Parser) parseBackoffClause() (types.Clause, error) {
	// Format: backoff=200ms..5s
	if p.pos+2 >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected backoff range"}
	}

	minTok := p.tokens[p.pos]
	p.pos++
	if p.tokens[p.pos].typ != tokenDotDot {
		return nil, &ParseError{Position: p.pos, Token: p.tokens[p.pos].value, Message: "expected .."}
	}
	p.pos++
	maxTok := p.tokens[p.pos]
	p.pos++

	minDur, err := parseDuration(minTok.value)
	if err != nil {
		return nil, &ParseError{Position: minTok.pos, Token: minTok.value, Message: "invalid duration"}
	}
	maxDur, err := parseDuration(maxTok.value)
	if err != nil {
		return nil, &ParseError{Position: maxTok.pos, Token: maxTok.value, Message: "invalid duration"}
	}

	return types.BackoffClause{Min: minDur, Max: maxDur}, nil
}

// parseDuration parses a duration string.
func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

// parseTimeoutClause parses a "timeout=" clause.
func (p *Parser) parseTimeoutClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected timeout duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.TimeoutClause{Duration: dur}, nil
}

// parseProxyClause parses a "proxy=" clause.
func (p *Parser) parseProxyClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected proxy URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ProxyClause{URL: tok.value}, nil
}

// parsePickClause parses a "pick=" clause.
func (p *Parser) parsePickClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected JSONPath expression"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.PickClause{Path: tok.value}, nil
}

// parseEveryClause parses an "every=" clause.
func (p *Parser) parseEveryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected interval duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.EveryClause{Interval: dur}, nil
}

// parseUntilClause parses an "until=" clause.
func (p *Parser) parseUntilClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected predicate"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.UntilClause{Predicate: tok.value}, nil
}

// parseFieldClause parses a "field=" clause.
func (p *Parser) parseFieldClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field name"}
	}

	nameTok := p.tokens[p.pos]
	p.pos++
	if p.pos >= len(p.tokens) || p.tokens[p.pos].typ != tokenEquals {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected ="}
	}
	p.pos++
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field value"}
	}
	valueTok := p.tokens[p.pos]
	p.pos++

	return types.FieldClause{Name: nameTok.value, Value: valueTok.value}, nil
}

// parseIncludeClause parses an "include=" clause.
// Format: include='header: Name: Value; param: key=value; cookie: key=value'
func (p *Parser) parseIncludeClause() (types.Clause, error) {
	// Collect tokens until we have a complete include value
	// The value may contain colons, semicolons, and spaces
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected include value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}

	items, err := parseIncludeItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.IncludeClause{Items: items}, nil
}

// parseIncludeItems parses semicolon-separated include items.
func parseIncludeItems(value string) ([]types.IncludeItem, error) {
	var items []types.IncludeItem
	
	// Split by semicolons, but respect quoted strings
	parts := splitRespectingQuotes(value, ';')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		item, err := parseIncludeItem(part)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	
	return items, nil
}

// parseIncludeItem parses a single include item (header:, param:, cookie:).
func parseIncludeItem(part string) (types.IncludeItem, error) {
	// Find the first colon to determine the type
	colonIdx := strings.Index(part, ":")
	if colonIdx == -1 {
		return types.IncludeItem{}, fmt.Errorf("missing colon in include item: %s", part)
	}
	
	typeTag := strings.TrimSpace(part[:colonIdx])
	rest := strings.TrimSpace(part[colonIdx+1:])
	
	switch typeTag {
	case "header":
		// Format: header: Name: Value
		headerColonIdx := strings.Index(rest, ":")
		if headerColonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("header item missing Name colon Value: %s", part)
		}
		name := strings.TrimSpace(rest[:headerColonIdx])
		value := strings.TrimSpace(rest[headerColonIdx+1:])
		// Unquote if needed
		name = unquoteString(name)
		value = unquoteString(value)
		return types.IncludeItem{Type: "header", Name: name, Value: value}, nil
		
	case "param":
		// Format: param: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("param item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "param", Name: key, Value: value}, nil
		
	case "cookie":
		// Format: cookie: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("cookie item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "cookie", Name: key, Value: value}, nil
		
	default:
		return types.IncludeItem{}, fmt.Errorf("unknown include item tag: %s (expected header, param, or cookie)", typeTag)
	}
}

// splitRespectingQuotes splits a string by a delimiter while respecting quoted strings.
func splitRespectingQuotes(s string, delim rune) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	escape := false
	
	for _, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}
		
		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}
		
		if r == '\'' || r == '"' {
			inQuotes = !inQuotes
			current.WriteRune(r)
			continue
		}
		
		if r == delim && !inQuotes {
			parts = append(parts, current.String())
			current.Reset()
			continue
		}
		
		current.WriteRune(r)
	}
	
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	
	return parts
}

// unquoteString removes surrounding quotes if present and handles escapes.
func unquoteString(s string) string {
	if len(s) >= 2 && ((s[0] == '\'' && s[len(s)-1] == '\'') || (s[0] == '"' && s[len(s)-1] == '"')) {
		s = s[1 : len(s)-1]
		// Handle escapes
		var result strings.Builder
		escape := false
		for _, r := range s {
			if escape {
				if r == '\\' || r == '\'' || r == '"' {
					result.WriteRune(r)
				} else {
					result.WriteRune('\\')
					result.WriteRune(r)
				}
				escape = false
			} else if r == '\\' {
				escape = true
			} else {
				result.WriteRune(r)
			}
		}
		if escape {
			result.WriteRune('\\')
		}
		return result.String()
	}
	return s
}

// parseAttachClause parses an "attach=" clause.
// Format: attach='part: name=..., file=@path; part: name=..., value=...'
func (p *Parser) parseAttachClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected attach value"}
	}

	tok := p.tokens[p.pos]
	p.pos++

	value := tok.value
	parts, boundary, err := parseAttachItems(value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: err.Error()}
	}

	return types.AttachClause{Parts: parts, Boundary: boundary}, nil
}

// parseAttachItems parses semicolon-separated attach items.
func parseAttachItems(value string) ([]types.AttachPart, string, error) {
	var parts []types.AttachPart
	var boundary string
	
	// Split by semicolons, respecting quotes
	items := splitRespectingQuotes(value, ';')
	
	for _, item := range items {
		item = strings.TrimSpace(item)
		if item == "" {
			continue
		}
		
		// Check if it's a boundary specification
		if strings.HasPrefix(item, "boundary:") {
			boundary = strings.TrimSpace(strings.TrimPrefix(item, "boundary:"))
			boundary = unquoteString(boundary)
			continue
		}
		
		// Parse part: specification
		if !strings.HasPrefix(item, "part:") {
			return nil, "", fmt.Errorf("expected 'part:' or 'boundary:', got: %s", item)
		}
		
		partSpec := strings.TrimSpace(strings.TrimPrefix(item, "part:"))
		part, err := parseAttachPart(partSpec)
		if err != nil {
			return nil, "", err
		}
		parts = append(parts, part)
	}
	
	return parts, boundary, nil
}

// parseAttachPart parses a single attach part specification.
// Format: name=..., file=@path or value=..., optional filename=..., optional type=...
func parseAttachPart(spec string) (types.AttachPart, error) {
	var part types.AttachPart
	
	// Parse comma-separated key=value pairs
	pairs := splitRespectingQuotes(spec, ',')
	
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		eqIdx := strings.Index(pair, "=")
		if eqIdx == -1 {
			return types.AttachPart{}, fmt.Errorf("missing equals in attach part: %s", pair)
		}
		
		key := strings.TrimSpace(pair[:eqIdx])
		value := strings.TrimSpace(pair[eqIdx+1:])
		value = unquoteString(value)
		
		switch key {
		case "name":
			part.Name = value
		case "file":
			if strings.HasPrefix(value, "@") {
				part.FilePath = value[1:] // Remove @
			} else {
				part.FilePath = value
			}
		case "value":
			part.Value = value
		case "filename":
			part.Filename = value
		case "type":
			part.Type = value
		default:
			return types.AttachPart{}, fmt.Errorf("unknown attach part key: %s", key)
		}
	}
	
	// Validate: name is required
	if part.Name == "" {
		return types.AttachPart{}, fmt.Errorf("attach part missing required 'name='")
	}
	
	// Validate: exactly one of file or value
	hasFile := part.FilePath != ""
	hasValue := part.Value != ""
	if hasFile && hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part cannot have both 'file=' and 'value='")
	}
	if !hasFile && !hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part must have either 'file=' or 'value='")
	}
	
	return part, nil
}

// parseExpectClause parses an "expect=" clause.
// Format: expect=status:200, header:Content-Type=application/json, contains:"text"
func (p *Parser) parseExpectClause() (types.Clause, error) {
	// Collect tokens until we have a complete expect value
	// The value may contain colons and commas, so we need to collect multiple tokens
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected expect value"}
	}

	// Join tokens, but handle colons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon and current isn't a colon
			if valueParts[i-1] != ":" && part != ":" {
				value += " "
			}
		}
		value += part
	}
	
	checks, err := parseExpectChecks(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.ExpectClause{Checks: checks}, nil
}

// parseExpectChecks parses comma-separated expect checks.
func parseExpectChecks(value string) ([]types.ExpectCheck, error) {
	var checks []types.ExpectCheck
	
	// Split by commas, respecting quotes
	parts := splitRespectingQuotes(value, ',')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		check, err := parseExpectCheck(part)
		if err != nil {
			return nil, err
		}
		checks = append(checks, check)
	}
	
	return checks, nil
}

// parseExpectCheck parses a single expect check.
func parseExpectCheck(part string) (types.ExpectCheck, error) {
	// Unquote if needed first
	unquoted := unquoteString(part)
	
	// Check types: status:, header:, contains:, jsonpath:, matches:
	if strings.HasPrefix(unquoted, "status:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "status:"))
		return types.ExpectCheck{Type: "status", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "header:") {
		rest := strings.TrimSpace(strings.TrimPrefix(unquoted, "header:"))
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.ExpectCheck{}, fmt.Errorf("header check missing equals: %s", part)
		}
		name := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		value = unquoteString(value)
		return types.ExpectCheck{Type: "header", Name: name, Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "contains:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "contains:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "contains", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "jsonpath:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "jsonpath:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "jsonpath", Path: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "matches:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "matches:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "matches", Regex: value}, nil
	}
	
	return types.ExpectCheck{}, fmt.Errorf("unknown expect check type: %s", part)
}

// parseFollowClause parses a "follow=" clause.
func (p *Parser) parseFollowClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected follow value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "smart" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "follow accepts only 'smart'"}
	}
	
	return types.FollowClause{Policy: "smart"}, nil
}

// parseUnderClause parses an "under=" clause (duration or size).
func (p *Parser) parseUnderClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected under value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.TrimSpace(tok.value)
	
	// Try parsing as duration first
	if dur, err := parseDuration(value); err == nil {
		return types.UnderClause{Duration: dur, IsSize: false}, nil
	}
	
	// Try parsing as size (e.g., "10MB", "1GB")
	if size, err := parseSize(value); err == nil {
		return types.UnderClause{Size: size, IsSize: true}, nil
	}
	
	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "under value must be a duration (e.g., 30s) or size (e.g., 10MB)"}
}

// parseSize parses a size string like "10MB", "1GB", etc.
func parseSize(s string) (int64, error) {
	s = strings.TrimSpace(s)
	s = strings.ToUpper(s)
	
	multipliers := map[string]int64{
		"B":  1,
		"KB": 1024,
		"MB": 1024 * 1024,
		"GB": 1024 * 1024 * 1024,
		"TB": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, mult := range multipliers {
		if strings.HasSuffix(s, suffix) {
			numStr := strings.TrimSuffix(s, suffix)
			var num float64
			if _, err := fmt.Sscanf(numStr, "%f", &num); err != nil {
				return 0, err
			}
			return int64(num * float64(mult)), nil
		}
	}
	
	return 0, fmt.Errorf("unknown size suffix")
}

// parseViaClause parses a "via=" clause.
func (p *Parser) parseViaClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected via URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ViaClause{URL: tok.value}, nil
}

// parseInsecureClause parses an "insecure=" clause.
func (p *Parser) parseInsecureClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected insecure value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "true" && value != "false" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "insecure accepts only 'true' or 'false'"}
	}
	
	return types.InsecureClause{Value: value == "true"}, nil
}

----
internal/planner/plan.go
// Package planner applies defaults, validates commands, and produces execution plans.
package planner

import (
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// ExecutionPlan represents a fully resolved execution plan ready for HTTP runtime.
type ExecutionPlan struct {
	Verb        types.Verb         `json:"verb"`
	Method      string             `json:"method"`
	URL         string             `json:"url"`
	Headers     map[string]string  `json:"headers,omitempty"`
	QueryParams map[string]string  `json:"query_params,omitempty"`
	Cookies     map[string]string  `json:"cookies,omitempty"`
	Body        *BodyPlan          `json:"body,omitempty"`
	Output      *OutputPlan        `json:"output,omitempty"`
	Retry       *RetryPlan         `json:"retry,omitempty"`
	Timeout     *time.Duration    `json:"timeout,omitempty"`
	SizeLimit   *int64            `json:"size_limit,omitempty"`
	Proxy       string             `json:"proxy,omitempty"`
	Insecure    bool               `json:"insecure,omitempty"`
	Verbose     bool               `json:"verbose,omitempty"`
	Resume      bool               `json:"resume,omitempty"`
	Follow      string             `json:"follow,omitempty"` // "smart" or empty
	Expect      []types.ExpectCheck `json:"expect,omitempty"`
}

// BodyPlan represents the request body configuration.
type BodyPlan struct {
	Type     string                `json:"type"` // json, form, multipart, raw
	Content  string                `json:"content,omitempty"`
	FilePath string                `json:"file_path,omitempty"`
	Field    string                `json:"field,omitempty"` // for multipart
	AttachParts []types.AttachPart `json:"attach_parts,omitempty"` // for multipart
	Boundary string                `json:"boundary,omitempty"` // for multipart
}

// OutputPlan represents the output configuration.
type OutputPlan struct {
	Format      string `json:"format"` // json, csv, text, raw
	Destination string `json:"destination,omitempty"`
	Pick        string `json:"pick,omitempty"` // JSONPath expression
}

// RetryPlan represents retry configuration.
type RetryPlan struct {
	Count  int           `json:"count"`
	Backoff BackoffRange `json:"backoff"`
}

// BackoffRange represents a backoff range with min and max durations.
type BackoffRange struct {
	Min time.Duration `json:"min"`
	Max time.Duration `json:"max"`
}

// Plan creates an ExecutionPlan from a parsed Command.
func Plan(cmd *types.Command) (*ExecutionPlan, error) {
	plan := &ExecutionPlan{
		Verb:        cmd.Verb,
		URL:         cmd.Target.URL,
		Headers:     make(map[string]string),
		QueryParams: make(map[string]string),
		Cookies:     make(map[string]string),
	}

	// Apply verb-specific defaults
	if err := applyVerbDefaults(cmd.Verb, plan); err != nil {
		return nil, err
	}

	// Process clauses
	for _, clause := range cmd.Clauses {
		if err := applyClause(clause, plan, cmd.Verb); err != nil {
			return nil, err
		}
	}

	// Post-process: extract filename for save verb if destination not provided or is a directory
	if cmd.Verb == types.VerbSave && plan.Output != nil {
		if plan.Output.Destination == "" {
			// No destination provided, extract from URL
			filename := extractFilenameFromURL(plan.URL)
			if filename != "" {
				plan.Output.Destination = filename
			}
		} else {
			// Destination provided - check if it's a directory
			if isDirectory(plan.Output.Destination) {
				// It's a directory, append filename from URL
				filename := extractFilenameFromURL(plan.URL)
				if filename != "" {
					plan.Output.Destination = filepath.Join(plan.Output.Destination, filename)
				}
			}
			// If it's a file path (like /tmp/file.zip), use it as-is
		}
	}

	// Validate plan
	if err := validatePlan(plan); err != nil {
		return nil, err
	}

	return plan, nil
}

// applyVerbDefaults applies default settings based on the verb.
func applyVerbDefaults(verb types.Verb, plan *ExecutionPlan) error {
	switch verb {
	case types.VerbRead:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSave:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "raw"}
	case types.VerbSend:
		// Default to GET, will be changed to POST if with= is present
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbUpload:
		// Default to POST, but will error if no attach= or with= present
		plan.Method = http.MethodPost
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbWatch:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbInspect:
		plan.Method = http.MethodHead
		plan.Output = &OutputPlan{Format: "json"}
	case types.VerbAuthenticate:
		// Default to POST if with= is present, otherwise require using=
		// We'll check this in validatePlan
		plan.Method = http.MethodPost // tentative, may be overridden
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSession:
		// Session verbs are handled separately in main
		plan.Method = http.MethodGet // placeholder
		plan.Output = &OutputPlan{Format: "auto"}
	default:
		return fmt.Errorf("unsupported verb: %s", verb)
	}
	return nil
}

// validateUsingClause validates that the HTTP method is compatible with the verb.
func validateUsingClause(verb types.Verb, method string) error {
	allowedMethods := map[types.Verb][]string{
		types.VerbRead:    {"GET", "HEAD", "OPTIONS"},
		types.VerbSave:    {"GET", "POST"},
		types.VerbSend:   {"POST", "PUT", "PATCH"},
		types.VerbUpload: {"POST", "PUT"},
		types.VerbWatch:  {"GET"},
		types.VerbInspect: {"HEAD", "GET", "OPTIONS"},
	}
	
	allowed, ok := allowedMethods[verb]
	if !ok {
		// If verb not in map, allow any method (for future verbs like delete)
		return nil
	}
	
	for _, allowedMethod := range allowed {
		if method == allowedMethod {
			return nil
		}
	}
	
	return fmt.Errorf("verb '%s' is incompatible with method '%s'", verb, method)
}

// applyClause applies a clause to the execution plan.
func applyClause(clause types.Clause, plan *ExecutionPlan, verb types.Verb) error {
	switch c := clause.(type) {
	case types.UsingClause:
		// Validate compatibility before applying
		if err := validateUsingClause(verb, c.Method); err != nil {
			return err
		}
		// Normalize to uppercase (defensive, should already be normalized in parser)
		plan.Method = strings.ToUpper(c.Method)
	case types.HeadersClause:
		for k, v := range c.Headers {
			plan.Headers[k] = v
		}
	case types.ParamsClause:
		for k, v := range c.Params {
			plan.QueryParams[k] = v
		}
	case types.WithClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		
		// Handle file or stdin
		if c.IsFile {
			plan.Body.FilePath = c.Value
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for files
			}
		} else if c.IsStdin {
			plan.Body.FilePath = "-" // Special marker for stdin
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for stdin
			}
		} else {
			plan.Body.Content = c.Value
			plan.Body.Type = c.Type
			// If type was inferred as JSON, we'll note it in runtime
			if plan.Body.Type == "json" {
				// JSON inference will be logged in runtime
			}
		}
		
		// If method is still GET and we have a body, default to POST
		if plan.Method == http.MethodGet {
			plan.Method = http.MethodPost
		}
	case types.AsClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Format = c.Format
	case types.ToClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Destination = c.Destination
	case types.RetryClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{
				Backoff: BackoffRange{
					Min: 200 * time.Millisecond,
					Max: 5 * time.Second,
				},
			}
		}
		plan.Retry.Count = c.Count
	case types.BackoffClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{Count: 3}
		}
		plan.Retry.Backoff = BackoffRange{
			Min: c.Min,
			Max: c.Max,
		}
	case types.TimeoutClause:
		plan.Timeout = &c.Duration
	case types.ProxyClause:
		plan.Proxy = c.URL
	case types.PickClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Pick = c.Path
	case types.InsecureClause:
		plan.Insecure = c.Value
	case types.ViaClause:
		plan.Proxy = c.URL
	case types.IncludeClause:
		// Merge include items into headers, params, or cookies
		for _, item := range c.Items {
			switch item.Type {
			case "header":
				// For multi-valued headers, we'd need to track arrays, but for now last wins
				// TODO: Support multi-valued headers properly
				plan.Headers[item.Name] = item.Value
			case "param":
				// Params can be repeated, so we append to query params
				// The runtime will handle serialization
				plan.QueryParams[item.Name] = item.Value
			case "cookie":
				// Cookies: last value wins
				plan.Cookies[item.Name] = item.Value
			}
		}
	case types.AttachClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		plan.Body.Type = "multipart"
		plan.Body.AttachParts = c.Parts
		if c.Boundary != "" {
			plan.Body.Boundary = c.Boundary
		}
	case types.ExpectClause:
		plan.Expect = c.Checks
	case types.FollowClause:
		plan.Follow = c.Policy
	case types.UnderClause:
		if c.IsSize {
			plan.SizeLimit = &c.Size
		} else {
			plan.Timeout = &c.Duration
		}
	case types.VerboseClause:
		plan.Verbose = true
	case types.ResumeClause:
		plan.Resume = true
	default:
		return fmt.Errorf("unsupported clause type: %T", clause)
	}
	return nil
}

// validatePlan validates the execution plan.
func validatePlan(plan *ExecutionPlan) error {
	if plan.Method == "" {
		return fmt.Errorf("method is required")
	}
	if plan.URL == "" {
		return fmt.Errorf("URL is required")
	}
	
	// Validate upload verb: must have attach= or with=
	// This check will be done after clauses are processed, so we check here
	// Actually, we need to check this in Plan() after processing clauses
	// For now, we'll do basic validation
	
	return nil
}

// extractFilenameFromURL extracts a filename from a URL.
func extractFilenameFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Get the path
	path := u.Path
	if path == "" || path == "/" {
		// Try to get from query or fragment
		return "download"
	}

	// Remove leading slash
	path = strings.TrimPrefix(path, "/")

	// Get the last segment
	parts := strings.Split(path, "/")
	if len(parts) == 0 {
		return "download"
	}

	filename := parts[len(parts)-1]

	// URL decode the filename (handle both path and query encoding)
	filename, err = url.PathUnescape(filename)
	if err != nil {
		// If PathUnescape fails, try QueryUnescape
		filename, err = url.QueryUnescape(filename)
		if err != nil {
			// If decoding fails, use the original
			filename = parts[len(parts)-1]
		}
	}

	// If filename is empty or doesn't have an extension, use a default
	if filename == "" || !strings.Contains(filename, ".") {
		filename = "download"
	}

	// Clean the filename (remove any path separators)
	filename = filepath.Base(filename)

	return filename
}

// isDirectory checks if a path is a directory.
func isDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}


----
internal/runtime/executor.go
// Package runtime executes HTTP requests based on execution plans.
package runtime

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
	"github.com/adammpkins/req/internal/session"
)

// Executor executes HTTP requests.
type Executor struct {
	client *http.Client
}

// NewExecutor creates a new executor.
func NewExecutor(plan *planner.ExecutionPlan) (*Executor, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create cookie jar: %w", err)
	}

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{},
	}

	// Configure TLS if insecure
	if plan.Insecure {
		transport.TLSClientConfig = getInsecureTLSConfig()
		fmt.Fprintf(os.Stderr, "Warning: TLS verification disabled\n")
	}

	// Configure proxy if specified
	if plan.Proxy != "" {
		proxyURL, err := url.Parse(plan.Proxy)
		if err != nil {
			return nil, fmt.Errorf("invalid proxy URL: %w", err)
		}
		transport.Proxy = http.ProxyURL(proxyURL)
	}

	client := &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
		Jar:       jar,
	}

	if plan.Timeout != nil {
		client.Timeout = *plan.Timeout
	}

	return &Executor{client: client}, nil
}

// Execute executes an HTTP request based on the plan.
func (e *Executor) Execute(plan *planner.ExecutionPlan) error {
	// Build request URL with query parameters (preserving order)
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("invalid URL: %v", err)}
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to build body: %v", err)}
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to create request: %v", err)}
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Auto-apply session if available and not explicitly set
	e.autoApplySession(req, plan)

	// Add Accept-Encoding if not set by user
	if req.Header.Get("Accept-Encoding") == "" {
		req.Header.Set("Accept-Encoding", "gzip, br")
	}

	// Execute request with redirect handling
	resp, redirectTrace, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
	}
	defer resp.Body.Close()

	// Print redirect trace to stderr
	if len(redirectTrace) > 0 {
		for _, trace := range redirectTrace {
			fmt.Fprintf(os.Stderr, "%s\n", trace)
		}
	}

	// Read and decompress response body
	bodyBytes, decompressed, err := e.readAndDecompress(resp)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("failed to read response: %v", err)}
	}

	if decompressed {
		fmt.Fprintf(os.Stderr, "Decompressed response\n")
	}

	// Print meta to stderr
	e.printMeta(resp, reqURL, len(bodyBytes), decompressed)

	// Capture session for authenticate verb
	if plan.Verb == types.VerbAuthenticate {
		host, err := session.ExtractHost(plan.URL)
		if err == nil {
			setCookies := resp.Header.Values("Set-Cookie")
			updatedSession, err := session.UpdateSessionFromResponse(host, setCookies, bodyBytes)
			if err == nil && updatedSession != nil {
				if err := session.SaveSession(updatedSession); err == nil {
					fmt.Fprintf(os.Stderr, "Session saved for %s\n", host)
				}
			}
		}
	}

	// Run expect checks
	if len(plan.Expect) > 0 {
		if err := e.runExpectChecks(resp, bodyBytes, plan.Expect); err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			return &ExecutionError{Code: 3, Message: "expectation failed"}
		}
	} else {
		// If no expect checks, fail on non-2xx status codes
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("HTTP %d %s", resp.StatusCode, resp.Status)}
		}
	}

	// Handle output based on plan
	if plan.Output != nil && plan.Output.Destination != "" {
		// Save to file - uses io.Copy for efficient writing
		// TODO: Optimize to stream directly from resp.Body when no expect checks
		return e.saveToFile(bytes.NewReader(bodyBytes), plan.Output.Destination)
	}

	// Handle watch verb with TTY detection
	if plan.Verb == types.VerbWatch {
		// TODO: Implement TTY detection
		// TTY: timestamped lines
		// Non-TTY: raw lines
		return e.writeOutput(bodyBytes, plan.Output)
	}

	// Format and write output
	return e.writeOutput(bodyBytes, plan.Output)
}

// ExecutionError represents an execution error with exit code.
type ExecutionError struct {
	Code    int
	Message string
}

func (e *ExecutionError) Error() string {
	return e.Message
}

// buildURL builds the request URL with query parameters, preserving order.
func (e *Executor) buildURL(plan *planner.ExecutionPlan) (string, error) {
	u, err := url.Parse(plan.URL)
	if err != nil {
		return "", err
	}

	// Merge existing query params with new ones
	existingParams := u.Query()
	for k, v := range plan.QueryParams {
		// Append to preserve order for repeated keys
		existingParams.Add(k, v)
	}
	u.RawQuery = existingParams.Encode()

	return u.String(), nil
}

// buildBody builds the request body.
func (e *Executor) buildBody(plan *planner.ExecutionPlan) (io.Reader, string, error) {
	if plan.Body == nil {
		return nil, "", nil
	}

	// Handle multipart
	if plan.Body.Type == "multipart" {
		return e.buildMultipartBody(plan.Body)
	}

	// Handle file or stdin
	if plan.Body.FilePath != "" {
		if plan.Body.FilePath == "-" {
			// Read from stdin
			data, err := io.ReadAll(os.Stdin)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read stdin: %w", err)
			}
			plan.Body.Content = string(data)
		} else {
			// Read from file
			data, err := os.ReadFile(plan.Body.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", plan.Body.FilePath, err)
			}
			plan.Body.Content = string(data)
		}
	}

	// Determine content type
	contentType := ""
	if plan.Body.Type == "json" {
		contentType = "application/json"
		// Log JSON inference if it was inferred
		if strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "{") || strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "[") {
			fmt.Fprintf(os.Stderr, "Inferred Content-Type: application/json\n")
		}
	} else if plan.Body.Type == "form" {
		contentType = "application/x-www-form-urlencoded"
	}

	return strings.NewReader(plan.Body.Content), contentType, nil
}

// buildMultipartBody builds a multipart/form-data body.
func (e *Executor) buildMultipartBody(bodyPlan *planner.BodyPlan) (io.Reader, string, error) {
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	boundary := bodyPlan.Boundary
	if boundary == "" {
		boundary = writer.Boundary()
	} else {
		writer.SetBoundary(boundary)
	}

	for _, part := range bodyPlan.AttachParts {
		var partWriter io.Writer
		var err error

		// Create form field
		if part.Filename != "" {
			partWriter, err = writer.CreateFormFile(part.Name, part.Filename)
		} else {
			partWriter, err = writer.CreateFormField(part.Name)
		}
		if err != nil {
			return nil, "", fmt.Errorf("failed to create form field: %w", err)
		}

		// Write part content
		if part.FilePath != "" {
			// Read file
			data, err := os.ReadFile(part.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", part.FilePath, err)
			}
			if _, err := partWriter.Write(data); err != nil {
				return nil, "", fmt.Errorf("failed to write file data: %w", err)
			}
		} else {
			// Write value
			if _, err := partWriter.Write([]byte(part.Value)); err != nil {
				return nil, "", fmt.Errorf("failed to write value: %w", err)
			}
		}
	}

	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
	return &buf, contentType, nil
}

// setHeaders sets request headers.
func (e *Executor) setHeaders(req *http.Request, plan *planner.ExecutionPlan, contentType string) {
	// Set user headers first
	for k, v := range plan.Headers {
		req.Header.Set(k, v)
	}

	// Override Content-Type if multipart (user may have set it manually)
	if plan.Body != nil && plan.Body.Type == "multipart" {
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
			// Check if user had set Content-Type manually
			if _, wasSet := plan.Headers["Content-Type"]; wasSet {
				fmt.Fprintf(os.Stderr, "Note: Content-Type overridden for multipart\n")
			}
		}
	} else if contentType != "" && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", contentType)
	}
}

// setCookies sets request cookies.
func (e *Executor) setCookies(req *http.Request, plan *planner.ExecutionPlan) {
	for name, value := range plan.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}
}

// autoApplySession automatically applies a stored session if available.
func (e *Executor) autoApplySession(req *http.Request, plan *planner.ExecutionPlan) {
	// Don't auto-apply if Authorization or Cookie headers are explicitly set
	hasAuth := req.Header.Get("Authorization") != ""
	hasCookie := false
	for name := range plan.Cookies {
		if name != "" {
			hasCookie = true
			break
		}
	}
	if hasAuth || hasCookie {
		return
	}

	// Extract host from URL
	host, err := session.ExtractHost(plan.URL)
	if err != nil {
		return
	}

	// Load session
	sess, err := session.LoadSession(host)
	if err != nil || sess == nil {
		return
	}

	// Apply authorization if available
	if sess.Authorization != "" {
		req.Header.Set("Authorization", sess.Authorization)
	}

	// Apply cookies
	for name, value := range sess.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}

	fmt.Fprintf(os.Stderr, "Using session for %s\n", host)
}

// executeWithRedirects executes the request with redirect handling.
func (e *Executor) executeWithRedirects(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, error) {
	maxRedirects := 5
	var redirectTrace []string

	// Determine redirect policy based on verb
	shouldFollow := false
	isWriteVerb := plan.Method == "POST" || plan.Method == "PUT" || plan.Method == "PATCH" || plan.Method == "DELETE"

	if plan.Follow == "smart" {
		// Smart follow: only follow 307/308 for write verbs
		shouldFollow = true
	} else {
		// Default: read and save follow, write verbs don't
		if plan.Verb == types.VerbRead || plan.Verb == types.VerbSave {
			shouldFollow = true
		} else if isWriteVerb {
			shouldFollow = false
		} else {
			// Other verbs (watch, inspect) don't follow by default
			shouldFollow = false
		}
	}

	if !shouldFollow {
		resp, err := e.client.Do(req)
		if err == nil && isWriteVerb && (resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303) {
			redirectTrace = append(redirectTrace, fmt.Sprintf("Advisory: %d redirect for write verb, not following", resp.StatusCode))
		}
		return resp, redirectTrace, err
	}

	// Follow redirects
	redirects := 0
	client := *e.client
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if redirects >= maxRedirects {
			return fmt.Errorf("stopped after %d redirects", maxRedirects)
		}

		// For smart follow with write verbs, only follow 307/308
		if plan.Follow == "smart" && isWriteVerb {
			statusCode := via[len(via)-1].Response.StatusCode
			if statusCode != 307 && statusCode != 308 {
				return fmt.Errorf("write verb: not following %d redirect (use 307/308)", statusCode)
			}
		}

		redirects++
		statusCode := via[len(via)-1].Response.StatusCode
		redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", statusCode, req.Method, req.URL.String()))
		return nil
	}

	resp, err := client.Do(req)
	return resp, redirectTrace, err
}

// readAndDecompress reads and decompresses the response body.
func (e *Executor) readAndDecompress(resp *http.Response) ([]byte, bool, error) {
	body := resp.Body
	decompressed := false

	// Check if compressed
	encoding := resp.Header.Get("Content-Encoding")
	if encoding == "gzip" {
		reader, err := gzip.NewReader(body)
		if err != nil {
			return nil, false, fmt.Errorf("failed to create gzip reader: %w", err)
		}
		defer reader.Close()
		body = reader
		decompressed = true
	} else if encoding == "br" {
		// Brotli decompression would require a library
		// For now, just read as-is
		// TODO: Add brotli support
	}

	data, err := io.ReadAll(body)
	return data, decompressed, err
}

// runExpectChecks runs expectation checks on the response.
func (e *Executor) runExpectChecks(resp *http.Response, body []byte, checks []types.ExpectCheck) error {
	for _, check := range checks {
		if err := e.runExpectCheck(resp, body, check); err != nil {
			return err
		}
	}
	return nil
}

// runExpectCheck runs a single expectation check.
func (e *Executor) runExpectCheck(resp *http.Response, body []byte, check types.ExpectCheck) error {
	switch check.Type {
	case "status":
		expected := check.Value
		actual := fmt.Sprintf("%d", resp.StatusCode)
		if actual != expected {
			return fmt.Errorf("expected status %s, got %s", expected, actual)
		}

	case "header":
		actual := resp.Header.Get(check.Name)
		if actual != check.Value {
			return fmt.Errorf("expected header %s=%s, got %s", check.Name, check.Value, actual)
		}

	case "contains":
		if !strings.Contains(string(body), check.Value) {
			return fmt.Errorf("expected body to contain %q", check.Value)
		}

	case "jsonpath":
		// Simple JSON path extraction (basic implementation)
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			return fmt.Errorf("failed to parse JSON: %w", err)
		}
		// TODO: Implement proper JSONPath evaluation
		// For now, just check if JSON is valid
		_ = data

	case "matches":
		matched, err := regexp.MatchString(check.Regex, string(body))
		if err != nil {
			return fmt.Errorf("invalid regex: %w", err)
		}
		if !matched {
			return fmt.Errorf("body does not match regex %q", check.Regex)
		}

	default:
		return fmt.Errorf("unknown expect check type: %s", check.Type)
	}

	return nil
}

// printMeta prints metadata to stderr.
func (e *Executor) printMeta(resp *http.Response, url string, bodySize int, decompressed bool) {
	fmt.Fprintf(os.Stderr, "HTTP %d\n", resp.StatusCode)
	fmt.Fprintf(os.Stderr, "URL: %s\n", url)
	fmt.Fprintf(os.Stderr, "Size: %d bytes\n", bodySize)
	if ct := resp.Header.Get("Content-Type"); ct != "" {
		fmt.Fprintf(os.Stderr, "Content-Type: %s\n", ct)
	}
}

// writeOutput formats and writes output to stdout.
func (e *Executor) writeOutput(body []byte, output *planner.OutputPlan) error {
	if output == nil {
		// Default: raw output
		_, err := os.Stdout.Write(body)
		return err
	}

	switch output.Format {
	case "json":
		// Pretty print JSON
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			// Not JSON, output as-is
			_, err := os.Stdout.Write(body)
			return err
		}
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)

	case "text":
		// Output as text
		_, err := os.Stdout.Write(body)
		return err

	case "raw":
		// Raw output
		_, err := os.Stdout.Write(body)
		return err

	case "csv":
		// CSV output (basic - would need proper CSV parsing)
		_, err := os.Stdout.Write(body)
		return err

	default:
		// Default: raw
		_, err := os.Stdout.Write(body)
		return err
	}
}

// saveToFile saves the response body to a file.
func (e *Executor) saveToFile(body io.Reader, destination string) error {
	// Create directory if needed
	dir := filepath.Dir(destination)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Create file
	file, err := os.Create(destination)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Copy response body to file
	_, err = io.Copy(file, body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// getInsecureTLSConfig returns an insecure TLS config.
func getInsecureTLSConfig() *tls.Config {
	return &tls.Config{
		InsecureSkipVerify: true,
	}
}

// ExecuteWithResponse executes an HTTP request and returns the response body as a string.
// This is useful for TUI mode where we need to capture and format the response.
func (e *Executor) ExecuteWithResponse(plan *planner.ExecutionPlan) (string, error) {
	// Build request URL with query parameters
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return "", fmt.Errorf("failed to build body: %w", err)
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Execute request
	resp, _, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and decompress response body
	bodyBytes, _, err := e.readAndDecompress(resp)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(bodyBytes), nil
}

----
internal/session/session.go
// Package session manages HTTP sessions (cookies and tokens) per host.
package session

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Session represents a stored session for a host.
type Session struct {
	Host          string            `json:"host"`
	Cookies       map[string]string `json:"cookies,omitempty"`
	Authorization string            `json:"authorization,omitempty"` // Bearer token
}

var (
	stateDir     string
	stateDirOnce sync.Once
)

// getStateDir returns the user state directory for storing sessions.
func getStateDir() string {
	stateDirOnce.Do(func() {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to current directory
			stateDir = ".req"
			return
		}
		stateDir = filepath.Join(homeDir, ".config", "req")
	})
	return stateDir
}

// ensureStateDir ensures the state directory exists with proper permissions.
func ensureStateDir() error {
	dir := getStateDir()
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}
	return nil
}

// getSessionPath returns the file path for a host's session.
func getSessionPath(host string) (string, error) {
	if err := ensureStateDir(); err != nil {
		return "", err
	}
	// Sanitize host name for filename
	safeHost := strings.ReplaceAll(host, ":", "_")
	safeHost = strings.ReplaceAll(safeHost, "/", "_")
	return filepath.Join(getStateDir(), fmt.Sprintf("session_%s.json", safeHost)), nil
}

// LoadSession loads a session for the given host.
func LoadSession(host string) (*Session, error) {
	path, err := getSessionPath(host)
	if err != nil {
		return nil, err
	}

	// Check file permissions - refuse to load if group or world readable
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // No session exists
		}
		return nil, fmt.Errorf("failed to stat session file: %w", err)
	}

	mode := info.Mode().Perm()
	// Check if group or others have read permission (044, 004, or any combination)
	if mode&0044 != 0 {
		return nil, fmt.Errorf("session file %s has insecure permissions (%s): group or world readable, refusing to load", path, mode.String())
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read session: %w", err)
	}

	var session Session
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, fmt.Errorf("failed to parse session: %w", err)
	}

	return &session, nil
}

// SaveSession saves a session for the given host.
func SaveSession(session *Session) error {
	path, err := getSessionPath(session.Host)
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal session: %w", err)
	}

	// Write with strict permissions (0600)
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write session: %w", err)
	}

	return nil
}

// DeleteSession deletes a session for the given host.
func DeleteSession(host string) error {
	path, err := getSessionPath(host)
	if err != nil {
		return err
	}

	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil // Already deleted
		}
		return fmt.Errorf("failed to delete session: %w", err)
	}

	return nil
}

// ExtractHost extracts the host from a URL.
func ExtractHost(urlStr string) (string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}
	return u.Host, nil
}

// UpdateSessionFromResponse updates a session from an HTTP response.
// Captures Set-Cookie headers and access_token from JSON body.
func UpdateSessionFromResponse(host string, setCookies []string, body []byte) (*Session, error) {
	session, err := LoadSession(host)
	if err != nil {
		return nil, err
	}

	if session == nil {
		session = &Session{
			Host:    host,
			Cookies: make(map[string]string),
		}
	}

	// Parse Set-Cookie headers
	for _, cookieHeader := range setCookies {
		// Simple cookie parsing (just get name=value part)
		parts := strings.Split(cookieHeader, ";")
		if len(parts) > 0 {
			cookiePart := strings.TrimSpace(parts[0])
			eqIdx := strings.Index(cookiePart, "=")
			if eqIdx > 0 {
				name := cookiePart[:eqIdx]
				value := cookiePart[eqIdx+1:]
				session.Cookies[name] = value
			}
		}
	}

	// Try to extract access_token from JSON body
	if len(body) > 0 {
		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err == nil {
			if token, ok := jsonData["access_token"].(string); ok && token != "" {
				session.Authorization = "Bearer " + token
			}
		}
	}

	return session, nil
}

// ListSessions lists all stored sessions.
func ListSessions() ([]string, error) {
	dir := getStateDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read state directory: %w", err)
	}

	var hosts []string
	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "session_") && strings.HasSuffix(entry.Name(), ".json") {
			// Extract host from filename
			host := strings.TrimPrefix(entry.Name(), "session_")
			host = strings.TrimSuffix(host, ".json")
			host = strings.ReplaceAll(host, "_", ":")
			hosts = append(hosts, host)
		}
	}

	return hosts, nil
}

// RedactSession creates a redacted version of a session for display.
func RedactSession(session *Session) *Session {
	redacted := &Session{
		Host:          session.Host,
		Cookies:       make(map[string]string),
		Authorization: "",
	}

	// Redact cookies (show only names)
	for name := range session.Cookies {
		redacted.Cookies[name] = "***"
	}

	// Redact authorization
	if session.Authorization != "" {
		redacted.Authorization = "Bearer ***"
	}

	return redacted
}


----
internal/tui/app.go
// Package tui provides an interactive terminal user interface for req.
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/adammpkins/req/internal/tui/views"
)

// Launch starts the TUI application.
func Launch() error {
	p := tea.NewProgram(NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run TUI: %w", err)
	}
	return nil
}

// Model represents the application state.
type Model struct {
	view View
}

// NewModel creates a new TUI model.
func NewModel() Model {
	return Model{
		view: views.NewBuilderView(),
	}
}

// Init initializes the model.
func (m Model) Init() tea.Cmd {
	// WindowSizeMsg will be sent automatically by bubbletea
	return m.view.Init()
}

// Update handles messages and updates the model.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		// Pass window size to view
		var cmd tea.Cmd
		m.view, cmd = m.view.Update(msg)
		return m, cmd
	}

	var cmd tea.Cmd
	m.view, cmd = m.view.Update(msg)
	return m, cmd
}

// View renders the current view.
func (m Model) View() string {
	return m.view.View()
}

// View represents a TUI view (exported from views package).
type View = views.View


----
internal/tui/views/builder.go
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("62")).
			Padding(1, 2)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Padding(1, 2).
			Width(80)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46")).
			Padding(1, 2).
			Width(80)

	commandStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252")).
			Padding(1, 2).
			Width(80)

	// JSON syntax highlighting styles
	jsonKeyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true)

	jsonStringStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46"))

	jsonNumberStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("220"))

	jsonBoolStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("213"))

	jsonNullStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			Italic(true)

	jsonPunctStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252"))

	outputStyle = lipgloss.NewStyle().
			Padding(1, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("62"))
)

// View represents a TUI view interface.
type View interface {
	Init() tea.Cmd
	Update(msg tea.Msg) (View, tea.Cmd)
	View() string
}

// BuilderView is an interactive command builder.
type BuilderView struct {
	form         *huh.Form
	executed     bool
	response     string
	responseBody string
	formattedBody string
	err          error
	verb         string
	url          string
	execute      bool
	width        int
	height       int
	viewport     viewport.Model
}

// NewBuilderView creates a new builder view.
func NewBuilderView() View {
	vp := viewport.New(80, 20) // default width and height
	b := &BuilderView{
		width:    80, // default width
		height:   20, // default height
		viewport: vp,
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Verb").
				Description("Select the action to perform").
				Options(
					huh.NewOption("read - Read a resource (GET)", "read"),
					huh.NewOption("save - Save a resource to file (GET)", "save"),
					huh.NewOption("send - Send data (POST)", "send"),
				).
				Value(&b.verb).
				Key("verb"),

			huh.NewInput().
				Title("URL").
				Description("Enter the target URL").
				Placeholder("https://api.example.com/users").
				Value(&b.url).
				Key("url"),

			huh.NewConfirm().
				Title("Execute immediately?").
				Description("Execute the command when form is complete").
				Value(&b.execute).
				Key("execute"),
		),
	)

	b.form = form
	return b
}

// Init initializes the view.
func (b *BuilderView) Init() tea.Cmd {
	return b.form.Init()
}

// Update handles messages.
func (b *BuilderView) Update(msg tea.Msg) (View, tea.Cmd) {
	var cmds []tea.Cmd

	// Handle window size messages first
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		b.width = msg.Width
		b.height = msg.Height
		if b.width == 0 {
			b.width = 80 // default width
		}
		if b.height == 0 {
			b.height = 20 // default height
		}
		// Update viewport size
		b.updateViewportSize()
	}

	// Handle keyboard input
	switch msg := msg.(type) {
	case tea.KeyMsg:
		key := msg.String()
		
		// If we have output to scroll, handle scrolling keys first
		if b.formattedBody != "" {
			// Check if it's a scrolling key
			switch key {
			case "up", "k", "pgup":
				b.viewport.LineUp(1)
				return b, nil
			case "down", "j", "pgdown":
				b.viewport.LineDown(1)
				return b, nil
			case "home":
				b.viewport.GotoTop()
				return b, nil
			case "end":
				b.viewport.GotoBottom()
				return b, nil
			case "ctrl+u":
				b.viewport.LineUp(b.viewport.Height / 2)
				return b, nil
			case "ctrl+d":
				b.viewport.LineDown(b.viewport.Height / 2)
				return b, nil
			case "esc":
				return b, tea.Quit
			}
		} else {
			// No output, just handle quit
			switch key {
			case "esc":
				return b, tea.Quit
			}
		}
	}

	// Update form (only if not a scrolling key when we have output)
	form, cmd := b.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		b.form = f
		cmds = append(cmds, cmd)
	}

	// Handle messages from command execution
	switch msg := msg.(type) {
	case ErrorMsg:
		b.err = msg.Err
		b.executed = false
		b.responseBody = ""
		b.formattedBody = ""
		b.viewport.SetContent("")
	case SuccessMsg:
		b.response = msg.Message
		b.responseBody = msg.ResponseBody
		b.err = nil
		// Format the response body
		b.updateFormattedBody()
	}
	
	// Handle viewport updates for other messages (like mouse wheel, etc.)
	if b.formattedBody != "" {
		vp, cmd := b.viewport.Update(msg)
		b.viewport = vp
		if cmd != nil {
			cmds = append(cmds, cmd)
		}
	}

	// Check if form is complete and should execute
	if b.form.State == huh.StateCompleted {
		if !b.executed && b.verb != "" && b.url != "" {
			// Values are already bound to b.verb, b.url, and b.execute via Value() in form creation
			// The bound variables are updated automatically when form fields change
			if b.execute {
				b.executed = true
				cmds = append(cmds, b.executeCommand())
			} else {
				// Form completed but execute was false - show message
				b.response = "Command built but not executed. Press 'esc' to exit."
			}
		}
	}

	return b, tea.Batch(cmds...)
}

// executeCommand executes the built command.
func (b *BuilderView) executeCommand() tea.Cmd {
	return func() tea.Msg {
		// Build command string
		cmdStr := fmt.Sprintf("%s %s", b.verb, b.url)
		
		// Parse command
		cmd, err := parser.Parse(cmdStr)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Plan execution
		plan, err := planner.Plan(cmd)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Execute
		executor, err := runtime.NewExecutor(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Capture response body for TUI display
		responseBody, err := executor.ExecuteWithResponse(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		return SuccessMsg{
			Message:      "Command executed successfully",
			ResponseBody: responseBody,
		}
	}
}

// View renders the view.
func (b *BuilderView) View() string {
	var s strings.Builder

	s.WriteString(titleStyle.Render("req - Interactive Command Builder"))
	s.WriteString("\n\n")

	if b.err != nil {
		s.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", b.err)))
		s.WriteString("\n\n")
	}

	if b.response != "" {
		s.WriteString(successStyle.Render(b.response))
		s.WriteString("\n\n")
	}

	// Display response body with formatting (using viewport for scrolling)
	if b.formattedBody != "" {
		// Calculate available width and height for viewport
		contentWidth := b.width - 6 // Account for border and padding
		if contentWidth < 20 {
			contentWidth = 20 // Minimum width
		}
		
		// Calculate available height (account for header, success message, form, command line, instructions)
		// Rough estimate: title ~3, success ~2, form ~varies, command ~2, instructions ~1 = ~8-10 lines
		// Reserve some space for the form and other UI elements
		availableHeight := b.height - 15 // Reserve space for other UI elements
		if availableHeight < 5 {
			availableHeight = 5 // Minimum height
		}
		
		// Update viewport dimensions if needed
		b.updateViewportSize()
		
		// Render viewport with border
		// The viewport handles its own height, so we just need to wrap it with the border style
		viewportContent := b.viewport.View()
		// Use the viewport's actual dimensions for the border
		s.WriteString(outputStyle.Width(contentWidth + 4).Render(viewportContent))
		s.WriteString("\n\n")
	}

	s.WriteString(b.form.View())
	
	// Show current values when form is completed
	if b.form.State == huh.StateCompleted {
		s.WriteString("\n\n")
		if b.verb != "" && b.url != "" {
			cmdText := fmt.Sprintf("Command: %s %s", b.verb, b.url)
			// Wrap the command text to fit terminal width
			width := b.width
			if width == 0 {
				width = 80 // default width
			}
			wrapped := wrapText(cmdText, width)
			s.WriteString(commandStyle.Render(wrapped))
			s.WriteString("\n")
			if b.response != "" {
				s.WriteString("\n")
			}
		}
	}
	
	s.WriteString("\n")
	if b.formattedBody != "" {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit, ↑/↓ to scroll, pgup/pgdn for page scroll\n")
	} else {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit\n")
	}

	return s.String()
}

// ErrorMsg represents an error message.
type ErrorMsg struct {
	Err error
}

// SuccessMsg represents a success message.
type SuccessMsg struct {
	Message      string
	ResponseBody string
}

// wrapText wraps text to the specified width, breaking at word boundaries.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}
	
	var result strings.Builder
	words := strings.Fields(text)
	currentLine := ""
	
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		if len(testLine) > width {
			if currentLine != "" {
				result.WriteString(currentLine)
				result.WriteString("\n")
				currentLine = word
			} else {
				// Word is longer than width, just add it
				result.WriteString(word)
				result.WriteString("\n")
				currentLine = ""
			}
		} else {
			currentLine = testLine
		}
	}
	
	if currentLine != "" {
		result.WriteString(currentLine)
	}
	
	return result.String()
}

// updateFormattedBody formats the response body and updates the viewport content.
func (b *BuilderView) updateFormattedBody() {
	if b.responseBody == "" {
		b.formattedBody = ""
		b.viewport.SetContent("")
		return
	}
	
	// Calculate available width for content
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	// Format the response
	formatted := formatResponse(b.responseBody, contentWidth)
	b.formattedBody = formatted
	
	// Update viewport content
	b.viewport.SetContent(formatted)
	b.viewport.GotoTop() // Start at the top
}

// updateViewportSize updates the viewport dimensions based on available space.
func (b *BuilderView) updateViewportSize() {
	if b.responseBody == "" {
		return
	}
	
	// Calculate available width and height
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	availableHeight := b.height - 15 // Reserve space for other UI elements
	if availableHeight < 5 {
		availableHeight = 5 // Minimum height
	}
	
	// Update viewport dimensions
	b.viewport.Width = contentWidth
	b.viewport.Height = availableHeight
	
	// If content is already set, ensure it's properly sized
	if b.formattedBody != "" {
		b.viewport.SetContent(b.formattedBody)
	}
}

// formatResponse formats the response body with syntax highlighting for JSON.
func formatResponse(body string, width int) string {
	// Try to parse as JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(body), &jsonData); err == nil {
		// It's valid JSON, format it with syntax highlighting
		return formatJSON(body, width)
	}

	// Not JSON, return as-is with word wrapping
	return wrapText(body, width)
}

// formatJSON formats JSON with syntax highlighting using lipgloss.
func formatJSON(jsonStr string, width int) string {
	// First, pretty-print the JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(jsonStr), &jsonData); err != nil {
		return jsonStr // Return original if parsing fails
	}

	prettyJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return jsonStr // Return original if formatting fails
	}

	// Now apply syntax highlighting
	lines := strings.Split(string(prettyJSON), "\n")
	var formattedLines []string

	for _, line := range lines {
		formattedLine := highlightJSONLine(line)
		formattedLines = append(formattedLines, formattedLine)
	}

	return strings.Join(formattedLines, "\n")
}

// highlightJSONLine applies syntax highlighting to a single line of JSON.
func highlightJSONLine(line string) string {
	// This is a simple JSON highlighter that handles common cases
	// For a more robust solution, consider using a proper JSON tokenizer
	
	result := ""
	i := 0
	
	for i < len(line) {
		char := line[i]
		
		// Skip whitespace
		if char == ' ' || char == '\t' {
			result += string(char)
			i++
			continue
		}
		
		// Handle string literals
		if char == '"' {
			end := i + 1
			escaped := false
			for end < len(line) {
				if line[end] == '\\' && !escaped {
					escaped = true
					end++
				} else if line[end] == '"' && !escaped {
					end++
					// Check if this is a key (followed by :)
					isKey := end < len(line) && line[end] == ':'
					str := line[i:end]
					if isKey {
						result += jsonKeyStyle.Render(str)
					} else {
						result += jsonStringStyle.Render(str)
					}
					i = end
					break
				} else {
					escaped = false
					end++
				}
			}
			if end >= len(line) {
				// Unterminated string, just add it
				result += jsonStringStyle.Render(line[i:])
				break
			}
			continue
		}
		
		// Handle numbers
		if (char >= '0' && char <= '9') || char == '-' {
			start := i
			for i < len(line) && ((line[i] >= '0' && line[i] <= '9') || 
				line[i] == '.' || line[i] == 'e' || line[i] == 'E' || 
				line[i] == '+' || line[i] == '-' || line[i] == 'i' || 
				line[i] == 'n' || line[i] == 'f') {
				i++
			}
			result += jsonNumberStyle.Render(line[start:i])
			continue
		}
		
		// Handle boolean and null
		if strings.HasPrefix(line[i:], "true") {
			result += jsonBoolStyle.Render("true")
			i += 4
			continue
		}
		if strings.HasPrefix(line[i:], "false") {
			result += jsonBoolStyle.Render("false")
			i += 5
			continue
		}
		if strings.HasPrefix(line[i:], "null") {
			result += jsonNullStyle.Render("null")
			i += 4
			continue
		}
		
		// Handle punctuation
		if char == '{' || char == '}' || char == '[' || char == ']' || 
		   char == ',' || char == ':' {
			result += jsonPunctStyle.Render(string(char))
			i++
			continue
		}
		
		// Default: just add the character
		result += string(char)
		i++
	}
	
	return result
}

----
internal/types/command.go
// Package types provides shared types and enums used across the req package.
package types

import "time"

// Verb represents the action verb in a req command.
type Verb string

const (
	VerbRead         Verb = "read"
	VerbSave         Verb = "save"
	VerbSend         Verb = "send"
	VerbUpload       Verb = "upload"
	VerbWatch        Verb = "watch"
	VerbInspect      Verb = "inspect"
	VerbAuthenticate Verb = "authenticate"
	VerbSession      Verb = "session"
)

// Command represents a parsed req command AST.
type Command struct {
	Verb    Verb
	Target  Target
	Clauses []Clause
	// For session verb, subcommand (show, clear, use)
	SessionSubcommand string
}

// Target represents the URL or resource being acted upon.
type Target struct {
	URL string
}

// Clause represents a modifier clause in the command.
// This is a sum type that will be expanded as we add more clause types.
type Clause interface {
	clause()
}

// WithClause represents a "with=" clause for request body.
type WithClause struct {
	Value    string // inline value, file path, or "-" for stdin
	Type     string // json, form, etc. (inferred if empty)
	IsFile   bool   // true if value starts with @
	IsStdin  bool   // true if value is @-
}

func (WithClause) clause() {}

// HeadersClause represents a "headers=" clause.
type HeadersClause struct {
	Headers map[string]string
}

func (HeadersClause) clause() {}

// ParamsClause represents a "params=" clause for query parameters.
type ParamsClause struct {
	Params map[string]string
}

func (ParamsClause) clause() {}

// AsClause represents an "as=" clause for output format.
type AsClause struct {
	Format string // json, csv, text, raw
}

func (AsClause) clause() {}

// ToClause represents a "to=" clause for destination.
type ToClause struct {
	Destination string
}

func (ToClause) clause() {}

// UsingClause represents a "using=" clause for HTTP method override.
type UsingClause struct {
	Method string // GET, POST, PUT, PATCH, DELETE, etc.
}

func (UsingClause) clause() {}

// RetryClause represents a "retry=" clause.
type RetryClause struct {
	Count int
}

func (RetryClause) clause() {}

// BackoffClause represents a "backoff=" clause.
type BackoffClause struct {
	Min time.Duration
	Max time.Duration
}

func (BackoffClause) clause() {}

// TimeoutClause represents a "timeout=" clause.
type TimeoutClause struct {
	Duration time.Duration
}

func (TimeoutClause) clause() {}

// ProxyClause represents a "proxy=" clause.
type ProxyClause struct {
	URL string
}

func (ProxyClause) clause() {}

// PickClause represents a "pick=" clause for JSON path selection.
type PickClause struct {
	Path string // JSONPath expression
}

func (PickClause) clause() {}

// EveryClause represents an "every=" clause for polling.
type EveryClause struct {
	Interval time.Duration
}

func (EveryClause) clause() {}

// UntilClause represents an "until=" clause for conditional polling.
type UntilClause struct {
	Predicate string
}

func (UntilClause) clause() {}

// FieldClause represents a "field=" clause for multipart uploads.
type FieldClause struct {
	Name  string
	Value string
}

func (FieldClause) clause() {}

// VerboseClause represents the "verbose" flag.
type VerboseClause struct{}

func (VerboseClause) clause() {}

// ResumeClause represents the "resume" flag for resumable downloads.
type ResumeClause struct{}

func (ResumeClause) clause() {}

// IncludeClause represents an "include=" clause for headers, params, and cookies.
type IncludeClause struct {
	Items []IncludeItem
}

func (IncludeClause) clause() {}

// IncludeItem represents a single item in an include clause.
type IncludeItem struct {
	Type  string // "header", "param", "cookie"
	Name  string // header name, param key, or cookie key
	Value string // header value, param value, or cookie value
}

// AttachClause represents an "attach=" clause for multipart form data.
type AttachClause struct {
	Parts    []AttachPart
	Boundary string // optional explicit boundary
}

func (AttachClause) clause() {}

// AttachPart represents a single part in an attach clause.
type AttachPart struct {
	Name     string // required
	FilePath string // file=@path (mutually exclusive with Value)
	Value    string // value=... (mutually exclusive with FilePath)
	Filename string // optional filename
	Type     string // optional Content-Type
}

// ExpectClause represents an "expect=" clause for response assertions.
type ExpectClause struct {
	Checks []ExpectCheck
}

func (ExpectClause) clause() {}

// ExpectCheck represents a single assertion check.
type ExpectCheck struct {
	Type  string // "status", "header", "contains", "jsonpath", "matches"
	Name  string // for header checks, the header name
	Value string // the value to check against
	Path  string // for jsonpath, the JSONPath expression
	Regex string // for matches, the regex pattern
}

// FollowClause represents a "follow=" clause for redirect policy.
type FollowClause struct {
	Policy string // "smart" or empty for default
}

func (FollowClause) clause() {}

// UnderClause represents an "under=" clause for timeout or size limit.
type UnderClause struct {
	Duration time.Duration // if it's a duration
	Size     int64         // if it's a size (in bytes)
	IsSize   bool          // true if it's a size limit, false if duration
}

func (UnderClause) clause() {}

// ViaClause represents a "via=" clause for proxy URL.
type ViaClause struct {
	URL string
}

func (ViaClause) clause() {}

// InsecureClause represents an "insecure=" clause (updated to support true/false).
type InsecureClause struct {
	Value bool // true or false
}

func (InsecureClause) clause() {}



----
tests/fixtures/grammar_snapshot.json
{
  "verbs": [
    "read",
    "save",
    "send",
    "upload",
    "watch",
    "inspect",
    "authenticate",
    "session"
  ],
  "clauses": [
    {
      "name": "using=",
      "description": "HTTP method override",
      "repeatable": false
    },
    {
      "name": "include=",
      "description": "Add headers, params, cookies",
      "repeatable": true
    },
    {
      "name": "with=",
      "description": "Request body",
      "repeatable": false
    },
    {
      "name": "expect=",
      "description": "Assertions on response",
      "repeatable": false
    },
    {
      "name": "as=",
      "description": "Output format for stdout",
      "repeatable": false
    },
    {
      "name": "to=",
      "description": "Destination path",
      "repeatable": false
    },
    {
      "name": "retry=",
      "description": "Retry attempts for transient errors",
      "repeatable": false
    },
    {
      "name": "under=",
      "description": "Timeout or size limit",
      "repeatable": false
    },
    {
      "name": "via=",
      "description": "Proxy URL",
      "repeatable": false
    },
    {
      "name": "attach=",
      "description": "Multipart parts for upload or send",
      "repeatable": true
    },
    {
      "name": "follow=",
      "description": "Redirect policy for write verbs",
      "repeatable": false
    },
    {
      "name": "insecure=",
      "description": "Disable TLS verification for this request",
      "repeatable": false
    }
  ]
}


----
tests/grammar_drift_test.go
package tests

import (
	"encoding/json"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/grammar"
)

// TestGrammarDrift ensures the binary help output matches the grammar snapshot.
func TestGrammarDrift(t *testing.T) {
	// Get expected snapshot from grammar package
	expectedJSON, err := grammar.GetSnapshotJSON()
	if err != nil {
		t.Fatalf("Failed to generate expected snapshot: %v", err)
	}

	var expected grammar.Snapshot
	if err := json.Unmarshal(expectedJSON, &expected); err != nil {
		t.Fatalf("Failed to unmarshal expected snapshot: %v", err)
	}

	// Load actual snapshot from file
	snapshotPath := filepath.Join("fixtures", "grammar_snapshot.json")
	actualJSON, err := os.ReadFile(snapshotPath)
	if err != nil {
		t.Fatalf("Failed to read snapshot file: %v", err)
	}

	var actual grammar.Snapshot
	if err := json.Unmarshal(actualJSON, &actual); err != nil {
		t.Fatalf("Failed to unmarshal actual snapshot: %v", err)
	}

	// Compare verbs
	if len(expected.Verbs) != len(actual.Verbs) {
		t.Errorf("Verb count mismatch: expected %d, got %d", len(expected.Verbs), len(actual.Verbs))
	}

	expectedVerbs := make(map[string]bool)
	for _, v := range expected.Verbs {
		expectedVerbs[v] = true
	}
	for _, v := range actual.Verbs {
		if !expectedVerbs[v] {
			t.Errorf("Unexpected verb in snapshot: %s", v)
		}
	}
	for _, v := range expected.Verbs {
		found := false
		for _, av := range actual.Verbs {
			if av == v {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Missing verb in snapshot: %s", v)
		}
	}

	// Compare clauses
	if len(expected.Clauses) != len(actual.Clauses) {
		t.Errorf("Clause count mismatch: expected %d, got %d", len(expected.Clauses), len(actual.Clauses))
	}

	expectedClauses := make(map[string]grammar.ClauseSnapshot)
	for _, c := range expected.Clauses {
		expectedClauses[c.Name] = c
	}

	for _, ac := range actual.Clauses {
		ec, ok := expectedClauses[ac.Name]
		if !ok {
			t.Errorf("Unexpected clause in snapshot: %s", ac.Name)
			continue
		}
		if ec.Description != ac.Description {
			t.Errorf("Clause %s description mismatch: expected %q, got %q", ac.Name, ec.Description, ac.Description)
		}
		if ec.Repeatable != ac.Repeatable {
			t.Errorf("Clause %s repeatable mismatch: expected %v, got %v", ac.Name, ec.Repeatable, ac.Repeatable)
		}
	}

	for _, ec := range expected.Clauses {
		found := false
		for _, ac := range actual.Clauses {
			if ac.Name == ec.Name {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Missing clause in snapshot: %s", ec.Name)
		}
	}
}

// TestBinaryHelpDrift ensures the binary help output matches the grammar.
func TestBinaryHelpDrift(t *testing.T) {
	// Build the binary
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	// Run req help
	cmd := exec.Command(binaryPath, "help")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Failed to run req help: %v", err)
	}

	helpText := string(output)

	// Get grammar
	g := grammar.GetGrammar()

	// Check that all verbs appear in help
	for _, verb := range g.Verbs {
		if !strings.Contains(helpText, verb.Name) {
			t.Errorf("Verb %s not found in help output", verb.Name)
		}
		if !strings.Contains(helpText, verb.Description) {
			t.Errorf("Verb %s description not found in help output", verb.Name)
		}
	}

	// Check that all clauses appear in help
	for _, clause := range g.Clauses {
		if !strings.Contains(helpText, clause.Name) {
			t.Errorf("Clause %s not found in help output", clause.Name)
		}
		if !strings.Contains(helpText, clause.Description) {
			t.Errorf("Clause %s description not found in help output", clause.Name)
		}
	}
}


----
tests/parser_test.go
package tests

import (
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/types"
)

func TestParseBasicRead(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    *types.Command
		wantErr bool
	}{
		{
			name:  "simple read",
			input: "read https://api.example.com/users",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
			},
			wantErr: false,
		},
		{
			name:  "read with as clause",
			input: "read https://api.example.com/users as=json",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.AsClause{Format: "json"},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with multiple clauses",
			input: "read https://api.example.com/users as=json verbose",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.AsClause{Format: "json"},
					types.VerboseClause{},
				},
			},
			wantErr: false,
		},
		{
			name:  "send with json body",
			input: "send https://api.example.com/users with='{\"name\":\"Ada\"}'",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.WithClause{Type: "json", Value: "'{\"name\":\"Ada\"}'"},
				},
			},
			wantErr: false,
		},
		{
			name:  "save with destination",
			input: "save https://example.com/file.zip to=file.zip",
			want: &types.Command{
				Verb:   types.VerbSave,
				Target: types.Target{URL: "https://example.com/file.zip"},
				Clauses: []types.Clause{
					types.ToClause{Destination: "file.zip"},
				},
			},
			wantErr: false,
		},
		{
			name:    "invalid verb",
			input:   "invalid https://example.com",
			wantErr: true,
		},
		{
			name:    "missing target",
			input:   "read",
			wantErr: true,
		},
		{
			name:  "read with insecure clause",
			input: "read https://api.example.com/users insecure=true",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.InsecureClause{Value: true},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with timeout",
			input: "read https://api.example.com/users under=5s",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UnderClause{Duration: 5000000000, IsSize: false}, // 5s in nanoseconds
				},
			},
			wantErr: false,
		},
		{
			name:  "send with using=PUT",
			input: "send https://api.example.com/users using=PUT",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "PUT"},
				},
			},
			wantErr: false,
		},
		{
			name:  "send with using=patch (normalize to uppercase)",
			input: "send https://api.example.com/users using=patch",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "PATCH"},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with using=HEAD",
			input: "read https://api.example.com/users using=HEAD",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "HEAD"},
				},
			},
			wantErr: false,
		},
		{
			name:    "using= with invalid method",
			input:   "read https://api.example.com/users using=INVALID",
			wantErr: true,
		},
		{
			name:    "old method= syntax should error",
			input:   "read https://api.example.com/users method=PUT",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parser.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if got.Verb != tt.want.Verb {
				t.Errorf("Parse() Verb = %v, want %v", got.Verb, tt.want.Verb)
			}
			if got.Target.URL != tt.want.Target.URL {
				t.Errorf("Parse() Target.URL = %v, want %v", got.Target.URL, tt.want.Target.URL)
			}
			if len(got.Clauses) != len(tt.want.Clauses) {
				t.Errorf("Parse() Clauses length = %v, want %v", len(got.Clauses), len(tt.want.Clauses))
				return
			}
			// Check UsingClause if present
			for i, clause := range got.Clauses {
				if usingClause, ok := clause.(types.UsingClause); ok {
					if i >= len(tt.want.Clauses) {
						t.Errorf("Parse() UsingClause found but not expected")
						continue
					}
					if wantUsingClause, ok := tt.want.Clauses[i].(types.UsingClause); ok {
						if usingClause.Method != wantUsingClause.Method {
							t.Errorf("Parse() UsingClause.Method = %v, want %v", usingClause.Method, wantUsingClause.Method)
						}
					}
				}
			}
		})
	}
}

func TestParseErrorSuggestions(t *testing.T) {
	tests := []struct {
		name       string
		input      string
		wantSuggestion string
	}{
		{
			name: "typo in verb",
			input: "reed https://api.example.com/users",
			wantSuggestion: "read",
		},
		{
			name: "typo in clause",
			input: "read https://api.example.com/users ass=json",
			wantSuggestion: "as",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := parser.Parse(tt.input)
			if err == nil {
				t.Errorf("Parse() expected error but got none")
				return
			}
			parseErr, ok := err.(*parser.ParseError)
			if !ok {
				t.Errorf("Parse() error is not a ParseError: %T", err)
				return
			}
			if parseErr.Suggest != tt.wantSuggestion {
				t.Errorf("Parse() Suggest = %v, want %v", parseErr.Suggest, tt.wantSuggestion)
			}
		})
	}
}


----
tests/planner_test.go
package tests

import (
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
)

func TestPlanRead(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.AsClause{Format: "json"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Method != http.MethodGet {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodGet)
	}
	if plan.URL != "https://api.example.com/users" {
		t.Errorf("Plan() URL = %v, want %v", plan.URL, "https://api.example.com/users")
	}
	if plan.Output == nil {
		t.Errorf("Plan() Output is nil")
	} else if plan.Output.Format != "json" {
		t.Errorf("Plan() Output.Format = %v, want json", plan.Output.Format)
	}
}

func TestPlanSend(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.WithClause{Type: "json", Value: "{\"name\":\"Ada\"}"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Send with with= should default to POST
	if plan.Method != http.MethodPost {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodPost)
	}
	if plan.Body == nil {
		t.Errorf("Plan() Body is nil")
	} else if plan.Body.Type != "json" {
		t.Errorf("Plan() Body.Type = %v, want json", plan.Body.Type)
	}
}

func TestPlanSave(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSave,
		Target: types.Target{URL: "https://example.com/file.zip"},
		Clauses: []types.Clause{
			types.ToClause{Destination: "file.zip"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Method != http.MethodGet {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodGet)
	}
	if plan.Output == nil {
		t.Errorf("Plan() Output is nil")
	} else if plan.Output.Destination != "file.zip" {
		t.Errorf("Plan() Output.Destination = %v, want file.zip", plan.Output.Destination)
	}
}

func TestPlanWithTimeout(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.TimeoutClause{Duration: 5 * time.Second},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Timeout == nil {
		t.Errorf("Plan() Timeout is nil")
	} else if *plan.Timeout != 5*time.Second {
		t.Errorf("Plan() Timeout = %v, want %v", *plan.Timeout, 5*time.Second)
	}
}

func TestPlanWithRetry(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.RetryClause{Count: 3},
			types.BackoffClause{
				Min: 200 * time.Millisecond,
				Max: 5 * time.Second,
			},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Retry == nil {
		t.Errorf("Plan() Retry is nil")
	} else {
		if plan.Retry.Count != 3 {
			t.Errorf("Plan() Retry.Count = %v, want 3", plan.Retry.Count)
		}
		if plan.Retry.Backoff.Min != 200*time.Millisecond {
			t.Errorf("Plan() Retry.Backoff.Min = %v, want %v", plan.Retry.Backoff.Min, 200*time.Millisecond)
		}
		if plan.Retry.Backoff.Max != 5*time.Second {
			t.Errorf("Plan() Retry.Backoff.Max = %v, want %v", plan.Retry.Backoff.Max, 5*time.Second)
		}
	}
}

func TestPlanWithUsingOverride(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "PUT"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Method override should take precedence
	if plan.Method != "PUT" {
		t.Errorf("Plan() Method = %v, want PUT", plan.Method)
	}
}

func TestPlanWithUsingIncompatible(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "POST"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err == nil {
		t.Fatalf("Plan() expected error for incompatible verb-method combination")
	}

	// Should have error message
	if plan != nil {
		t.Errorf("Plan() should return nil on error")
	}
	
	// Check error message
	if !strings.Contains(err.Error(), "incompatible") {
		t.Errorf("Plan() error message should mention incompatibility, got: %v", err)
	}
}

func TestPlanWithUsingDeleteForSend(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "DELETE"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err == nil {
		t.Fatalf("Plan() expected error for incompatible verb-method combination")
	}

	if plan != nil {
		t.Errorf("Plan() should return nil on error")
	}
}


----
tests/redirect_compression_test.go
package tests

import (
	"bytes"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestRedirectTrace tests that redirect traces appear in stderr.
func TestRedirectTrace(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Test redirect with read verb (should follow by default)
	cmdStr := "read " + ts.URL() + "/redirect/301"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	err = executor.Execute(plan)
	os.Stderr = oldStderr
	w.Close()

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read stderr
	var buf bytes.Buffer
	buf.ReadFrom(r)
	stderr := buf.String()

	// Check for redirect trace
	if !strings.Contains(stderr, "→") {
		t.Errorf("Expected redirect trace in stderr, got: %s", stderr)
	}
	if !strings.Contains(stderr, "301") {
		t.Errorf("Expected status code 301 in redirect trace, got: %s", stderr)
	}
}

// TestCompressionTrace tests that decompression notes appear in stderr.
func TestCompressionTrace(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/gzip"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	err = executor.Execute(plan)
	os.Stderr = oldStderr
	w.Close()

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read stderr
	var buf bytes.Buffer
	buf.ReadFrom(r)
	stderr := buf.String()

	// Check for decompression note
	if !strings.Contains(stderr, "Decompressed") {
		t.Errorf("Expected decompression note in stderr, got: %s", stderr)
	}
}

// TestRedirectTraceGolden tests redirect trace output against golden file.
func TestRedirectTraceGolden(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/redirect/307"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	stderr := stderrBuf.String()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "redirect_trace.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		// Create golden file if it doesn't exist
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, []byte(stderr), 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare (normalize line endings)
	actualNorm := strings.ReplaceAll(stderr, "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Redirect trace mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestCompressionTraceGolden tests compression trace output against golden file.
func TestCompressionTraceGolden(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/gzip"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	stderr := stderrBuf.String()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "compression_trace.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		// Create golden file if it doesn't exist
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, []byte(stderr), 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare (normalize line endings)
	actualNorm := strings.ReplaceAll(stderr, "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Compression trace mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestBinaryRedirectTrace tests redirect trace using the built binary.
func TestBinaryRedirectTrace(t *testing.T) {
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	ts := NewTestServer()
	defer ts.Close()

	// Run req with redirect
	cmd := exec.Command(binaryPath, "read", ts.URL()+"/redirect/302")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Run() // Don't care about exit code, just want stderr

	output := stderr.String()
	if !strings.Contains(output, "→") {
		t.Errorf("Expected redirect trace in binary output, got: %s", output)
	}
}

// TestBinaryCompressionTrace tests compression trace using the built binary.
func TestBinaryCompressionTrace(t *testing.T) {
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	ts := NewTestServer()
	defer ts.Close()

	// Run req with gzip endpoint
	cmd := exec.Command(binaryPath, "read", ts.URL()+"/gzip")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Run() // Don't care about exit code, just want stderr

	output := stderr.String()
	if !strings.Contains(output, "Decompressed") {
		t.Errorf("Expected decompression note in binary output, got: %s", output)
	}
}


----
tests/runtime_test.go
package tests

import (
	"encoding/json"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestRuntimeReadDogFacts tests reading from a real API.
// Note: This test requires internet connectivity.
func TestRuntimeReadDogFacts(t *testing.T) {
	// Use httpbin.org as a reliable test API
	// If dog-facts-api comes back online, we can switch back
	cmdStr := "read https://httpbin.org/json"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read captured output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	// Verify output is JSON
	var data map[string]interface{}
	if err := json.Unmarshal(output, &data); err != nil {
		t.Fatalf("Output is not valid JSON: %v\nOutput: %s", err, string(output))
	}

	// Verify we got some data
	if len(data) == 0 {
		t.Errorf("Expected non-empty JSON response, got empty map")
	}

	t.Logf("Successfully received JSON response: %v", data)
}

// TestRuntimeReadMultipleDogFacts tests reading from a real API with query params.
// Note: This test requires internet connectivity.
func TestRuntimeReadMultipleDogFacts(t *testing.T) {
	// Use httpbin.org with query params
	cmdStr := "read https://httpbin.org/get?foo=bar&baz=qux"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read captured output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	// Verify output is JSON
	var data map[string]interface{}
	if err := json.Unmarshal(output, &data); err != nil {
		t.Fatalf("Output is not valid JSON: %v\nOutput: %s", err, string(output))
	}

	// Verify we got data with query params
	if args, ok := data["args"].(map[string]interface{}); ok {
		if args["foo"] != "bar" || args["baz"] != "qux" {
			t.Errorf("Expected query params foo=bar&baz=qux, got: %v", args)
		}
	} else {
		t.Errorf("Expected 'args' field in response, got: %v", data)
	}

	t.Logf("Successfully received JSON response with query params")
}

// TestRuntimeSaveDogFact tests saving API response to a file.
// Note: This test requires internet connectivity.
func TestRuntimeSaveDogFact(t *testing.T) {
	// Create a temporary file
	tmpFile, err := os.CreateTemp("", "api-response-*.json")
	if err != nil {
		t.Fatalf("CreateTemp() error = %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	cmdStr := "read https://httpbin.org/json to=" + tmpFile.Name()
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and contains valid JSON
	fileContent, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("ReadFile() error = %v", err)
	}

	var data map[string]interface{}
	if err := json.Unmarshal(fileContent, &data); err != nil {
		t.Fatalf("File content is not valid JSON: %v\nContent: %s", err, string(fileContent))
	}

	if len(data) == 0 {
		t.Errorf("Expected non-empty JSON in file, got empty map")
	}

	t.Logf("Successfully saved API response to file: %s", tmpFile.Name())
}

// TestRuntimeSaveVideoFile tests downloading a video file using the save command.
// Note: This test requires internet connectivity.
func TestRuntimeSaveVideoFile(t *testing.T) {
	// Create a temporary file
	tmpFile, err := os.CreateTemp("", "video-*.mp4")
	if err != nil {
		t.Fatalf("CreateTemp() error = %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	// Use the provided test video URL
	cmdStr := "save http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4 to=" + tmpFile.Name()
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and has content
	fileInfo, err := os.Stat(tmpFile.Name())
	if err != nil {
		t.Fatalf("Stat() error = %v", err)
	}

	if fileInfo.Size() == 0 {
		t.Error("Expected non-empty file, got empty file")
	}

	// Video files should be reasonably large (at least a few KB)
	if fileInfo.Size() < 1024 {
		t.Errorf("Expected file size >= 1KB, got %d bytes", fileInfo.Size())
	}

	// Verify file content is binary (not text)
	fileContent, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("ReadFile() error = %v", err)
	}

	// Check for MP4 file signature (ftyp box at the beginning)
	// MP4 files typically start with some metadata, but we can check for non-text content
	if len(fileContent) == 0 {
		t.Error("Expected non-empty file content")
	}

	// MP4 files typically start with specific bytes or contain binary data
	// For a simple test, verify it's not plain text by checking for null bytes
	// or non-printable characters in the first few bytes
	hasBinaryContent := false
	for i := 0; i < len(fileContent) && i < 100; i++ {
		if fileContent[i] == 0 || (fileContent[i] < 32 && fileContent[i] != 9 && fileContent[i] != 10 && fileContent[i] != 13) {
			hasBinaryContent = true
			break
		}
	}

	if !hasBinaryContent && len(fileContent) > 100 {
		// If first 100 bytes are all printable, it's likely not a binary video file
		t.Logf("Warning: File content appears to be text, expected binary video file")
	}

	t.Logf("Successfully downloaded video file: %s (size: %d bytes)", tmpFile.Name(), fileInfo.Size())
}

// TestRuntimeReadWithTimeout tests request with timeout.
// Note: This test requires internet connectivity.
func TestRuntimeReadWithTimeout(t *testing.T) {
	cmdStr := "read https://httpbin.org/json under=10s"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify we got output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(output) == 0 {
		t.Error("Expected non-empty output")
	}

	t.Logf("Successfully received response with timeout")
}

// TestRuntimeHTTPError tests handling of HTTP errors.
// Note: This test requires internet connectivity.
func TestRuntimeHTTPError(t *testing.T) {
	// Use a non-existent endpoint to trigger 404
	cmdStr := "read https://httpbin.org/status/404"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	
	// Should return an error for non-2xx status
	if err == nil {
		t.Error("Expected error for non-existent endpoint, got nil")
	}

	// Verify error message contains status code
	if !strings.Contains(err.Error(), "404") {
		t.Errorf("Expected error to contain '404', got: %v", err)
	}

	t.Logf("Successfully handled HTTP error: %v", err)
}

// TestRuntimeInvalidURL tests handling of invalid URLs.
func TestRuntimeInvalidURL(t *testing.T) {
	cmdStr := "read https://this-domain-does-not-exist-12345.example.com/nonexistent"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	
	// Should return an error for invalid domain
	if err == nil {
		t.Error("Expected error for invalid domain, got nil")
	}

	t.Logf("Successfully handled invalid URL error: %v", err)
}


----
tests/session_test.go
package tests

import (
	"bytes"
	"net/http"
	"os"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
)

// TestAuthenticateStoresSession tests that authenticate verb stores Set-Cookie and access_token.
func TestAuthenticateStoresSession(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Create a login endpoint that returns Set-Cookie and access_token
	ts.mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) {
		http.SetCookie(w, &http.Cookie{
			Name:  "session",
			Value: "test-session-123",
			Path:  "/",
		})
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte(`{"access_token": "test-token-456", "user": "test"}`))
	})

	// Clean up any existing session
	host, _ := session.ExtractHost(ts.URL())
	session.DeleteSession(host)

	cmdStr := "authenticate " + ts.URL() + "/login using=POST with='{\"user\":\"test\"}'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify session was saved
	sess, err := session.LoadSession(host)
	if err != nil {
		t.Fatalf("LoadSession() error = %v", err)
	}
	if sess == nil {
		t.Fatal("Session was not saved")
	}

	// Verify cookie was captured
	if sess.Cookies["session"] != "test-session-123" {
		t.Errorf("Expected cookie 'session'='test-session-123', got %q", sess.Cookies["session"])
	}

	// Verify access_token was captured
	if sess.Authorization != "Bearer test-token-456" {
		t.Errorf("Expected Authorization 'Bearer test-token-456', got %q", sess.Authorization)
	}

	// Verify stderr shows session saved
	stderr := stderrBuf.String()
	if !strings.Contains(stderr, "Session saved") {
		t.Errorf("Expected 'Session saved' in stderr, got: %s", stderr)
	}

	// Clean up
	session.DeleteSession(host)
}

// TestAutoApplySession tests that sessions are auto-applied for matching hosts.
func TestAutoApplySession(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "auto-applied-session"},
		Authorization: "Bearer auto-applied-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes headers
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		auth := r.Header.Get("Authorization")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"auth": "` + auth + `", "cookie": "` + cookie + `"}`))
	})

	cmdStr := "read " + ts.URL() + "/test"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify Authorization header was applied
	output := stdoutBuf.String()
	if !strings.Contains(output, "Bearer auto-applied-token") {
		t.Errorf("Expected Authorization header in request, output: %s", output)
	}

	// Verify Cookie was applied
	if !strings.Contains(output, "auto-applied-session") {
		t.Errorf("Expected session cookie in request, output: %s", output)
	}

	// Verify stderr shows session was used
	stderr := stderrBuf.String()
	if !strings.Contains(stderr, "Using session for") {
		t.Errorf("Expected 'Using session for' in stderr, got: %s", stderr)
	}
}

// TestSessionSuppression tests that explicit include of Authorization or Cookie suppresses session injection.
func TestSessionSuppression(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes headers
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		auth := r.Header.Get("Authorization")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"auth": "` + auth + `", "cookie": "` + cookie + `"}`))
	})

	// Test with explicit Authorization header
	cmdStr := "read " + ts.URL() + "/test include='header: Authorization: Bearer explicit-token'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify explicit Authorization was used, not stored session
	output := stdoutBuf.String()
	if !strings.Contains(output, "Bearer explicit-token") {
		t.Errorf("Expected explicit Authorization header, output: %s", output)
	}
	if strings.Contains(output, "Bearer stored-token") {
		t.Errorf("Stored session token should not be used when explicit header is set, output: %s", output)
	}

	// Verify stderr does NOT show "Using session for"
	stderr := stderrBuf.String()
	if strings.Contains(stderr, "Using session for") {
		t.Errorf("Session should not be auto-applied when explicit Authorization is set, stderr: %s", stderr)
	}
}

// TestSessionSuppressionWithCookie tests that explicit Cookie suppresses session injection.
func TestSessionSuppressionWithCookie(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes cookies
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"cookie": "` + cookie + `"}`))
	})

	// Test with explicit Cookie
	cmdStr := "read " + ts.URL() + "/test include='cookie: session=explicit-cookie'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify explicit cookie was used
	output := stdoutBuf.String()
	if !strings.Contains(output, "explicit-cookie") {
		t.Errorf("Expected explicit cookie, output: %s", output)
	}
	if strings.Contains(output, "stored-session") {
		t.Errorf("Stored session cookie should not be used when explicit cookie is set, output: %s", output)
	}

	// Verify stderr does NOT show "Using session for"
	stderr := stderrBuf.String()
	if strings.Contains(stderr, "Using session for") {
		t.Errorf("Session should not be auto-applied when explicit Cookie is set, stderr: %s", stderr)
	}
}

// TestSessionNotUsedMessage tests that stderr prints a message when session exists but wasn't used.
// Note: This test may need adjustment based on actual implementation behavior.
func TestSessionNotUsedMessage(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Request with explicit Authorization (suppresses session)
	cmdStr := "read " + ts.URL() + "/json include='header: Authorization: Bearer explicit'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// The current implementation doesn't print a message when session exists but wasn't used
	// This test documents the expected behavior - if we want to add this feature, we'd need
	// to modify the executor to check if a session exists but wasn't applied
	stderr := stderrBuf.String()
	// For now, just verify the request succeeded
	_ = stderr
}


----
tests/shell_quoting_test.go
package tests

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// TestShellQuotingBash tests bash quoting behavior.
func TestShellQuotingBash(t *testing.T) {
	if _, err := exec.LookPath("bash"); err != nil {
		t.Skip("bash not available")
		return
	}

	// Test command with include clause containing commas and semicolons
	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	// Create a test script that prints argv
	script := `#!/bin/bash
exec "$@" --argv-test
`
	tmpScript := filepath.Join(t.TempDir(), "test.sh")
	if err := os.WriteFile(tmpScript, []byte(script), 0755); err != nil {
		t.Fatalf("Failed to write test script: %v", err)
	}

	// Run through bash and capture output
	cmd := exec.Command("bash", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "shell_quoting_bash.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare
	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Bash quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingZsh tests zsh quoting behavior.
func TestShellQuotingZsh(t *testing.T) {
	if _, err := exec.LookPath("zsh"); err != nil {
		t.Skip("zsh not available")
		return
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	cmd := exec.Command("zsh", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_zsh.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Zsh quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingFish tests fish shell quoting behavior.
func TestShellQuotingFish(t *testing.T) {
	if _, err := exec.LookPath("fish"); err != nil {
		t.Skip("fish not available")
		return
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	cmd := exec.Command("fish", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_fish.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Fish quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingPowerShell tests PowerShell quoting behavior.
func TestShellQuotingPowerShell(t *testing.T) {
	if _, err := exec.LookPath("pwsh"); err != nil {
		if _, err := exec.LookPath("powershell"); err != nil {
			t.Skip("PowerShell not available")
			return
		}
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	var cmd *exec.Cmd
	if _, err := exec.LookPath("pwsh"); err == nil {
		cmd = exec.Command("pwsh", "-Command", testCmd+" --argv-test")
	} else {
		cmd = exec.Command("powershell", "-Command", testCmd+" --argv-test")
	}
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_powershell.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("PowerShell quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// Note: These tests require the binary to support --argv-test flag that prints argv.
// For now, they will skip if shells are not available, which is acceptable.
// The golden files can be created manually by running the commands and capturing output.


----
tests/testserver.go
// Package tests provides a local HTTP test server for integration tests.
package tests

import (
	"compress/gzip"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
)

// TestServer provides a test HTTP server with various endpoints.
type TestServer struct {
	server *httptest.Server
	mux    *http.ServeMux
}

// NewTestServer creates a new test server.
func NewTestServer() *TestServer {
	mux := http.NewServeMux()
	ts := &TestServer{
		mux: mux,
	}

	// Echo endpoint - returns request details
	mux.HandleFunc("/echo", ts.handleEcho)

	// Headers endpoint - returns request headers
	mux.HandleFunc("/headers", ts.handleHeaders)

	// Cookies endpoint - sets and returns cookies
	mux.HandleFunc("/cookies", ts.handleCookies)

	// Query endpoint - returns query parameters
	mux.HandleFunc("/query", ts.handleQuery)

	// Gzip endpoint - returns gzipped content
	mux.HandleFunc("/gzip", ts.handleGzip)

	// Redirect endpoints
	mux.HandleFunc("/redirect/301", ts.handleRedirect(301))
	mux.HandleFunc("/redirect/302", ts.handleRedirect(302))
	mux.HandleFunc("/redirect/303", ts.handleRedirect(303))
	mux.HandleFunc("/redirect/307", ts.handleRedirect(307))
	mux.HandleFunc("/redirect/308", ts.handleRedirect(308))
	mux.HandleFunc("/final", ts.handleFinal)

	// Multipart endpoint - echoes multipart form data
	mux.HandleFunc("/multipart", ts.handleMultipart)

	// JSON endpoint - returns JSON
	mux.HandleFunc("/json", ts.handleJSON)

	// Status endpoint - returns specific status code
	mux.HandleFunc("/status/", ts.handleStatus)

	ts.server = httptest.NewServer(mux)
	return ts
}

// URL returns the base URL of the test server.
func (ts *TestServer) URL() string {
	return ts.server.URL
}

// Close shuts down the test server.
func (ts *TestServer) Close() {
	ts.server.Close()
}

// handleEcho returns request details as JSON.
func (ts *TestServer) handleEcho(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{
  "method": "%s",
  "url": "%s",
  "headers": %s,
  "body": "%s"
}`, r.Method, r.URL.String(), ts.headersJSON(r), ts.bodyString(r))
}

// handleHeaders returns request headers as JSON.
func (ts *TestServer) handleHeaders(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"headers": %s}`, ts.headersJSON(r))
}

// handleCookies sets and returns cookies.
func (ts *TestServer) handleCookies(w http.ResponseWriter, r *http.Request) {
	// Set a test cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "session",
		Value: "test-session-value",
		Path:  "/",
	})

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"cookies": %s}`, ts.cookiesJSON(r))
}

// handleQuery returns query parameters as JSON.
func (ts *TestServer) handleQuery(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"query": %s}`, ts.queryJSON(r))
}

// handleGzip returns gzipped content.
func (ts *TestServer) handleGzip(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Encoding", "gzip")
	w.Header().Set("Content-Type", "text/plain")

	gz := gzip.NewWriter(w)
	defer gz.Close()
	fmt.Fprint(gz, "This is gzipped content")
}

// handleFinal is the final destination for redirects.
func (ts *TestServer) handleFinal(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	fmt.Fprint(w, "Final destination")
}

// handleRedirect returns a redirect response.
func (ts *TestServer) handleRedirect(code int) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Location", ts.server.URL+"/final")
		w.WriteHeader(code)
	}
}

// handleMultipart echoes multipart form data.
func (ts *TestServer) handleMultipart(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	err := r.ParseMultipartForm(10 << 20) // 10 MB
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Error parsing multipart: %v", err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{
  "form": %s,
  "files": %s
}`, ts.formJSON(r), ts.filesJSON(r))
}

// handleJSON returns JSON data.
func (ts *TestServer) handleJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprint(w, `{"message": "Hello, World!", "items": [1, 2, 3]}`)
}

// handleStatus returns a specific HTTP status code.
func (ts *TestServer) handleStatus(w http.ResponseWriter, r *http.Request) {
	// Extract status code from path
	path := strings.TrimPrefix(r.URL.Path, "/status/")
	var code int
	fmt.Sscanf(path, "%d", &code)
	if code == 0 {
		code = 200
	}
	w.WriteHeader(code)
	fmt.Fprintf(w, "Status %d", code)
}

// Helper functions

func (ts *TestServer) headersJSON(r *http.Request) string {
	headers := make(map[string]string)
	for k, v := range r.Header {
		headers[k] = strings.Join(v, ", ")
	}
	return fmt.Sprintf(`{"%s": "%s"}`, "User-Agent", headers["User-Agent"])
}

func (ts *TestServer) cookiesJSON(r *http.Request) string {
	cookies := make([]string, 0)
	for _, cookie := range r.Cookies() {
		cookies = append(cookies, fmt.Sprintf(`"%s=%s"`, cookie.Name, cookie.Value))
	}
	return "[" + strings.Join(cookies, ", ") + "]"
}

func (ts *TestServer) queryJSON(r *http.Request) string {
	params := make([]string, 0)
	for k, v := range r.URL.Query() {
		for _, val := range v {
			params = append(params, fmt.Sprintf(`"%s": "%s"`, k, val))
		}
	}
	return "{" + strings.Join(params, ", ") + "}"
}

func (ts *TestServer) bodyString(r *http.Request) string {
	body, _ := io.ReadAll(r.Body)
	return strings.ReplaceAll(string(body), "\"", "\\\"")
}

func (ts *TestServer) formJSON(r *http.Request) string {
	form := make([]string, 0)
	for k, v := range r.MultipartForm.Value {
		for _, val := range v {
			form = append(form, fmt.Sprintf(`"%s": "%s"`, k, val))
		}
	}
	return "{" + strings.Join(form, ", ") + "}"
}

func (ts *TestServer) filesJSON(r *http.Request) string {
	files := make([]string, 0)
	for k, v := range r.MultipartForm.File {
		for _, fh := range v {
			files = append(files, fmt.Sprintf(`"%s": "%s"`, k, fh.Filename))
		}
	}
	return "{" + strings.Join(files, ", ") + "}"
}

----
tests/watch_save_test.go
package tests

import (
	"net/http"
	"os"
	"path/filepath"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestSaveStreaming tests that save verb uses efficient file writing.
// Note: Current implementation uses io.Copy which is efficient, but reads body into memory first.
// Future optimization: stream directly from resp.Body when no expect checks are present.
func TestSaveStreaming(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Create a large response endpoint
	ts.mux.HandleFunc("/large", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain")
		// Write 1MB of data
		data := make([]byte, 1024*1024)
		for i := range data {
			data[i] = byte(i % 256)
		}
		w.Write(data)
	})

	tmpFile := filepath.Join(t.TempDir(), "output.bin")
	cmdStr := "save " + ts.URL() + "/large to=" + tmpFile
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and has correct size
	info, err := os.Stat(tmpFile)
	if err != nil {
		t.Fatalf("Failed to stat output file: %v", err)
	}

	expectedSize := int64(1024 * 1024)
	if info.Size() != expectedSize {
		t.Errorf("Expected file size %d, got %d", expectedSize, info.Size())
	}
}

// TestWatchTTYDetection tests TTY detection for watch verb.
// Note: Watch verb TTY detection is not yet implemented.
func TestWatchTTYDetection(t *testing.T) {
	t.Skip("Watch verb TTY detection not yet implemented")
}


--END--
----
go.mod
module github.com/adammpkins/req

go 1.24.0

toolchain go1.24.10

require (
	github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7
	github.com/charmbracelet/bubbletea v1.3.10
	github.com/charmbracelet/huh v0.8.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/mattn/go-isatty v0.0.20
)

require (
	github.com/andybalholm/brotli v1.2.0 // indirect
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/catppuccin/go v0.3.0 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.10.1 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13 // indirect
	github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/mitchellh/hashstructure/v2 v2.0.2 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.23.0 // indirect
)

----
go.sum
github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=
github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=
github.com/andybalholm/brotli v1.2.0 h1:ukwgCxwYrmACq68yiUqwIWnGY0cTPox/M94sVwToPjQ=
github.com/andybalholm/brotli v1.2.0/go.mod h1:rzTDkvFWvIrjDXZHkuS16NPggd91W3kUSvPlQ1pLaKY=
github.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=
github.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/aymanbagabas/go-udiff v0.3.1 h1:LV+qyBQ2pqe0u42ZsUEtPiCaUoqgA9gYRDs3vj1nolY=
github.com/aymanbagabas/go-udiff v0.3.1/go.mod h1:G0fsKmG+P6ylD0r6N/KgQD/nWzgfnl8ZBcNLgcbrw8E=
github.com/catppuccin/go v0.3.0 h1:d+0/YicIq+hSTo5oPuRi5kOpqkVA5tAsU6dNhvRu+aY=
github.com/catppuccin/go v0.3.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7 h1:JFgG/xnwFfbezlUnFMJy0nusZvytYysV4SCS2cYbvws=
github.com/charmbracelet/bubbles v0.21.1-0.20250623103423-23b8fd6302d7/go.mod h1:ISC1gtLcVilLOf23wvTfoQuYbW2q0JevFxPfUzZ9Ybw=
github.com/charmbracelet/bubbletea v1.3.10 h1:otUDHWMMzQSB0Pkc87rm691KZ3SWa4KUlvF9nRvCICw=
github.com/charmbracelet/bubbletea v1.3.10/go.mod h1:ORQfo0fk8U+po9VaNvnV95UPWA1BitP1E0N6xJPlHr4=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/huh v0.8.0 h1:Xz/Pm2h64cXQZn/Jvele4J3r7DDiqFCNIVteYukxDvY=
github.com/charmbracelet/huh v0.8.0/go.mod h1:5YVc+SlZ1IhQALxRPpkGwwEKftN/+OlJlnJYlDRFqN4=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.10.1 h1:rL3Koar5XvX0pHGfovN03f5cxLbCF2YvLeyz7D2jVDQ=
github.com/charmbracelet/x/ansi v0.10.1/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13 h1:/KBBKHuVRbq1lYx5BzEHBAFBP8VcQzJejZ/IA3iR28k=
github.com/charmbracelet/x/cellbuf v0.0.13/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=
github.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=
github.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91 h1:payRxjMjKgx2PaCWLZ4p3ro9y97+TVLZNaRZgJwSVDQ=
github.com/charmbracelet/x/exp/golden v0.0.0-20241011142426-46044092ad91/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=
github.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/charmbracelet/x/termios v0.1.1 h1:o3Q2bT8eqzGnGPOYheoYS8eEleT5ZVNYNy8JawjaNZY=
github.com/charmbracelet/x/termios v0.1.1/go.mod h1:rB7fnv1TgOPOyyKRJ9o+AsTU/vK5WHJ2ivHeut/Pcwo=
github.com/charmbracelet/x/xpty v0.1.2 h1:Pqmu4TEJ8KeA9uSkISKMU3f+C1F6OGBn8ABuGlqCbtI=
github.com/charmbracelet/x/xpty v0.1.2/go.mod h1:XK2Z0id5rtLWcpeNiMYBccNNBrP2IJnzHI0Lq13Xzq4=
github.com/creack/pty v1.1.24 h1:bJrF4RRfyJnbTJqzRLHzcGaZK1NeM5kTC9jGgovnR1s=
github.com/creack/pty v1.1.24/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=
github.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=
golang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=

----
internal/grammar/grammar.go
// Package grammar defines the structured grammar data for req commands.
package grammar

import "fmt"

// Verb represents a req command verb.
type Verb struct {
	Name        string
	Description string
}

// Clause represents a req command clause.
type Clause struct {
	Name        string
	Description string
	Repeatable  bool
	Example     string
}

// Grammar contains the complete grammar definition.
type Grammar struct {
	Verbs   []Verb
	Clauses []Clause
}

// GetGrammar returns the canonical grammar definition.
func GetGrammar() Grammar {
	return Grammar{
		Verbs: []Verb{
			{Name: "read", Description: "GET, print to stdout"},
			{Name: "save", Description: "GET, write to file via to="},
			{Name: "send", Description: "default GET, POST if with= present"},
			{Name: "upload", Description: "POST when attach= or with= present, else error"},
			{Name: "watch", Description: "GET with SSE or polling"},
			{Name: "inspect", Description: "HEAD only"},
			{Name: "authenticate", Description: "login and store session state"},
			{Name: "session", Description: "session management (show, clear, use)"},
		},
		Clauses: []Clause{
			{Name: "using=", Description: "HTTP method override", Repeatable: false, Example: "using=PUT"},
			{Name: "include=", Description: "Add headers, params, cookies, basic auth", Repeatable: true, Example: "include='header: Authorization: Bearer token; param: q=search query; basic: user:pass'"},
			{Name: "with=", Description: "Request body", Repeatable: false, Example: "with=@user.json or with='{\"name\":\"Adam\"}'"},
			{Name: "expect=", Description: "Assertions on response", Repeatable: false, Example: "expect=status:200, header:Content-Type=application/json, contains:\"ok\""},
			{Name: "as=", Description: "Output format for stdout", Repeatable: false, Example: "as=json"},
			{Name: "to=", Description: "Destination path", Repeatable: false, Example: "to=out.json"},
			{Name: "retry=", Description: "Retry attempts for transient errors", Repeatable: false, Example: "retry=3"},
			{Name: "under=", Description: "Timeout or size limit", Repeatable: false, Example: "under=30s or under=10MB"},
			{Name: "via=", Description: "Proxy URL", Repeatable: false, Example: "via=http://proxy:8080"},
			{Name: "attach=", Description: "Multipart parts for upload or send", Repeatable: true, Example: "attach='part: name=avatar, file=@me.png; part: name=meta, value=xyz'"},
			{Name: "follow=", Description: "Redirect policy for write verbs", Repeatable: false, Example: "follow=smart"},
			{Name: "insecure=", Description: "Disable TLS verification for this request", Repeatable: false, Example: "insecure=true"},
		},
	}
}

// FormatHelp formats the grammar as help text.
func FormatHelp() string {
	g := GetGrammar()
	
	var help string
	help += "req - HTTP client DSL\n\n"
	help += "Usage: req <verb> <url> [clauses...]\n\n"
	help += "Verbs:\n"
	
	for _, verb := range g.Verbs {
		help += fmt.Sprintf("  %-13s - %s\n", verb.Name, verb.Description)
	}
	
	help += "\nClauses:\n"
	for _, clause := range g.Clauses {
		help += fmt.Sprintf("  %-13s - %s", clause.Name, clause.Description)
		if clause.Repeatable {
			help += " (repeatable)"
		}
		help += "\n"
		if clause.Example != "" {
			help += fmt.Sprintf("                 Example: %s\n", clause.Example)
		}
	}
	
	help += "\nExamples:\n"
	help += "  req read https://api.example.com/search include='param: q=search query' as=json\n"
	help += "  \n"
	help += "  req read https://httpbin.org/basic-auth/user/passwd include='basic: user:passwd' expect=status:200\n"
	help += "  \n"
	help += "  req send https://api.example.com/users \\\n"
	help += "    using=POST \\\n"
	help += "    include='header: Authorization: Bearer $TOKEN' \\\n"
	help += "    with='{\"name\":\"Adam\"}' \\\n"
	help += "    expect=status:201, header:Content-Type=application/json \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req upload https://api.example.com/upload \\\n"
	help += "    attach='part: name=file, file=@./avatar.png, type=image/png' \\\n"
	help += "    as=json\n"
	help += "  \n"
	help += "  req authenticate https://api.example.com/login \\\n"
	help += "    using=POST \\\n"
	help += "    with='{\"user\":\"adam\",\"pass\":\"xyz\"}'\n"
	help += "  \n"
	help += "  req read https://api.example.com/me as=json\n\n"
	help += "For more information, see the grammar documentation.\n"
	
	return help
}


----
internal/grammar/snapshot.go
package grammar

import "encoding/json"

// Snapshot represents a snapshot of the grammar for drift detection.
type Snapshot struct {
	Verbs   []string `json:"verbs"`
	Clauses []ClauseSnapshot `json:"clauses"`
}

// ClauseSnapshot represents a clause in the snapshot.
type ClauseSnapshot struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Repeatable  bool   `json:"repeatable"`
}

// GetSnapshot returns a JSON-serializable snapshot of the grammar.
func GetSnapshot() Snapshot {
	g := GetGrammar()
	
	verbs := make([]string, len(g.Verbs))
	for i, v := range g.Verbs {
		verbs[i] = v.Name
	}
	
	clauses := make([]ClauseSnapshot, len(g.Clauses))
	for i, c := range g.Clauses {
		clauses[i] = ClauseSnapshot{
			Name:        c.Name,
			Description: c.Description,
			Repeatable:  c.Repeatable,
		}
	}
	
	return Snapshot{
		Verbs:   verbs,
		Clauses: clauses,
	}
}

// GetSnapshotJSON returns the snapshot as JSON bytes.
func GetSnapshotJSON() ([]byte, error) {
	snapshot := GetSnapshot()
	return json.MarshalIndent(snapshot, "", "  ")
}


----
internal/output/format.go
// Package output provides formatting and pretty-printing for execution plans.
package output

import (
	"encoding/json"
	"os"

	"github.com/adammpkins/req/internal/planner"
	"github.com/mattn/go-isatty"
)

// FormatPlan formats an ExecutionPlan as JSON for output.
func FormatPlan(plan *planner.ExecutionPlan) ([]byte, error) {
	if isatty.IsTerminal(os.Stdout.Fd()) {
		// Pretty print when outputting to terminal
		return json.MarshalIndent(plan, "", "  ")
	}
	// Compact JSON when piped
	return json.Marshal(plan)
}


----
internal/parser/parser.go
// Package parser implements a lexer and parser for the req command grammar.
//
// Grammar (EBNF):
//
//	command = verb target [clauses]
//	verb = "read" | "save" | "send" | "upload" | "watch" | "inspect" | "authenticate" | "session"
//	target = url
//	clauses = clause { clause }
//	clause = with_clause | include_clause | attach_clause | expect_clause | as_clause | to_clause |
//	         using_clause | retry_clause | under_clause | via_clause | follow_clause | insecure_clause
//	with_clause = "with=" ( string | "@file" | "@-" )
//	include_clause = "include=" items
//	attach_clause = "attach=" parts
//	expect_clause = "expect=" checks
//	as_clause = "as=" ( "json" | "csv" | "text" | "raw" )
//	to_clause = "to=" path
//	using_clause = "using=" ( "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTIONS" )
//	retry_clause = "retry=" number
//	under_clause = "under=" ( duration | size )
//	via_clause = "via=" url
//	follow_clause = "follow=smart"
//	insecure_clause = "insecure=" ( "true" | "false" )
package parser

import (
	"fmt"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// isValidHTTPMethod checks if a method is a valid HTTP method.
func isValidHTTPMethod(method string) bool {
	validMethods := []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	methodUpper := strings.ToUpper(method)
	for _, valid := range validMethods {
		if methodUpper == valid {
			return true
		}
	}
	return false
}

// ParseError represents a parse error with position information.
type ParseError struct {
	Position int
	Token    string
	Message  string
	Suggest  string
}

func (e *ParseError) Error() string {
	if e.Suggest != "" {
		return fmt.Sprintf("parse error at position %d (token: %q): %s (did you mean %q?)", e.Position, e.Token, e.Message, e.Suggest)
	}
	return fmt.Sprintf("parse error at position %d (token: %q): %s", e.Position, e.Token, e.Message)
}

// Parser parses req commands into AST.
type Parser struct {
	tokens []token
	pos    int
}

// token represents a lexical token.
type token struct {
	typ   tokenType
	value string
	pos   int
}

type tokenType int

const (
	tokenEOF tokenType = iota
	tokenWord
	tokenURL
	tokenEquals
	tokenColon
	tokenDotDot
	tokenString
	tokenNumber
	tokenDuration
	tokenFlag
)

// Parse parses a command string into a Command AST.
func Parse(input string) (*types.Command, error) {
	p := &Parser{}
	p.tokenize(input)
	return p.parseCommand()
}

// tokenize tokenizes the input string.
func (p *Parser) tokenize(input string) {
	input = strings.TrimSpace(input)
	if input == "" {
		p.tokens = []token{{typ: tokenEOF, pos: 0}}
		return
	}

	// Split on whitespace while respecting quoted strings
	parts := tokenizeRespectingQuotes(input)
	tokens := make([]token, 0, len(parts))

	for i, part := range parts {
		pos := i
		// Check if this is a URL first (URLs with query params contain = but are not clauses)
		if looksLikeURL(part) {
			tokens = append(tokens, token{typ: tokenURL, value: part, pos: pos})
		} else if strings.Contains(part, "=") {
			// Handle clauses with equals
			// Split on = but keep the = as a token
			eqIdx := strings.Index(part, "=")
			key := part[:eqIdx]
			value := part[eqIdx+1:]

			tokens = append(tokens, token{typ: tokenWord, value: key, pos: pos})
			tokens = append(tokens, token{typ: tokenEquals, value: "=", pos: pos})
			// Handle typed values like json:... (but not if value is quoted or looks like JSON)
			valueTrimmed := strings.TrimSpace(value)
			isQuoted := (len(valueTrimmed) >= 2 && ((valueTrimmed[0] == '\'' && valueTrimmed[len(valueTrimmed)-1] == '\'') || (valueTrimmed[0] == '"' && valueTrimmed[len(valueTrimmed)-1] == '"')))
			looksLikeJSON := strings.HasPrefix(valueTrimmed, "{") || strings.HasPrefix(valueTrimmed, "[")
			// Only parse as typed value if it matches pattern "word:" at the start (like json:...)
			// and not quoted or JSON-like
			if !isQuoted && !looksLikeJSON && strings.Contains(value, ":") {
				colonIdx := strings.Index(value, ":")
				typeName := strings.TrimSpace(value[:colonIdx])
				// Only treat as typed if typeName is a simple word (no special chars)
				if isSimpleWord(typeName) {
					typeValue := value[colonIdx+1:]
					tokens = append(tokens, token{typ: tokenWord, value: typeName, pos: pos})
					tokens = append(tokens, token{typ: tokenColon, value: ":", pos: pos})
					tokens = append(tokens, token{typ: tokenString, value: typeValue, pos: pos})
				} else {
					tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
				}
			} else if looksLikeURL(value) {
				tokens = append(tokens, token{typ: tokenURL, value: value, pos: pos})
			} else if looksLikeDuration(value) {
				tokens = append(tokens, token{typ: tokenDuration, value: value, pos: pos})
			} else {
				tokens = append(tokens, token{typ: tokenString, value: value, pos: pos})
			}
		} else if isFlag(part) {
			tokens = append(tokens, token{typ: tokenFlag, value: part, pos: pos})
		} else {
			tokens = append(tokens, token{typ: tokenWord, value: part, pos: pos})
		}
	}

	tokens = append(tokens, token{typ: tokenEOF, pos: len(parts)})
	p.tokens = tokens
}

// tokenizeRespectingQuotes splits a string on whitespace while respecting quoted strings.
// Quoted strings (single or double quotes) are preserved as single tokens.
// Also preserves clause values (everything after =) as single tokens even if unquoted.
func tokenizeRespectingQuotes(s string) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	quoteChar := rune(0)
	escape := false
	afterEquals := false // Track if we're in a clause value (after =)

	for i, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}

		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}

		if (r == '\'' || r == '"') && !inQuotes {
			// Start of quoted string
			inQuotes = true
			quoteChar = r
			current.WriteRune(r)
			continue
		}

		if inQuotes && r == quoteChar {
			// End of quoted string
			inQuotes = false
			quoteChar = 0
			current.WriteRune(r)
			continue
		}

		if r == '=' && !inQuotes {
			// Found equals - mark that we're now in a clause value
			afterEquals = true
			current.WriteRune(r)
			continue
		}

		if !inQuotes && (r == ' ' || r == '\t' || r == '\n') {
			// Whitespace outside quotes
			if afterEquals {
				// We're in a clause value - check if next token starts a new clause
				// Look ahead to see if there's a word followed by =
				remaining := s[i+1:]
				remaining = strings.TrimLeft(remaining, " \t\n")
				// Check if remaining starts with a word followed by = (new clause)
				// or if it's empty/EOF
				if remaining == "" || looksLikeNewClause(remaining) {
					// This whitespace separates clauses - split here
					if current.Len() > 0 {
						parts = append(parts, current.String())
						current.Reset()
					}
					afterEquals = false
					continue
				}
				// Otherwise, preserve whitespace as part of the clause value
				current.WriteRune(r)
				continue
			}
			// Not in a clause value - split here
			if current.Len() > 0 {
				parts = append(parts, current.String())
				current.Reset()
			}
			afterEquals = false
			continue
		}

		// If we hit a non-whitespace character after being in a clause value,
		// and it's not part of a quoted string, check if it starts a new clause
		if afterEquals && !inQuotes && r != ' ' && r != '\t' && r != '\n' {
			// Check if we're starting a new clause (word followed by =)
			// This is tricky - we need to look at what we've accumulated
			// For now, just continue accumulating
		}

		current.WriteRune(r)
	}

	// Add remaining content
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}

	return parts
}

// looksLikeNewClause checks if a string looks like it starts a new clause (word=)
func looksLikeNewClause(s string) bool {
	// Find first space or equals
	for i, r := range s {
		if r == '=' {
			// Found = - check if there's a word before it
			if i > 0 {
				word := strings.TrimSpace(s[:i])
				// Check if it's a valid clause key
				validKeys := []string{"include", "expect", "with", "as", "to", "using", "retry", "under", "via", "follow", "insecure", "attach"}
				for _, key := range validKeys {
					if word == key {
						return true
					}
				}
			}
			return false
		}
		if r == ' ' || r == '\t' {
			// Found space before = - not a new clause
			return false
		}
	}
	return false
}

// isSimpleWord checks if a string is a simple word (letters, numbers, underscore, no special chars)
func isSimpleWord(s string) bool {
	if len(s) == 0 {
		return false
	}
	for _, r := range s {
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_') {
			return false
		}
	}
	return true
}

// looksLikeURL checks if a string looks like a URL.
func looksLikeURL(s string) bool {
	return strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://")
}

// looksLikeDuration checks if a string looks like a duration.
func looksLikeDuration(s string) bool {
	_, err := parseDuration(s)
	return err == nil
}

// isFlag checks if a string is a flag.
func isFlag(s string) bool {
	return s == "verbose" || s == "resume"
}

// parseCommand parses a command.
func (p *Parser) parseCommand() (*types.Command, error) {
	cmd := &types.Command{}

	// Parse verb
	verb, err := p.parseVerb()
	if err != nil {
		return nil, err
	}
	cmd.Verb = verb

	// Handle session subcommands (show, clear, use)
	if verb == types.VerbSession {
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected session subcommand (show, clear, use)"}
		}
		tok := p.tokens[p.pos]
		if tok.typ == tokenWord {
			subcmd := tok.value
			if subcmd == "show" || subcmd == "clear" || subcmd == "use" {
				cmd.SessionSubcommand = subcmd
				p.pos++
			} else {
				return nil, &ParseError{Position: tok.pos, Token: subcmd, Message: "unknown session subcommand (expected show, clear, or use)"}
			}
		}
	}

	// Parse target
	target, err := p.parseTarget()
	if err != nil {
		return nil, err
	}
	cmd.Target = target

	// Parse clauses
	clauses, err := p.parseClauses()
	if err != nil {
		return nil, err
	}
	cmd.Clauses = clauses

	return cmd, nil
}

// parseVerb parses a verb.
func (p *Parser) parseVerb() (types.Verb, error) {
	if p.pos >= len(p.tokens) {
		return "", &ParseError{Position: p.pos, Token: "", Message: "expected verb"}
	}

	tok := p.tokens[p.pos]
	if tok.typ != tokenWord {
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "expected verb"}
	}

	verb := types.Verb(tok.value)
	switch verb {
	case types.VerbRead, types.VerbSave, types.VerbSend, types.VerbUpload,
		types.VerbWatch, types.VerbInspect, types.VerbAuthenticate, types.VerbSession:
		p.pos++
		return verb, nil
	default:
		suggest := suggestVerb(tok.value)
		return "", &ParseError{Position: tok.pos, Token: tok.value, Message: "unknown verb", Suggest: suggest}
	}
}

// suggestVerb suggests a similar verb.
func suggestVerb(input string) string {
	verbs := []string{"read", "save", "send", "upload", "watch", "inspect", "authenticate", "session"}
	best := ""
	minDist := 999
	for _, v := range verbs {
		dist := levenshteinDistance(input, v)
		if dist < minDist {
			minDist = dist
			best = v
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// levenshteinDistance calculates the Levenshtein distance between two strings.
func levenshteinDistance(a, b string) int {
	if len(a) == 0 {
		return len(b)
	}
	if len(b) == 0 {
		return len(a)
	}

	matrix := make([][]int, len(a)+1)
	for i := range matrix {
		matrix[i] = make([]int, len(b)+1)
	}

	for i := 0; i <= len(a); i++ {
		matrix[i][0] = i
	}
	for j := 0; j <= len(b); j++ {
		matrix[0][j] = j
	}

	for i := 1; i <= len(a); i++ {
		for j := 1; j <= len(b); j++ {
			cost := 0
			if a[i-1] != b[j-1] {
				cost = 1
			}
			matrix[i][j] = min(
				matrix[i-1][j]+1,
				matrix[i][j-1]+1,
				matrix[i-1][j-1]+cost,
			)
		}
	}

	return matrix[len(a)][len(b)]
}

func min(a, b, c int) int {
	if a < b && a < c {
		return a
	}
	if b < c {
		return b
	}
	return c
}

// parseTarget parses a target URL.
func (p *Parser) parseTarget() (types.Target, error) {
	if p.pos >= len(p.tokens) {
		return types.Target{}, &ParseError{Position: p.pos, Token: "", Message: "expected target URL or host"}
	}

	tok := p.tokens[p.pos]
	// For session commands, target might be a host instead of full URL
	if tok.typ == tokenURL {
		p.pos++
		return types.Target{URL: tok.value}, nil
	} else if tok.typ == tokenWord {
		// Might be a host name for session commands
		// Try to parse as URL, if it fails, treat as host
		if strings.Contains(tok.value, ".") || strings.Contains(tok.value, ":") {
			// Looks like a host, construct URL
			urlStr := "https://" + tok.value
			p.pos++
			return types.Target{URL: urlStr}, nil
		}
	}

	return types.Target{}, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected URL or host"}
}

// parseClauses parses zero or more clauses.
func (p *Parser) parseClauses() ([]types.Clause, error) {
	var clauses []types.Clause
	singletonSeen := make(map[string]bool)

	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}

		clause, err := p.parseClause()
		if err != nil {
			return nil, err
		}

		// Check for duplicate singletons
		if singletonKey := getSingletonKey(clause); singletonKey != "" {
			if singletonSeen[singletonKey] {
				return nil, &ParseError{
					Position: tok.pos,
					Token:    tok.value,
					Message:  fmt.Sprintf("duplicate singleton clause '%s'", singletonKey),
					Suggest:  fmt.Sprintf("remove duplicate '%s=' clause", singletonKey),
				}
			}
			singletonSeen[singletonKey] = true
		}

		clauses = append(clauses, clause)
	}

	return clauses, nil
}

// getSingletonKey returns the key name for singleton clauses, or empty string for repeatable clauses.
func getSingletonKey(clause types.Clause) string {
	switch clause.(type) {
	case types.UsingClause:
		return "using"
	case types.WithClause:
		return "with"
	case types.ExpectClause:
		return "expect"
	case types.AsClause:
		return "as"
	case types.ToClause:
		return "to"
	case types.RetryClause:
		return "retry"
	case types.UnderClause:
		return "under"
	case types.ViaClause:
		return "via"
	case types.InsecureClause:
		return "insecure"
	case types.FollowClause:
		return "follow"
	case types.TimeoutClause:
		return "timeout"
	case types.BackoffClause:
		return "backoff"
	case types.PickClause:
		return "pick"
	case types.EveryClause:
		return "every"
	case types.UntilClause:
		return "until"
	case types.ProxyClause:
		return "proxy"
	case types.FieldClause:
		return "field"
	case types.VerboseClause:
		return "verbose"
	case types.ResumeClause:
		return "resume"
	// Repeatable clauses return empty string
	case types.IncludeClause, types.AttachClause:
		return ""
	default:
		return ""
	}
}

// parseClause parses a single clause.
func (p *Parser) parseClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected clause"}
	}

	tok := p.tokens[p.pos]

	// Handle flags (insecure is now a clause with =, but keep verbose and resume as flags)
	if tok.typ == tokenFlag {
		p.pos++
		switch tok.value {
		case "verbose":
			return types.VerboseClause{}, nil
		case "resume":
			return types.ResumeClause{}, nil
		}
	}

	// Handle clauses with equals
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
		key := tok.value
		p.pos += 2 // skip key and =

		switch key {
		case "with":
			return p.parseWithClause()
		case "include":
			return p.parseIncludeClause()
		case "attach":
			return p.parseAttachClause()
		case "expect":
			return p.parseExpectClause()
		case "headers":
			return p.parseHeadersClause()
		case "params":
			return p.parseParamsClause()
		case "as":
			return p.parseAsClause()
		case "to":
			return p.parseToClause()
		case "using":
			return p.parseUsingClause()
		case "retry":
			return p.parseRetryClause()
		case "backoff":
			return p.parseBackoffClause()
		case "timeout":
			return p.parseTimeoutClause()
		case "under":
			return p.parseUnderClause()
		case "proxy":
			return p.parseProxyClause()
		case "via":
			return p.parseViaClause()
		case "follow":
			return p.parseFollowClause()
		case "insecure":
			return p.parseInsecureClause()
		case "pick":
			return p.parsePickClause()
		case "every":
			return p.parseEveryClause()
		case "until":
			return p.parseUntilClause()
		case "field":
			return p.parseFieldClause()
		default:
			suggest := suggestClause(key)
			return nil, &ParseError{Position: tok.pos, Token: key, Message: "unknown clause", Suggest: suggest}
		}
	}

	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "expected clause"}
}

// suggestClause suggests a similar clause name.
func suggestClause(input string) string {
	clauses := []string{"with", "include", "attach", "expect", "headers", "params", "as", "to", "using", "retry", "backoff", "timeout", "under", "proxy", "via", "follow", "insecure", "pick", "every", "until", "field"}
	best := ""
	minDist := 999
	for _, c := range clauses {
		dist := levenshteinDistance(input, c)
		if dist < minDist {
			minDist = dist
			best = c
		}
	}
	if minDist <= 2 {
		return best
	}
	return ""
}

// parseWithClause parses a "with=" clause.
func (p *Parser) parseWithClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	tok := p.tokens[p.pos]
	if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenColon {
		// typed value like json:...
		typeName := tok.value
		p.pos += 2 // skip type and :
		if p.pos >= len(p.tokens) {
			return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
		}
		valueTok := p.tokens[p.pos]
		p.pos++
		value := valueTok.value
		isFile := strings.HasPrefix(value, "@") && value != "@-"
		isStdin := value == "@-"
		if isFile {
			value = value[1:] // Remove @ prefix
		}
		return types.WithClause{Type: typeName, Value: value, IsFile: isFile, IsStdin: isStdin}, nil
	}

	// plain value - collect all tokens until next clause
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected with value"}
	}

	// Join tokens with spaces
	value := strings.Join(valueParts, " ")
	
	// Unquote if needed
	value = unquoteString(value)
	
	isFile := strings.HasPrefix(value, "@") && value != "@-"
	isStdin := value == "@-"
	if isFile {
		value = value[1:] // Remove @ prefix
	}
	
	// Infer JSON type if value starts with { or [
	typeInferred := ""
	if !isFile && !isStdin {
		trimmed := strings.TrimSpace(value)
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			typeInferred = "json"
		}
	}
	
	return types.WithClause{Value: value, Type: typeInferred, IsFile: isFile, IsStdin: isStdin}, nil
}

// parseHeadersClause parses a "headers=" clause (simplified for v0.1.0).
func (p *Parser) parseHeadersClause() (types.Clause, error) {
	// Simplified: just parse a single key:value pair for now
	// Full object parsing will come later
	return types.HeadersClause{Headers: make(map[string]string)}, nil
}

// parseParamsClause parses a "params=" clause (simplified for v0.1.0).
func (p *Parser) parseParamsClause() (types.Clause, error) {
	// Simplified: just parse a single key=value pair for now
	return types.ParamsClause{Params: make(map[string]string)}, nil
}

// parseAsClause parses an "as=" clause.
func (p *Parser) parseAsClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected format"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.AsClause{Format: tok.value}, nil
}

// parseToClause parses a "to=" clause.
func (p *Parser) parseToClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected destination"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ToClause{Destination: tok.value}, nil
}

// parseUsingClause parses a "using=" clause.
func (p *Parser) parseUsingClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected HTTP method"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	method := strings.ToUpper(tok.value)
	
	if !isValidHTTPMethod(method) {
		return nil, &ParseError{
			Position: tok.pos,
			Token:    tok.value,
			Message:  fmt.Sprintf("invalid HTTP method: %s (valid methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS)", tok.value),
		}
	}
	
	return types.UsingClause{Method: method}, nil
}

// parseRetryClause parses a "retry=" clause.
func (p *Parser) parseRetryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected retry count"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	// Parse number (simplified)
	count := 3 // default
	if tok.typ == tokenNumber {
		// In a real implementation, parse the number
		// For now, just use default
	}
	return types.RetryClause{Count: count}, nil
}

// parseBackoffClause parses a "backoff=" clause.
func (p *Parser) parseBackoffClause() (types.Clause, error) {
	// Format: backoff=200ms..5s
	if p.pos+2 >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected backoff range"}
	}

	minTok := p.tokens[p.pos]
	p.pos++
	if p.tokens[p.pos].typ != tokenDotDot {
		return nil, &ParseError{Position: p.pos, Token: p.tokens[p.pos].value, Message: "expected .."}
	}
	p.pos++
	maxTok := p.tokens[p.pos]
	p.pos++

	minDur, err := parseDuration(minTok.value)
	if err != nil {
		return nil, &ParseError{Position: minTok.pos, Token: minTok.value, Message: "invalid duration"}
	}
	maxDur, err := parseDuration(maxTok.value)
	if err != nil {
		return nil, &ParseError{Position: maxTok.pos, Token: maxTok.value, Message: "invalid duration"}
	}

	return types.BackoffClause{Min: minDur, Max: maxDur}, nil
}

// parseDuration parses a duration string.
func parseDuration(s string) (time.Duration, error) {
	return time.ParseDuration(s)
}

// parseTimeoutClause parses a "timeout=" clause.
func (p *Parser) parseTimeoutClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected timeout duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.TimeoutClause{Duration: dur}, nil
}

// parseProxyClause parses a "proxy=" clause.
func (p *Parser) parseProxyClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected proxy URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ProxyClause{URL: tok.value}, nil
}

// parsePickClause parses a "pick=" clause.
func (p *Parser) parsePickClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected JSONPath expression"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.PickClause{Path: tok.value}, nil
}

// parseEveryClause parses an "every=" clause.
func (p *Parser) parseEveryClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected interval duration"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	dur, err := parseDuration(tok.value)
	if err != nil {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "invalid duration"}
	}
	return types.EveryClause{Interval: dur}, nil
}

// parseUntilClause parses an "until=" clause.
func (p *Parser) parseUntilClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected predicate"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.UntilClause{Predicate: tok.value}, nil
}

// parseFieldClause parses a "field=" clause.
func (p *Parser) parseFieldClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field name"}
	}

	nameTok := p.tokens[p.pos]
	p.pos++
	if p.pos >= len(p.tokens) || p.tokens[p.pos].typ != tokenEquals {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected ="}
	}
	p.pos++
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected field value"}
	}
	valueTok := p.tokens[p.pos]
	p.pos++

	return types.FieldClause{Name: nameTok.value, Value: valueTok.value}, nil
}

// parseIncludeClause parses an "include=" clause.
// Format: include='header: Name: Value; param: key=value; cookie: key=value'
func (p *Parser) parseIncludeClause() (types.Clause, error) {
	// Collect tokens until we have a complete include value
	// The value may contain colons, semicolons, and spaces
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected include value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}

	// Unquote the value if it's a single quoted string
	value = unquoteString(value)

	items, err := parseIncludeItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.IncludeClause{Items: items}, nil
}

// parseIncludeItems parses semicolon-separated include items.
func parseIncludeItems(value string) ([]types.IncludeItem, error) {
	var items []types.IncludeItem
	
	// For header items, semicolons in the value should not split items
	// We need to parse more carefully by looking for type tags
	value = strings.TrimSpace(value)
	if value == "" {
		return items, nil
	}
	
	// Split by semicolons, but be smarter about it:
	// - Look for type tags (header:, param:, cookie:)
	// - For header items, everything after "Name: " is the value, including semicolons
	// - Only split on semicolons that are followed by a type tag
	
	var current strings.Builder
	var parts []string
	
	i := 0
	for i < len(value) {
		// Look ahead for a type tag pattern: "; header:", "; param:", "; cookie:"
		if i > 0 && value[i] == ';' {
			// Check if this semicolon is followed by a type tag
			remaining := strings.TrimSpace(value[i+1:])
			if strings.HasPrefix(remaining, "header:") ||
				strings.HasPrefix(remaining, "param:") ||
				strings.HasPrefix(remaining, "cookie:") {
				// This semicolon is a separator
				if current.Len() > 0 {
					parts = append(parts, strings.TrimSpace(current.String()))
					current.Reset()
				}
				i++ // Skip the semicolon
				continue
			}
		}
		current.WriteByte(value[i])
		i++
	}
	
	if current.Len() > 0 {
		parts = append(parts, strings.TrimSpace(current.String()))
	}
	
	// If we didn't find any type tag separators, treat the whole thing as one item
	if len(parts) == 0 {
		parts = []string{value}
	}
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		item, err := parseIncludeItem(part)
		if err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	
	return items, nil
}

// parseIncludeItem parses a single include item (header:, param:, cookie:).
func parseIncludeItem(part string) (types.IncludeItem, error) {
	// Find the first colon to determine the type
	colonIdx := strings.Index(part, ":")
	if colonIdx == -1 {
		return types.IncludeItem{}, fmt.Errorf("missing colon in include item: %s", part)
	}
	
	typeTag := strings.TrimSpace(part[:colonIdx])
	rest := strings.TrimSpace(part[colonIdx+1:])
	
	switch typeTag {
	case "header":
		// Format: header: Name: Value
		headerColonIdx := strings.Index(rest, ":")
		if headerColonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("header item missing Name colon Value: %s", part)
		}
		name := strings.TrimSpace(rest[:headerColonIdx])
		value := strings.TrimSpace(rest[headerColonIdx+1:])
		// Unquote if needed
		name = unquoteString(name)
		value = unquoteString(value)
		return types.IncludeItem{Type: "header", Name: name, Value: value}, nil
		
	case "param":
		// Format: param: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("param item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "param", Name: key, Value: value}, nil
		
	case "cookie":
		// Format: cookie: key=value
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("cookie item missing equals: %s", part)
		}
		key := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		key = unquoteString(key)
		value = unquoteString(value)
		return types.IncludeItem{Type: "cookie", Name: key, Value: value}, nil
		
	case "basic":
		// Format: basic: username:password
		// The rest should be username:password
		rest = strings.TrimSpace(rest)
		rest = unquoteString(rest)
		// Validate that it contains at least one colon
		colonIdx := strings.Index(rest, ":")
		if colonIdx == -1 {
			return types.IncludeItem{}, fmt.Errorf("basic item must be in format username:password: %s", part)
		}
		// Store the full username:password as the value
		// We'll split it in the planner when encoding
		return types.IncludeItem{Type: "basic", Value: rest}, nil
		
	default:
		return types.IncludeItem{}, fmt.Errorf("unknown include item tag: %s (expected header, param, cookie, or basic)", typeTag)
	}
}

// splitRespectingQuotes splits a string by a delimiter while respecting quoted strings.
func splitRespectingQuotes(s string, delim rune) []string {
	var parts []string
	var current strings.Builder
	inQuotes := false
	escape := false
	
	for _, r := range s {
		if escape {
			current.WriteRune(r)
			escape = false
			continue
		}
		
		if r == '\\' {
			escape = true
			current.WriteRune(r)
			continue
		}
		
		if r == '\'' || r == '"' {
			inQuotes = !inQuotes
			current.WriteRune(r)
			continue
		}
		
		if r == delim && !inQuotes {
			parts = append(parts, current.String())
			current.Reset()
			continue
		}
		
		current.WriteRune(r)
	}
	
	if current.Len() > 0 {
		parts = append(parts, current.String())
	}
	
	return parts
}

// unquoteString removes surrounding quotes if present and handles escapes.
func unquoteString(s string) string {
	if len(s) >= 2 && ((s[0] == '\'' && s[len(s)-1] == '\'') || (s[0] == '"' && s[len(s)-1] == '"')) {
		s = s[1 : len(s)-1]
		// Handle escapes
		var result strings.Builder
		escape := false
		for _, r := range s {
			if escape {
				if r == '\\' || r == '\'' || r == '"' {
					result.WriteRune(r)
				} else {
					result.WriteRune('\\')
					result.WriteRune(r)
				}
				escape = false
			} else if r == '\\' {
				escape = true
			} else {
				result.WriteRune(r)
			}
		}
		if escape {
			result.WriteRune('\\')
		}
		return result.String()
	}
	return s
}

// parseAttachClause parses an "attach=" clause.
// Format: attach='part: name=..., file=@path; part: name=..., value=...'
func (p *Parser) parseAttachClause() (types.Clause, error) {
	// Collect tokens until we have a complete attach value
	// The value may contain spaces, commas, and semicolons
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected attach value"}
	}

	// Join tokens, but handle colons and semicolons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon/semicolon and current isn't a colon/semicolon
			prev := valueParts[i-1]
			if prev != ":" && prev != ";" && part != ":" && part != ";" {
				value += " "
			}
		}
		value += part
	}
	
	// Unquote if needed
	value = unquoteString(value)
	
	parts, boundary, err := parseAttachItems(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.AttachClause{Parts: parts, Boundary: boundary}, nil
}

// parseAttachItems parses semicolon-separated attach items.
func parseAttachItems(value string) ([]types.AttachPart, string, error) {
	var parts []types.AttachPart
	var boundary string
	
	// Split by semicolons, respecting quotes
	items := splitRespectingQuotes(value, ';')
	
	for _, item := range items {
		item = strings.TrimSpace(item)
		if item == "" {
			continue
		}
		
		// Check if it's a boundary specification
		if strings.HasPrefix(item, "boundary:") {
			boundary = strings.TrimSpace(strings.TrimPrefix(item, "boundary:"))
			boundary = unquoteString(boundary)
			continue
		}
		
		// Parse part: specification
		if !strings.HasPrefix(item, "part:") {
			return nil, "", fmt.Errorf("expected 'part:' or 'boundary:', got: %s", item)
		}
		
		partSpec := strings.TrimSpace(strings.TrimPrefix(item, "part:"))
		part, err := parseAttachPart(partSpec)
		if err != nil {
			return nil, "", err
		}
		parts = append(parts, part)
	}
	
	return parts, boundary, nil
}

// parseAttachPart parses a single attach part specification.
// Format: name=..., file=@path or value=..., optional filename=..., optional type=...
func parseAttachPart(spec string) (types.AttachPart, error) {
	var part types.AttachPart
	
	// Parse comma-separated key=value pairs
	pairs := splitRespectingQuotes(spec, ',')
	
	for _, pair := range pairs {
		pair = strings.TrimSpace(pair)
		eqIdx := strings.Index(pair, "=")
		if eqIdx == -1 {
			return types.AttachPart{}, fmt.Errorf("missing equals in attach part: %s", pair)
		}
		
		key := strings.TrimSpace(pair[:eqIdx])
		value := strings.TrimSpace(pair[eqIdx+1:])
		value = unquoteString(value)
		
		switch key {
		case "name":
			part.Name = value
		case "file":
			if strings.HasPrefix(value, "@") {
				part.FilePath = value[1:] // Remove @
			} else {
				part.FilePath = value
			}
		case "value":
			part.Value = value
		case "filename":
			part.Filename = value
		case "type":
			part.Type = value
		default:
			return types.AttachPart{}, fmt.Errorf("unknown attach part key: %s", key)
		}
	}
	
	// Validate: name is required
	if part.Name == "" {
		return types.AttachPart{}, fmt.Errorf("attach part missing required 'name='")
	}
	
	// Validate: exactly one of file or value
	hasFile := part.FilePath != ""
	hasValue := part.Value != ""
	if hasFile && hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part cannot have both 'file=' and 'value='")
	}
	if !hasFile && !hasValue {
		return types.AttachPart{}, fmt.Errorf("attach part must have either 'file=' or 'value='")
	}
	
	return part, nil
}

// parseExpectClause parses an "expect=" clause.
// Format: expect=status:200, header:Content-Type=application/json, contains:"text"
func (p *Parser) parseExpectClause() (types.Clause, error) {
	// Collect tokens until we have a complete expect value
	// The value may contain colons and commas, so we need to collect multiple tokens
	var valueParts []string
	for p.pos < len(p.tokens) {
		tok := p.tokens[p.pos]
		if tok.typ == tokenEOF {
			break
		}
		// Stop if we hit another clause (word followed by =)
		if tok.typ == tokenWord && p.pos+1 < len(p.tokens) && p.tokens[p.pos+1].typ == tokenEquals {
			break
		}
		valueParts = append(valueParts, tok.value)
		p.pos++
	}

	if len(valueParts) == 0 {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected expect value"}
	}

	// Join tokens, but handle colons specially (no space before/after)
	value := ""
	for i, part := range valueParts {
		if i > 0 {
			// Add space only if previous token wasn't a colon and current isn't a colon
			if valueParts[i-1] != ":" && part != ":" {
				value += " "
			}
		}
		value += part
	}
	
	// Unquote the value if it's a single quoted string
	value = unquoteString(value)
	
	checks, err := parseExpectChecks(value)
	if err != nil {
		return nil, &ParseError{Position: p.pos, Token: value, Message: err.Error()}
	}

	return types.ExpectClause{Checks: checks}, nil
}

// parseExpectChecks parses comma-separated expect checks.
func parseExpectChecks(value string) ([]types.ExpectCheck, error) {
	var checks []types.ExpectCheck
	
	// Split by commas, respecting quotes
	parts := splitRespectingQuotes(value, ',')
	
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}
		
		check, err := parseExpectCheck(part)
		if err != nil {
			return nil, err
		}
		checks = append(checks, check)
	}
	
	return checks, nil
}

// parseExpectCheck parses a single expect check.
func parseExpectCheck(part string) (types.ExpectCheck, error) {
	// Unquote if needed first
	unquoted := unquoteString(part)
	
	// Check types: status:, header:, contains:, jsonpath:, matches:
	if strings.HasPrefix(unquoted, "status:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "status:"))
		return types.ExpectCheck{Type: "status", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "header:") {
		rest := strings.TrimSpace(strings.TrimPrefix(unquoted, "header:"))
		eqIdx := strings.Index(rest, "=")
		if eqIdx == -1 {
			return types.ExpectCheck{}, fmt.Errorf("header check missing equals: %s", part)
		}
		name := strings.TrimSpace(rest[:eqIdx])
		value := strings.TrimSpace(rest[eqIdx+1:])
		value = unquoteString(value)
		return types.ExpectCheck{Type: "header", Name: name, Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "contains:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "contains:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "contains", Value: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "jsonpath:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "jsonpath:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "jsonpath", Path: value}, nil
	}
	
	if strings.HasPrefix(unquoted, "matches:") {
		value := strings.TrimSpace(strings.TrimPrefix(unquoted, "matches:"))
		value = unquoteString(value)
		return types.ExpectCheck{Type: "matches", Regex: value}, nil
	}
	
	return types.ExpectCheck{}, fmt.Errorf("unknown expect check type: %s", part)
}

// parseFollowClause parses a "follow=" clause.
func (p *Parser) parseFollowClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected follow value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "smart" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "follow accepts only 'smart'"}
	}
	
	return types.FollowClause{Policy: "smart"}, nil
}

// parseUnderClause parses an "under=" clause (duration or size).
func (p *Parser) parseUnderClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected under value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.TrimSpace(tok.value)
	
	// Try parsing as duration first
	if dur, err := parseDuration(value); err == nil {
		return types.UnderClause{Duration: dur, IsSize: false}, nil
	}
	
	// Try parsing as size (e.g., "10MB", "1GB")
	if size, err := parseSize(value); err == nil {
		return types.UnderClause{Size: size, IsSize: true}, nil
	}
	
	return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "under value must be a duration (e.g., 30s) or size (e.g., 10MB)"}
}

// parseSize parses a size string like "10MB", "1GB", etc.
func parseSize(s string) (int64, error) {
	s = strings.TrimSpace(s)
	s = strings.ToUpper(s)
	
	multipliers := map[string]int64{
		"B":  1,
		"KB": 1024,
		"MB": 1024 * 1024,
		"GB": 1024 * 1024 * 1024,
		"TB": 1024 * 1024 * 1024 * 1024,
	}
	
	for suffix, mult := range multipliers {
		if strings.HasSuffix(s, suffix) {
			numStr := strings.TrimSuffix(s, suffix)
			var num float64
			if _, err := fmt.Sscanf(numStr, "%f", &num); err != nil {
				return 0, err
			}
			return int64(num * float64(mult)), nil
		}
	}
	
	return 0, fmt.Errorf("unknown size suffix")
}

// parseViaClause parses a "via=" clause.
func (p *Parser) parseViaClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected via URL"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	return types.ViaClause{URL: tok.value}, nil
}

// parseInsecureClause parses an "insecure=" clause.
func (p *Parser) parseInsecureClause() (types.Clause, error) {
	if p.pos >= len(p.tokens) {
		return nil, &ParseError{Position: p.pos, Token: "", Message: "expected insecure value"}
	}

	tok := p.tokens[p.pos]
	p.pos++
	
	value := strings.ToLower(strings.TrimSpace(tok.value))
	if value != "true" && value != "false" {
		return nil, &ParseError{Position: tok.pos, Token: tok.value, Message: "insecure accepts only 'true' or 'false'"}
	}
	
	return types.InsecureClause{Value: value == "true"}, nil
}

----
internal/planner/plan.go
// Package planner applies defaults, validates commands, and produces execution plans.
package planner

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/adammpkins/req/internal/types"
)

// ExecutionPlan represents a fully resolved execution plan ready for HTTP runtime.
type ExecutionPlan struct {
	Verb        types.Verb         `json:"verb"`
	Method      string             `json:"method"`
	URL         string             `json:"url"`
	Headers     map[string]string  `json:"headers,omitempty"`
	QueryParams map[string]string  `json:"query_params,omitempty"`
	Cookies     map[string]string  `json:"cookies,omitempty"`
	Body        *BodyPlan          `json:"body,omitempty"`
	Output      *OutputPlan        `json:"output,omitempty"`
	Retry       *RetryPlan         `json:"retry,omitempty"`
	Timeout     *time.Duration    `json:"timeout,omitempty"`
	SizeLimit   *int64            `json:"size_limit,omitempty"`
	Proxy       string             `json:"proxy,omitempty"`
	Insecure    bool               `json:"insecure,omitempty"`
	Verbose     bool               `json:"verbose,omitempty"`
	Resume      bool               `json:"resume,omitempty"`
	Follow      string             `json:"follow,omitempty"` // "smart" or empty
	Expect      []types.ExpectCheck `json:"expect,omitempty"`
}

// BodyPlan represents the request body configuration.
type BodyPlan struct {
	Type     string                `json:"type"` // json, form, multipart, raw
	Content  string                `json:"content,omitempty"`
	FilePath string                `json:"file_path,omitempty"`
	Field    string                `json:"field,omitempty"` // for multipart
	AttachParts []types.AttachPart `json:"attach_parts,omitempty"` // for multipart
	Boundary string                `json:"boundary,omitempty"` // for multipart
}

// OutputPlan represents the output configuration.
type OutputPlan struct {
	Format      string `json:"format"` // json, csv, text, raw
	Destination string `json:"destination,omitempty"`
	Pick        string `json:"pick,omitempty"` // JSONPath expression
}

// RetryPlan represents retry configuration.
type RetryPlan struct {
	Count  int           `json:"count"`
	Backoff BackoffRange `json:"backoff"`
}

// BackoffRange represents a backoff range with min and max durations.
type BackoffRange struct {
	Min time.Duration `json:"min"`
	Max time.Duration `json:"max"`
}

// Plan creates an ExecutionPlan from a parsed Command.
func Plan(cmd *types.Command) (*ExecutionPlan, error) {
	plan := &ExecutionPlan{
		Verb:        cmd.Verb,
		URL:         cmd.Target.URL,
		Headers:     make(map[string]string),
		QueryParams: make(map[string]string),
		Cookies:     make(map[string]string),
	}

	// Apply verb-specific defaults
	if err := applyVerbDefaults(cmd.Verb, plan); err != nil {
		return nil, err
	}

	// Process clauses
	for _, clause := range cmd.Clauses {
		if err := applyClause(clause, plan, cmd.Verb); err != nil {
			return nil, err
		}
	}

	// Post-process: extract filename for save verb if destination not provided or is a directory
	if cmd.Verb == types.VerbSave && plan.Output != nil {
		if plan.Output.Destination == "" {
			// No destination provided, extract from URL
			filename := extractFilenameFromURL(plan.URL)
			if filename != "" {
				plan.Output.Destination = filename
			}
		} else {
			// Destination provided - check if it's a directory
			if isDirectory(plan.Output.Destination) {
				// It's a directory, append filename from URL
				filename := extractFilenameFromURL(plan.URL)
				if filename != "" {
					plan.Output.Destination = filepath.Join(plan.Output.Destination, filename)
				}
			}
			// If it's a file path (like /tmp/file.zip), use it as-is
		}
	}

	// Validate plan
	if err := validatePlan(plan); err != nil {
		return nil, err
	}

	return plan, nil
}

// applyVerbDefaults applies default settings based on the verb.
func applyVerbDefaults(verb types.Verb, plan *ExecutionPlan) error {
	switch verb {
	case types.VerbRead:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSave:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "raw"}
	case types.VerbSend:
		// Default to GET, will be changed to POST if with= is present
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbUpload:
		// Default to POST, but will error if no attach= or with= present
		plan.Method = http.MethodPost
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbWatch:
		plan.Method = http.MethodGet
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbInspect:
		plan.Method = http.MethodHead
		plan.Output = &OutputPlan{Format: "json"}
	case types.VerbAuthenticate:
		// Default to POST if with= is present, otherwise require using=
		// We'll check this in validatePlan
		plan.Method = http.MethodPost // tentative, may be overridden
		plan.Output = &OutputPlan{Format: "auto"}
	case types.VerbSession:
		// Session verbs are handled separately in main
		plan.Method = http.MethodGet // placeholder
		plan.Output = &OutputPlan{Format: "auto"}
	default:
		return fmt.Errorf("unsupported verb: %s", verb)
	}
	return nil
}

// validateUsingClause validates that the HTTP method is compatible with the verb.
func validateUsingClause(verb types.Verb, method string) error {
	allowedMethods := map[types.Verb][]string{
		types.VerbRead:    {"GET", "HEAD", "OPTIONS"},
		types.VerbSave:    {"GET", "POST"},
		types.VerbSend:   {"POST", "PUT", "PATCH"},
		types.VerbUpload: {"POST", "PUT"},
		types.VerbWatch:  {"GET"},
		types.VerbInspect: {"HEAD", "GET", "OPTIONS"},
	}
	
	allowed, ok := allowedMethods[verb]
	if !ok {
		// If verb not in map, allow any method (for future verbs like delete)
		return nil
	}
	
	for _, allowedMethod := range allowed {
		if method == allowedMethod {
			return nil
		}
	}
	
	return fmt.Errorf("verb '%s' is incompatible with method '%s'", verb, method)
}

// applyClause applies a clause to the execution plan.
func applyClause(clause types.Clause, plan *ExecutionPlan, verb types.Verb) error {
	switch c := clause.(type) {
	case types.UsingClause:
		// Validate compatibility before applying
		if err := validateUsingClause(verb, c.Method); err != nil {
			return err
		}
		// Normalize to uppercase (defensive, should already be normalized in parser)
		plan.Method = strings.ToUpper(c.Method)
	case types.HeadersClause:
		for k, v := range c.Headers {
			plan.Headers[k] = v
		}
	case types.ParamsClause:
		for k, v := range c.Params {
			plan.QueryParams[k] = v
		}
	case types.WithClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		
		// Handle file or stdin
		if c.IsFile {
			plan.Body.FilePath = c.Value
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for files
			}
		} else if c.IsStdin {
			plan.Body.FilePath = "-" // Special marker for stdin
			plan.Body.Type = c.Type
			if plan.Body.Type == "" {
				plan.Body.Type = "raw" // Default for stdin
			}
		} else {
			plan.Body.Content = c.Value
			plan.Body.Type = c.Type
			// If type was inferred as JSON, we'll note it in runtime
			if plan.Body.Type == "json" {
				// JSON inference will be logged in runtime
			}
		}
		
		// If method is still GET and we have a body, default to POST
		if plan.Method == http.MethodGet {
			plan.Method = http.MethodPost
		}
	case types.AsClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Format = c.Format
	case types.ToClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Destination = c.Destination
	case types.RetryClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{
				Backoff: BackoffRange{
					Min: 200 * time.Millisecond,
					Max: 5 * time.Second,
				},
			}
		}
		plan.Retry.Count = c.Count
	case types.BackoffClause:
		if plan.Retry == nil {
			plan.Retry = &RetryPlan{Count: 3}
		}
		plan.Retry.Backoff = BackoffRange{
			Min: c.Min,
			Max: c.Max,
		}
	case types.TimeoutClause:
		plan.Timeout = &c.Duration
	case types.ProxyClause:
		plan.Proxy = c.URL
	case types.PickClause:
		if plan.Output == nil {
			plan.Output = &OutputPlan{}
		}
		plan.Output.Pick = c.Path
	case types.InsecureClause:
		plan.Insecure = c.Value
	case types.ViaClause:
		plan.Proxy = c.URL
	case types.IncludeClause:
		// Merge include items into headers, params, or cookies
		for _, item := range c.Items {
			switch item.Type {
			case "header":
				// For multi-valued headers, we'd need to track arrays, but for now last wins
				// TODO: Support multi-valued headers properly
				plan.Headers[item.Name] = item.Value
			case "param":
				// Params can be repeated, so we append to query params
				// The runtime will handle serialization
				plan.QueryParams[item.Name] = item.Value
			case "cookie":
				// Cookies: last value wins
				plan.Cookies[item.Name] = item.Value
			case "basic":
				// Basic Auth: encode username:password and set Authorization header
				// item.Value contains "username:password"
				credentials := item.Value
				// Base64 encode the credentials
				encoded := base64.StdEncoding.EncodeToString([]byte(credentials))
				// Set Authorization header with Basic scheme
				plan.Headers["Authorization"] = "Basic " + encoded
			}
		}
	case types.AttachClause:
		if plan.Body == nil {
			plan.Body = &BodyPlan{}
		}
		plan.Body.Type = "multipart"
		plan.Body.AttachParts = c.Parts
		if c.Boundary != "" {
			plan.Body.Boundary = c.Boundary
		}
	case types.ExpectClause:
		plan.Expect = c.Checks
	case types.FollowClause:
		plan.Follow = c.Policy
	case types.UnderClause:
		if c.IsSize {
			plan.SizeLimit = &c.Size
		} else {
			plan.Timeout = &c.Duration
		}
	case types.VerboseClause:
		plan.Verbose = true
	case types.ResumeClause:
		plan.Resume = true
	default:
		return fmt.Errorf("unsupported clause type: %T", clause)
	}
	return nil
}

// validatePlan validates the execution plan.
func validatePlan(plan *ExecutionPlan) error {
	if plan.Method == "" {
		return fmt.Errorf("method is required")
	}
	if plan.URL == "" {
		return fmt.Errorf("URL is required")
	}
	
	// Validate upload verb: must have attach= or with=
	// This check will be done after clauses are processed, so we check here
	// Actually, we need to check this in Plan() after processing clauses
	// For now, we'll do basic validation
	
	return nil
}

// extractFilenameFromURL extracts a filename from a URL.
func extractFilenameFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Get the path
	path := u.Path
	if path == "" || path == "/" {
		// Try to get from query or fragment
		return "download"
	}

	// Remove leading slash
	path = strings.TrimPrefix(path, "/")

	// Get the last segment
	parts := strings.Split(path, "/")
	if len(parts) == 0 {
		return "download"
	}

	filename := parts[len(parts)-1]

	// URL decode the filename (handle both path and query encoding)
	filename, err = url.PathUnescape(filename)
	if err != nil {
		// If PathUnescape fails, try QueryUnescape
		filename, err = url.QueryUnescape(filename)
		if err != nil {
			// If decoding fails, use the original
			filename = parts[len(parts)-1]
		}
	}

	// If filename is empty or doesn't have an extension, use a default
	if filename == "" || !strings.Contains(filename, ".") {
		filename = "download"
	}

	// Clean the filename (remove any path separators)
	filename = filepath.Base(filename)

	return filename
}

// isDirectory checks if a path is a directory.
func isDirectory(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}


----
internal/runtime/executor.go
// Package runtime executes HTTP requests based on execution plans.
package runtime

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/andybalholm/brotli"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
	"github.com/adammpkins/req/internal/session"
)

// Executor executes HTTP requests.
type Executor struct {
	client *http.Client
}

// NewExecutor creates a new executor.
func NewExecutor(plan *planner.ExecutionPlan) (*Executor, error) {
	jar, err := cookiejar.New(nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create cookie jar: %w", err)
	}

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{},
	}

	// Configure TLS if insecure
	if plan.Insecure {
		transport.TLSClientConfig = getInsecureTLSConfig()
		fmt.Fprintf(os.Stderr, "Warning: TLS verification disabled\n")
	}

	// Configure proxy if specified
	if plan.Proxy != "" {
		proxyURL, err := url.Parse(plan.Proxy)
		if err != nil {
			return nil, fmt.Errorf("invalid proxy URL: %w", err)
		}
		transport.Proxy = http.ProxyURL(proxyURL)
	}

	client := &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
		Jar:       jar,
	}

	if plan.Timeout != nil {
		client.Timeout = *plan.Timeout
	}

	return &Executor{client: client}, nil
}

// Execute executes an HTTP request based on the plan.
func (e *Executor) Execute(plan *planner.ExecutionPlan) error {
	// Build request URL with query parameters (preserving order)
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("invalid URL: %v", err)}
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to build body: %v", err)}
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return &ExecutionError{Code: 5, Message: fmt.Sprintf("failed to create request: %v", err)}
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Auto-apply session if available and not explicitly set
	e.autoApplySession(req, plan)

	// Add Accept-Encoding if not set by user
	if req.Header.Get("Accept-Encoding") == "" {
		req.Header.Set("Accept-Encoding", "gzip, br")
	}

	// Execute request with redirect handling
	// For authenticate verb, we need to capture Set-Cookie from redirect responses
	var resp *http.Response
	var redirectTrace []string
	var bodyBytes []byte
	var decompressed bool
	var allSetCookies []string

	if plan.Verb == types.VerbAuthenticate {
		resp, redirectTrace, allSetCookies, err = e.executeWithRedirectsCapturingCookies(req, plan)
		if err != nil {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
		}
		defer resp.Body.Close()
		// Also include Set-Cookie from final response
		allSetCookies = append(allSetCookies, resp.Header.Values("Set-Cookie")...)
	} else {
		resp, redirectTrace, err = e.executeWithRedirects(req, plan)
		if err != nil {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("request failed: %v", err)}
		}
		defer resp.Body.Close()
	}

	// Print redirect trace to stderr
	if len(redirectTrace) > 0 {
		for _, trace := range redirectTrace {
			fmt.Fprintf(os.Stderr, "%s\n", trace)
		}
	}

	// Read and decompress response body
	bodyBytes, decompressed, err = e.readAndDecompress(resp)
	if err != nil {
		return &ExecutionError{Code: 4, Message: fmt.Sprintf("failed to read response: %v", err)}
	}

	if decompressed {
		fmt.Fprintf(os.Stderr, "Decompressed response\n")
	}

	// Print meta to stderr
	e.printMeta(resp, reqURL, len(bodyBytes), decompressed)

	// Capture session for authenticate verb
	if plan.Verb == types.VerbAuthenticate {
		host, err := session.ExtractHost(plan.URL)
		if err == nil {
			updatedSession, err := session.UpdateSessionFromResponse(host, allSetCookies, bodyBytes)
			if err == nil && updatedSession != nil {
				if err := session.SaveSession(updatedSession); err == nil {
					fmt.Fprintf(os.Stderr, "Session saved for %s\n", host)
				}
			}
		}
	}

	// Run expect checks
	if len(plan.Expect) > 0 {
		if err := e.runExpectChecks(resp, bodyBytes, plan.Expect); err != nil {
			fmt.Fprintf(os.Stderr, "%s\n", err.Error())
			return &ExecutionError{Code: 3, Message: "expectation failed"}
		}
	} else {
		// If no expect checks, fail on non-2xx status codes
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			return &ExecutionError{Code: 4, Message: fmt.Sprintf("HTTP %d %s", resp.StatusCode, resp.Status)}
		}
	}

	// Handle output based on plan
	if plan.Output != nil && plan.Output.Destination != "" {
		// Save to file - uses io.Copy for efficient writing
		// TODO: Optimize to stream directly from resp.Body when no expect checks
		return e.saveToFile(bytes.NewReader(bodyBytes), plan.Output.Destination)
	}

	// Handle watch verb with TTY detection
	if plan.Verb == types.VerbWatch {
		// TODO: Implement TTY detection
		// TTY: timestamped lines
		// Non-TTY: raw lines
		return e.writeOutput(bodyBytes, plan.Output)
	}

	// Format and write output
	return e.writeOutput(bodyBytes, plan.Output)
}

// ExecutionError represents an execution error with exit code.
type ExecutionError struct {
	Code    int
	Message string
}

func (e *ExecutionError) Error() string {
	return e.Message
}

// buildURL builds the request URL with query parameters, preserving order.
func (e *Executor) buildURL(plan *planner.ExecutionPlan) (string, error) {
	u, err := url.Parse(plan.URL)
	if err != nil {
		return "", err
	}

	// Merge existing query params with new ones
	existingParams := u.Query()
	for k, v := range plan.QueryParams {
		// Append to preserve order for repeated keys
		existingParams.Add(k, v)
	}
	u.RawQuery = existingParams.Encode()

	return u.String(), nil
}

// buildBody builds the request body.
func (e *Executor) buildBody(plan *planner.ExecutionPlan) (io.Reader, string, error) {
	if plan.Body == nil {
		return nil, "", nil
	}

	// Handle multipart
	if plan.Body.Type == "multipart" {
		return e.buildMultipartBody(plan.Body)
	}

	// Handle file or stdin
	if plan.Body.FilePath != "" {
		if plan.Body.FilePath == "-" {
			// Read from stdin
			data, err := io.ReadAll(os.Stdin)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read stdin: %w", err)
			}
			plan.Body.Content = string(data)
		} else {
			// Read from file
			data, err := os.ReadFile(plan.Body.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", plan.Body.FilePath, err)
			}
			plan.Body.Content = string(data)
		}
	}

	// Determine content type
	contentType := ""
	if plan.Body.Type == "json" {
		contentType = "application/json"
		// Log JSON inference if it was inferred
		if strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "{") || strings.HasPrefix(strings.TrimSpace(plan.Body.Content), "[") {
			fmt.Fprintf(os.Stderr, "Inferred Content-Type: application/json\n")
		}
	} else if plan.Body.Type == "form" {
		contentType = "application/x-www-form-urlencoded"
	}

	return strings.NewReader(plan.Body.Content), contentType, nil
}

// buildMultipartBody builds a multipart/form-data body.
func (e *Executor) buildMultipartBody(bodyPlan *planner.BodyPlan) (io.Reader, string, error) {
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	boundary := bodyPlan.Boundary
	if boundary == "" {
		boundary = writer.Boundary()
	} else {
		writer.SetBoundary(boundary)
	}

	for _, part := range bodyPlan.AttachParts {
		var partWriter io.Writer
		var err error

		// Create form field
		if part.Filename != "" {
			partWriter, err = writer.CreateFormFile(part.Name, part.Filename)
		} else {
			partWriter, err = writer.CreateFormField(part.Name)
		}
		if err != nil {
			return nil, "", fmt.Errorf("failed to create form field: %w", err)
		}

		// Write part content
		if part.FilePath != "" {
			// Read file
			data, err := os.ReadFile(part.FilePath)
			if err != nil {
				return nil, "", fmt.Errorf("failed to read file %s: %w", part.FilePath, err)
			}
			if _, err := partWriter.Write(data); err != nil {
				return nil, "", fmt.Errorf("failed to write file data: %w", err)
			}
		} else {
			// Write value
			if _, err := partWriter.Write([]byte(part.Value)); err != nil {
				return nil, "", fmt.Errorf("failed to write value: %w", err)
			}
		}
	}

	if err := writer.Close(); err != nil {
		return nil, "", fmt.Errorf("failed to close multipart writer: %w", err)
	}

	contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
	return &buf, contentType, nil
}

// setHeaders sets request headers.
func (e *Executor) setHeaders(req *http.Request, plan *planner.ExecutionPlan, contentType string) {
	// Set user headers first
	for k, v := range plan.Headers {
		req.Header.Set(k, v)
	}

	// Override Content-Type if multipart (user may have set it manually)
	if plan.Body != nil && plan.Body.Type == "multipart" {
		if contentType != "" {
			req.Header.Set("Content-Type", contentType)
			// Check if user had set Content-Type manually
			if _, wasSet := plan.Headers["Content-Type"]; wasSet {
				fmt.Fprintf(os.Stderr, "Note: Content-Type overridden for multipart\n")
			}
		}
	} else if contentType != "" && req.Header.Get("Content-Type") == "" {
		req.Header.Set("Content-Type", contentType)
	}
}

// setCookies sets request cookies.
func (e *Executor) setCookies(req *http.Request, plan *planner.ExecutionPlan) {
	for name, value := range plan.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}
}

// autoApplySession automatically applies a stored session if available.
func (e *Executor) autoApplySession(req *http.Request, plan *planner.ExecutionPlan) {
	// Don't auto-apply if Authorization or Cookie headers are explicitly set
	hasAuth := req.Header.Get("Authorization") != ""
	hasCookie := false
	for name := range plan.Cookies {
		if name != "" {
			hasCookie = true
			break
		}
	}
	if hasAuth || hasCookie {
		return
	}

	// Extract host from URL
	host, err := session.ExtractHost(plan.URL)
	if err != nil {
		return
	}

	// Load session
	sess, err := session.LoadSession(host)
	if err != nil || sess == nil {
		return
	}

	// Apply authorization if available
	if sess.Authorization != "" {
		req.Header.Set("Authorization", sess.Authorization)
	}

	// Apply cookies
	for name, value := range sess.Cookies {
		req.AddCookie(&http.Cookie{
			Name:  name,
			Value: value,
		})
	}

	fmt.Fprintf(os.Stderr, "Using session for %s\n", host)
}

// executeWithRedirects executes the request with redirect handling.
func (e *Executor) executeWithRedirects(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, error) {
	maxRedirects := 5
	var redirectTrace []string

	// Determine redirect policy based on verb
	shouldFollow := false
	isWriteVerb := plan.Method == "POST" || plan.Method == "PUT" || plan.Method == "PATCH" || plan.Method == "DELETE"

	if plan.Follow == "smart" {
		// Smart follow: only follow 307/308 for write verbs
		shouldFollow = true
	} else {
		// Default: read, save, and authenticate follow, write verbs don't
		if plan.Verb == types.VerbRead || plan.Verb == types.VerbSave || plan.Verb == types.VerbAuthenticate {
			shouldFollow = true
		} else if isWriteVerb {
			shouldFollow = false
		} else {
			// Other verbs (watch, inspect) don't follow by default
			shouldFollow = false
		}
	}

	if !shouldFollow {
		resp, err := e.client.Do(req)
		if err == nil && isWriteVerb && (resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303) {
			redirectTrace = append(redirectTrace, fmt.Sprintf("Advisory: %d redirect for write verb, not following", resp.StatusCode))
		}
		return resp, redirectTrace, err
	}

	// Follow redirects
	redirects := 0
	client := *e.client
	client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if redirects >= maxRedirects {
			return fmt.Errorf("stopped after %d redirects", maxRedirects)
		}

		// For smart follow with write verbs, only follow 307/308
		if plan.Follow == "smart" && isWriteVerb {
			statusCode := via[len(via)-1].Response.StatusCode
			if statusCode != 307 && statusCode != 308 {
				return fmt.Errorf("write verb: not following %d redirect (use 307/308)", statusCode)
			}
		}

		redirects++
		statusCode := via[len(via)-1].Response.StatusCode
		redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", statusCode, req.Method, req.URL.String()))
		return nil
	}

	resp, err := client.Do(req)
	return resp, redirectTrace, err
}

// executeWithRedirectsCapturingCookies executes the request with redirect handling,
// capturing Set-Cookie headers from all redirect responses.
// This is needed for authenticate verb to capture cookies from redirect responses.
func (e *Executor) executeWithRedirectsCapturingCookies(req *http.Request, plan *planner.ExecutionPlan) (*http.Response, []string, []string, error) {
	maxRedirects := 5
	var redirectTrace []string
	var allSetCookies []string

	// Use the client's CookieJar to automatically handle cookies during redirects
	// Then extract cookies from the jar after redirects complete
	client := *e.client
	client.CheckRedirect = nil // Disable automatic redirect following

	originalURL := req.URL
	for i := 0; i < maxRedirects; i++ {
		resp, err := client.Do(req)
		if err != nil {
			return nil, redirectTrace, allSetCookies, err
		}

		// Capture Set-Cookie headers from this response
		setCookies := resp.Header.Values("Set-Cookie")
		allSetCookies = append(allSetCookies, setCookies...)

		// Check if this is a redirect
		if resp.StatusCode >= 300 && resp.StatusCode < 400 {
			location := resp.Header.Get("Location")
			if location == "" {
				resp.Body.Close()
				return resp, redirectTrace, allSetCookies, nil
			}

			// Parse the location URL
			redirectURL, err := url.Parse(location)
			if err != nil {
				resp.Body.Close()
				return resp, redirectTrace, allSetCookies, fmt.Errorf("invalid redirect URL: %w", err)
			}

			// Make location absolute if needed
			if !redirectURL.IsAbs() {
				baseURL, _ := url.Parse(req.URL.String())
				redirectURL = baseURL.ResolveReference(redirectURL)
			}

			// Create new request for redirect
			redirectTrace = append(redirectTrace, fmt.Sprintf("→ %d %s %s", resp.StatusCode, req.Method, redirectURL.String()))
			resp.Body.Close()

			// Create new request for redirect (preserve method for 307/308)
			method := req.Method
			if resp.StatusCode == 301 || resp.StatusCode == 302 || resp.StatusCode == 303 {
				// Change to GET for these redirects
				method = "GET"
			}

			newReq, err := http.NewRequest(method, redirectURL.String(), nil)
			if err != nil {
				return nil, redirectTrace, allSetCookies, fmt.Errorf("failed to create redirect request: %w", err)
			}

			// Copy headers from original request
			for k, v := range req.Header {
				newReq.Header[k] = v
			}
			req = newReq
			continue
		}

		// Not a redirect, return the response
		// Extract cookies from CookieJar for the original host
		if client.Jar != nil {
			hostURL, err := url.Parse(originalURL.Scheme + "://" + originalURL.Host)
			if err == nil {
				jarCookies := client.Jar.Cookies(hostURL)
				// Convert jar cookies to Set-Cookie format strings
				for _, cookie := range jarCookies {
					allSetCookies = append(allSetCookies, fmt.Sprintf("%s=%s", cookie.Name, cookie.Value))
				}
			}
		}
		return resp, redirectTrace, allSetCookies, nil
	}

	return nil, redirectTrace, allSetCookies, fmt.Errorf("stopped after %d redirects", maxRedirects)
}

// readAndDecompress reads and decompresses the response body.
func (e *Executor) readAndDecompress(resp *http.Response) ([]byte, bool, error) {
	var reader io.Reader = resp.Body
	decompressed := false

	// Check if compressed - handle case-insensitive and multiple encodings
	encoding := resp.Header.Get("Content-Encoding")
	if encoding != "" {
		// Split by comma and check each encoding (case-insensitive)
		// Process encodings in reverse order (last encoding applied first)
		encodings := strings.Split(encoding, ",")
		for i := len(encodings) - 1; i >= 0; i-- {
			enc := strings.TrimSpace(strings.ToLower(encodings[i]))
			if enc == "gzip" {
				gzipReader, err := gzip.NewReader(reader)
				if err != nil {
					return nil, false, fmt.Errorf("failed to create gzip reader: %w", err)
				}
				defer gzipReader.Close()
				reader = gzipReader
				decompressed = true
			} else if enc == "br" {
				// brotli.Reader implements io.Reader
				reader = brotli.NewReader(reader)
				decompressed = true
			}
		}
	}

	data, err := io.ReadAll(reader)
	return data, decompressed, err
}

// runExpectChecks runs expectation checks on the response.
func (e *Executor) runExpectChecks(resp *http.Response, body []byte, checks []types.ExpectCheck) error {
	for _, check := range checks {
		if err := e.runExpectCheck(resp, body, check); err != nil {
			return err
		}
	}
	return nil
}

// runExpectCheck runs a single expectation check.
func (e *Executor) runExpectCheck(resp *http.Response, body []byte, check types.ExpectCheck) error {
	switch check.Type {
	case "status":
		expected := check.Value
		actual := fmt.Sprintf("%d", resp.StatusCode)
		if actual != expected {
			return fmt.Errorf("expected status %s, got %s", expected, actual)
		}

	case "header":
		actual := resp.Header.Get(check.Name)
		if actual != check.Value {
			return fmt.Errorf("expected header %s=%s, got %s", check.Name, check.Value, actual)
		}

	case "contains":
		if !strings.Contains(string(body), check.Value) {
			return fmt.Errorf("expected body to contain %q", check.Value)
		}

	case "jsonpath":
		// Simple JSON path extraction (basic implementation)
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			return fmt.Errorf("failed to parse JSON: %w", err)
		}
		// TODO: Implement proper JSONPath evaluation
		// For now, just check if JSON is valid
		_ = data

	case "matches":
		matched, err := regexp.MatchString(check.Regex, string(body))
		if err != nil {
			return fmt.Errorf("invalid regex: %w", err)
		}
		if !matched {
			return fmt.Errorf("body does not match regex %q", check.Regex)
		}

	default:
		return fmt.Errorf("unknown expect check type: %s", check.Type)
	}

	return nil
}

// printMeta prints metadata to stderr.
func (e *Executor) printMeta(resp *http.Response, url string, bodySize int, decompressed bool) {
	fmt.Fprintf(os.Stderr, "HTTP %d\n", resp.StatusCode)
	fmt.Fprintf(os.Stderr, "URL: %s\n", url)
	fmt.Fprintf(os.Stderr, "Size: %d bytes\n", bodySize)
	if ct := resp.Header.Get("Content-Type"); ct != "" {
		fmt.Fprintf(os.Stderr, "Content-Type: %s\n", ct)
	}
}

// writeOutput formats and writes output to stdout.
func (e *Executor) writeOutput(body []byte, output *planner.OutputPlan) error {
	if output == nil {
		// Default: raw output
		_, err := os.Stdout.Write(body)
		return err
	}

	switch output.Format {
	case "json":
		// Pretty print JSON
		var data interface{}
		if err := json.Unmarshal(body, &data); err != nil {
			// Not JSON, output as-is
			_, err := os.Stdout.Write(body)
			return err
		}
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		return encoder.Encode(data)

	case "text":
		// Output as text
		_, err := os.Stdout.Write(body)
		return err

	case "raw":
		// Raw output
		_, err := os.Stdout.Write(body)
		return err

	case "csv":
		// CSV output (basic - would need proper CSV parsing)
		_, err := os.Stdout.Write(body)
		return err

	default:
		// Default: raw
		_, err := os.Stdout.Write(body)
		return err
	}
}

// saveToFile saves the response body to a file.
func (e *Executor) saveToFile(body io.Reader, destination string) error {
	// Create directory if needed
	dir := filepath.Dir(destination)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
	}

	// Create file
	file, err := os.Create(destination)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Copy response body to file
	_, err = io.Copy(file, body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// getInsecureTLSConfig returns an insecure TLS config.
func getInsecureTLSConfig() *tls.Config {
	return &tls.Config{
		InsecureSkipVerify: true,
	}
}

// ExecuteWithResponse executes an HTTP request and returns the response body as a string.
// This is useful for TUI mode where we need to capture and format the response.
func (e *Executor) ExecuteWithResponse(plan *planner.ExecutionPlan) (string, error) {
	// Build request URL with query parameters
	reqURL, err := e.buildURL(plan)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}

	// Build request body
	body, contentType, err := e.buildBody(plan)
	if err != nil {
		return "", fmt.Errorf("failed to build body: %w", err)
	}

	// Create request
	req, err := http.NewRequest(plan.Method, reqURL, body)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	e.setHeaders(req, plan, contentType)

	// Set cookies
	e.setCookies(req, plan)

	// Execute request
	resp, _, err := e.executeWithRedirects(req, plan)
	if err != nil {
		return "", fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	// Read and decompress response body
	bodyBytes, _, err := e.readAndDecompress(resp)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %w", err)
	}

	return string(bodyBytes), nil
}

----
internal/session/session.go
// Package session manages HTTP sessions (cookies and tokens) per host.
package session

import (
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// Session represents a stored session for a host.
type Session struct {
	Host          string            `json:"host"`
	Cookies       map[string]string `json:"cookies,omitempty"`
	Authorization string            `json:"authorization,omitempty"` // Bearer token
}

var (
	stateDir     string
	stateDirOnce sync.Once
)

// getStateDir returns the user state directory for storing sessions.
func getStateDir() string {
	stateDirOnce.Do(func() {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to current directory
			stateDir = ".req"
			return
		}
		stateDir = filepath.Join(homeDir, ".config", "req")
	})
	return stateDir
}

// ensureStateDir ensures the state directory exists with proper permissions.
func ensureStateDir() error {
	dir := getStateDir()
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}
	return nil
}

// getSessionPath returns the file path for a host's session.
func getSessionPath(host string) (string, error) {
	if err := ensureStateDir(); err != nil {
		return "", err
	}
	// Sanitize host name for filename
	safeHost := strings.ReplaceAll(host, ":", "_")
	safeHost = strings.ReplaceAll(safeHost, "/", "_")
	return filepath.Join(getStateDir(), fmt.Sprintf("session_%s.json", safeHost)), nil
}

// LoadSession loads a session for the given host.
func LoadSession(host string) (*Session, error) {
	path, err := getSessionPath(host)
	if err != nil {
		return nil, err
	}

	// Check file permissions - refuse to load if group or world readable
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // No session exists
		}
		return nil, fmt.Errorf("failed to stat session file: %w", err)
	}

	mode := info.Mode().Perm()
	// Check if group or others have read permission (044, 004, or any combination)
	if mode&0044 != 0 {
		return nil, fmt.Errorf("session file %s has insecure permissions (%s): group or world readable, refusing to load", path, mode.String())
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read session: %w", err)
	}

	var session Session
	if err := json.Unmarshal(data, &session); err != nil {
		return nil, fmt.Errorf("failed to parse session: %w", err)
	}

	return &session, nil
}

// SaveSession saves a session for the given host.
func SaveSession(session *Session) error {
	path, err := getSessionPath(session.Host)
	if err != nil {
		return err
	}

	data, err := json.MarshalIndent(session, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal session: %w", err)
	}

	// Write with strict permissions (0600)
	if err := os.WriteFile(path, data, 0600); err != nil {
		return fmt.Errorf("failed to write session: %w", err)
	}

	return nil
}

// DeleteSession deletes a session for the given host.
func DeleteSession(host string) error {
	path, err := getSessionPath(host)
	if err != nil {
		return err
	}

	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil // Already deleted
		}
		return fmt.Errorf("failed to delete session: %w", err)
	}

	return nil
}

// ExtractHost extracts the host from a URL.
func ExtractHost(urlStr string) (string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", fmt.Errorf("invalid URL: %w", err)
	}
	return u.Host, nil
}

// UpdateSessionFromResponse updates a session from an HTTP response.
// Captures Set-Cookie headers and access_token from JSON body.
func UpdateSessionFromResponse(host string, setCookies []string, body []byte) (*Session, error) {
	session, err := LoadSession(host)
	if err != nil {
		return nil, err
	}

	if session == nil {
		session = &Session{
			Host:    host,
			Cookies: make(map[string]string),
		}
	}

	// Parse Set-Cookie headers
	for _, cookieHeader := range setCookies {
		// Simple cookie parsing (just get name=value part)
		parts := strings.Split(cookieHeader, ";")
		if len(parts) > 0 {
			cookiePart := strings.TrimSpace(parts[0])
			eqIdx := strings.Index(cookiePart, "=")
			if eqIdx > 0 {
				name := cookiePart[:eqIdx]
				value := cookiePart[eqIdx+1:]
				session.Cookies[name] = value
			}
		}
	}

	// Try to extract access_token from JSON body
	if len(body) > 0 {
		var jsonData map[string]interface{}
		if err := json.Unmarshal(body, &jsonData); err == nil {
			if token, ok := jsonData["access_token"].(string); ok && token != "" {
				session.Authorization = "Bearer " + token
			}
		}
	}

	return session, nil
}

// ListSessions lists all stored sessions.
func ListSessions() ([]string, error) {
	dir := getStateDir()
	entries, err := os.ReadDir(dir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read state directory: %w", err)
	}

	var hosts []string
	for _, entry := range entries {
		if strings.HasPrefix(entry.Name(), "session_") && strings.HasSuffix(entry.Name(), ".json") {
			// Extract host from filename
			host := strings.TrimPrefix(entry.Name(), "session_")
			host = strings.TrimSuffix(host, ".json")
			host = strings.ReplaceAll(host, "_", ":")
			hosts = append(hosts, host)
		}
	}

	return hosts, nil
}

// RedactSession creates a redacted version of a session for display.
func RedactSession(session *Session) *Session {
	redacted := &Session{
		Host:          session.Host,
		Cookies:       make(map[string]string),
		Authorization: "",
	}

	// Redact cookies (show only names)
	for name := range session.Cookies {
		redacted.Cookies[name] = "***"
	}

	// Redact authorization
	if session.Authorization != "" {
		redacted.Authorization = "Bearer ***"
	}

	return redacted
}


----
internal/tui/app.go
// Package tui provides an interactive terminal user interface for req.
package tui

import (
	"fmt"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/adammpkins/req/internal/tui/views"
)

// Launch starts the TUI application.
func Launch() error {
	p := tea.NewProgram(NewModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("failed to run TUI: %w", err)
	}
	return nil
}

// Model represents the application state.
type Model struct {
	view View
}

// NewModel creates a new TUI model.
func NewModel() Model {
	return Model{
		view: views.NewBuilderView(),
	}
}

// Init initializes the model.
func (m Model) Init() tea.Cmd {
	// WindowSizeMsg will be sent automatically by bubbletea
	return m.view.Init()
}

// Update handles messages and updates the model.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		}
	case tea.WindowSizeMsg:
		// Pass window size to view
		var cmd tea.Cmd
		m.view, cmd = m.view.Update(msg)
		return m, cmd
	}

	var cmd tea.Cmd
	m.view, cmd = m.view.Update(msg)
	return m, cmd
}

// View renders the current view.
func (m Model) View() string {
	return m.view.View()
}

// View represents a TUI view (exported from views package).
type View = views.View


----
internal/tui/views/builder.go
package views

import (
	"encoding/json"
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/bubbles/viewport"
	"github.com/charmbracelet/huh"
	"github.com/charmbracelet/lipgloss"
	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("62")).
			Padding(1, 2)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("196")).
			Padding(1, 2).
			Width(80)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46")).
			Padding(1, 2).
			Width(80)

	commandStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252")).
			Padding(1, 2).
			Width(80)

	// JSON syntax highlighting styles
	jsonKeyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true)

	jsonStringStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("46"))

	jsonNumberStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("220"))

	jsonBoolStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("213"))

	jsonNullStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("240")).
			Italic(true)

	jsonPunctStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("252"))

	outputStyle = lipgloss.NewStyle().
			Padding(1, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("62"))
)

// View represents a TUI view interface.
type View interface {
	Init() tea.Cmd
	Update(msg tea.Msg) (View, tea.Cmd)
	View() string
}

// BuilderView is an interactive command builder.
type BuilderView struct {
	form         *huh.Form
	executed     bool
	response     string
	responseBody string
	formattedBody string
	err          error
	verb         string
	url          string
	execute      bool
	width        int
	height       int
	viewport     viewport.Model
}

// NewBuilderView creates a new builder view.
func NewBuilderView() View {
	vp := viewport.New(80, 20) // default width and height
	b := &BuilderView{
		width:    80, // default width
		height:   20, // default height
		viewport: vp,
	}

	form := huh.NewForm(
		huh.NewGroup(
			huh.NewSelect[string]().
				Title("Verb").
				Description("Select the action to perform").
				Options(
					huh.NewOption("read - Read a resource (GET)", "read"),
					huh.NewOption("save - Save a resource to file (GET)", "save"),
					huh.NewOption("send - Send data (POST)", "send"),
				).
				Value(&b.verb).
				Key("verb"),

			huh.NewInput().
				Title("URL").
				Description("Enter the target URL").
				Placeholder("https://api.example.com/users").
				Value(&b.url).
				Key("url"),

			huh.NewConfirm().
				Title("Execute immediately?").
				Description("Execute the command when form is complete").
				Value(&b.execute).
				Key("execute"),
		),
	)

	b.form = form
	return b
}

// Init initializes the view.
func (b *BuilderView) Init() tea.Cmd {
	return b.form.Init()
}

// Update handles messages.
func (b *BuilderView) Update(msg tea.Msg) (View, tea.Cmd) {
	var cmds []tea.Cmd

	// Handle window size messages first
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		b.width = msg.Width
		b.height = msg.Height
		if b.width == 0 {
			b.width = 80 // default width
		}
		if b.height == 0 {
			b.height = 20 // default height
		}
		// Update viewport size
		b.updateViewportSize()
	}

	// Handle keyboard input
	switch msg := msg.(type) {
	case tea.KeyMsg:
		key := msg.String()
		
		// If we have output to scroll, handle scrolling keys first
		if b.formattedBody != "" {
			// Check if it's a scrolling key
			switch key {
			case "up", "k", "pgup":
				b.viewport.LineUp(1)
				return b, nil
			case "down", "j", "pgdown":
				b.viewport.LineDown(1)
				return b, nil
			case "home":
				b.viewport.GotoTop()
				return b, nil
			case "end":
				b.viewport.GotoBottom()
				return b, nil
			case "ctrl+u":
				b.viewport.LineUp(b.viewport.Height / 2)
				return b, nil
			case "ctrl+d":
				b.viewport.LineDown(b.viewport.Height / 2)
				return b, nil
			case "esc":
				return b, tea.Quit
			}
		} else {
			// No output, just handle quit
			switch key {
			case "esc":
				return b, tea.Quit
			}
		}
	}

	// Update form (only if not a scrolling key when we have output)
	form, cmd := b.form.Update(msg)
	if f, ok := form.(*huh.Form); ok {
		b.form = f
		cmds = append(cmds, cmd)
	}

	// Handle messages from command execution
	switch msg := msg.(type) {
	case ErrorMsg:
		b.err = msg.Err
		b.executed = false
		b.responseBody = ""
		b.formattedBody = ""
		b.viewport.SetContent("")
	case SuccessMsg:
		b.response = msg.Message
		b.responseBody = msg.ResponseBody
		b.err = nil
		// Format the response body
		b.updateFormattedBody()
	}
	
	// Handle viewport updates for other messages (like mouse wheel, etc.)
	if b.formattedBody != "" {
		vp, cmd := b.viewport.Update(msg)
		b.viewport = vp
		if cmd != nil {
			cmds = append(cmds, cmd)
		}
	}

	// Check if form is complete and should execute
	if b.form.State == huh.StateCompleted {
		if !b.executed && b.verb != "" && b.url != "" {
			// Values are already bound to b.verb, b.url, and b.execute via Value() in form creation
			// The bound variables are updated automatically when form fields change
			if b.execute {
				b.executed = true
				cmds = append(cmds, b.executeCommand())
			} else {
				// Form completed but execute was false - show message
				b.response = "Command built but not executed. Press 'esc' to exit."
			}
		}
	}

	return b, tea.Batch(cmds...)
}

// executeCommand executes the built command.
func (b *BuilderView) executeCommand() tea.Cmd {
	return func() tea.Msg {
		// Build command string
		cmdStr := fmt.Sprintf("%s %s", b.verb, b.url)
		
		// Parse command
		cmd, err := parser.Parse(cmdStr)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Plan execution
		plan, err := planner.Plan(cmd)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Execute
		executor, err := runtime.NewExecutor(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		// Capture response body for TUI display
		responseBody, err := executor.ExecuteWithResponse(plan)
		if err != nil {
			return ErrorMsg{Err: err}
		}

		return SuccessMsg{
			Message:      "Command executed successfully",
			ResponseBody: responseBody,
		}
	}
}

// View renders the view.
func (b *BuilderView) View() string {
	var s strings.Builder

	s.WriteString(titleStyle.Render("req - Interactive Command Builder"))
	s.WriteString("\n\n")

	if b.err != nil {
		s.WriteString(errorStyle.Render(fmt.Sprintf("Error: %v", b.err)))
		s.WriteString("\n\n")
	}

	if b.response != "" {
		s.WriteString(successStyle.Render(b.response))
		s.WriteString("\n\n")
	}

	// Display response body with formatting (using viewport for scrolling)
	if b.formattedBody != "" {
		// Calculate available width and height for viewport
		contentWidth := b.width - 6 // Account for border and padding
		if contentWidth < 20 {
			contentWidth = 20 // Minimum width
		}
		
		// Calculate available height (account for header, success message, form, command line, instructions)
		// Rough estimate: title ~3, success ~2, form ~varies, command ~2, instructions ~1 = ~8-10 lines
		// Reserve some space for the form and other UI elements
		availableHeight := b.height - 15 // Reserve space for other UI elements
		if availableHeight < 5 {
			availableHeight = 5 // Minimum height
		}
		
		// Update viewport dimensions if needed
		b.updateViewportSize()
		
		// Render viewport with border
		// The viewport handles its own height, so we just need to wrap it with the border style
		viewportContent := b.viewport.View()
		// Use the viewport's actual dimensions for the border
		s.WriteString(outputStyle.Width(contentWidth + 4).Render(viewportContent))
		s.WriteString("\n\n")
	}

	s.WriteString(b.form.View())
	
	// Show current values when form is completed
	if b.form.State == huh.StateCompleted {
		s.WriteString("\n\n")
		if b.verb != "" && b.url != "" {
			cmdText := fmt.Sprintf("Command: %s %s", b.verb, b.url)
			// Wrap the command text to fit terminal width
			width := b.width
			if width == 0 {
				width = 80 // default width
			}
			wrapped := wrapText(cmdText, width)
			s.WriteString(commandStyle.Render(wrapped))
			s.WriteString("\n")
			if b.response != "" {
				s.WriteString("\n")
			}
		}
	}
	
	s.WriteString("\n")
	if b.formattedBody != "" {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit, ↑/↓ to scroll, pgup/pgdn for page scroll\n")
	} else {
		s.WriteString("Press 'esc' to quit, 'ctrl+c' to exit\n")
	}

	return s.String()
}

// ErrorMsg represents an error message.
type ErrorMsg struct {
	Err error
}

// SuccessMsg represents a success message.
type SuccessMsg struct {
	Message      string
	ResponseBody string
}

// wrapText wraps text to the specified width, breaking at word boundaries.
func wrapText(text string, width int) string {
	if len(text) <= width {
		return text
	}
	
	var result strings.Builder
	words := strings.Fields(text)
	currentLine := ""
	
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		if len(testLine) > width {
			if currentLine != "" {
				result.WriteString(currentLine)
				result.WriteString("\n")
				currentLine = word
			} else {
				// Word is longer than width, just add it
				result.WriteString(word)
				result.WriteString("\n")
				currentLine = ""
			}
		} else {
			currentLine = testLine
		}
	}
	
	if currentLine != "" {
		result.WriteString(currentLine)
	}
	
	return result.String()
}

// updateFormattedBody formats the response body and updates the viewport content.
func (b *BuilderView) updateFormattedBody() {
	if b.responseBody == "" {
		b.formattedBody = ""
		b.viewport.SetContent("")
		return
	}
	
	// Calculate available width for content
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	// Format the response
	formatted := formatResponse(b.responseBody, contentWidth)
	b.formattedBody = formatted
	
	// Update viewport content
	b.viewport.SetContent(formatted)
	b.viewport.GotoTop() // Start at the top
}

// updateViewportSize updates the viewport dimensions based on available space.
func (b *BuilderView) updateViewportSize() {
	if b.responseBody == "" {
		return
	}
	
	// Calculate available width and height
	contentWidth := b.width - 6 // Account for border and padding
	if contentWidth < 20 {
		contentWidth = 20 // Minimum width
	}
	
	availableHeight := b.height - 15 // Reserve space for other UI elements
	if availableHeight < 5 {
		availableHeight = 5 // Minimum height
	}
	
	// Update viewport dimensions
	b.viewport.Width = contentWidth
	b.viewport.Height = availableHeight
	
	// If content is already set, ensure it's properly sized
	if b.formattedBody != "" {
		b.viewport.SetContent(b.formattedBody)
	}
}

// formatResponse formats the response body with syntax highlighting for JSON.
func formatResponse(body string, width int) string {
	// Try to parse as JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(body), &jsonData); err == nil {
		// It's valid JSON, format it with syntax highlighting
		return formatJSON(body, width)
	}

	// Not JSON, return as-is with word wrapping
	return wrapText(body, width)
}

// formatJSON formats JSON with syntax highlighting using lipgloss.
func formatJSON(jsonStr string, width int) string {
	// First, pretty-print the JSON
	var jsonData interface{}
	if err := json.Unmarshal([]byte(jsonStr), &jsonData); err != nil {
		return jsonStr // Return original if parsing fails
	}

	prettyJSON, err := json.MarshalIndent(jsonData, "", "  ")
	if err != nil {
		return jsonStr // Return original if formatting fails
	}

	// Now apply syntax highlighting
	lines := strings.Split(string(prettyJSON), "\n")
	var formattedLines []string

	for _, line := range lines {
		formattedLine := highlightJSONLine(line)
		formattedLines = append(formattedLines, formattedLine)
	}

	return strings.Join(formattedLines, "\n")
}

// highlightJSONLine applies syntax highlighting to a single line of JSON.
func highlightJSONLine(line string) string {
	// This is a simple JSON highlighter that handles common cases
	// For a more robust solution, consider using a proper JSON tokenizer
	
	result := ""
	i := 0
	
	for i < len(line) {
		char := line[i]
		
		// Skip whitespace
		if char == ' ' || char == '\t' {
			result += string(char)
			i++
			continue
		}
		
		// Handle string literals
		if char == '"' {
			end := i + 1
			escaped := false
			for end < len(line) {
				if line[end] == '\\' && !escaped {
					escaped = true
					end++
				} else if line[end] == '"' && !escaped {
					end++
					// Check if this is a key (followed by :)
					isKey := end < len(line) && line[end] == ':'
					str := line[i:end]
					if isKey {
						result += jsonKeyStyle.Render(str)
					} else {
						result += jsonStringStyle.Render(str)
					}
					i = end
					break
				} else {
					escaped = false
					end++
				}
			}
			if end >= len(line) {
				// Unterminated string, just add it
				result += jsonStringStyle.Render(line[i:])
				break
			}
			continue
		}
		
		// Handle numbers
		if (char >= '0' && char <= '9') || char == '-' {
			start := i
			for i < len(line) && ((line[i] >= '0' && line[i] <= '9') || 
				line[i] == '.' || line[i] == 'e' || line[i] == 'E' || 
				line[i] == '+' || line[i] == '-' || line[i] == 'i' || 
				line[i] == 'n' || line[i] == 'f') {
				i++
			}
			result += jsonNumberStyle.Render(line[start:i])
			continue
		}
		
		// Handle boolean and null
		if strings.HasPrefix(line[i:], "true") {
			result += jsonBoolStyle.Render("true")
			i += 4
			continue
		}
		if strings.HasPrefix(line[i:], "false") {
			result += jsonBoolStyle.Render("false")
			i += 5
			continue
		}
		if strings.HasPrefix(line[i:], "null") {
			result += jsonNullStyle.Render("null")
			i += 4
			continue
		}
		
		// Handle punctuation
		if char == '{' || char == '}' || char == '[' || char == ']' || 
		   char == ',' || char == ':' {
			result += jsonPunctStyle.Render(string(char))
			i++
			continue
		}
		
		// Default: just add the character
		result += string(char)
		i++
	}
	
	return result
}

----
internal/types/command.go
// Package types provides shared types and enums used across the req package.
package types

import "time"

// Verb represents the action verb in a req command.
type Verb string

const (
	VerbRead         Verb = "read"
	VerbSave         Verb = "save"
	VerbSend         Verb = "send"
	VerbUpload       Verb = "upload"
	VerbWatch        Verb = "watch"
	VerbInspect      Verb = "inspect"
	VerbAuthenticate Verb = "authenticate"
	VerbSession      Verb = "session"
)

// Command represents a parsed req command AST.
type Command struct {
	Verb    Verb
	Target  Target
	Clauses []Clause
	// For session verb, subcommand (show, clear, use)
	SessionSubcommand string
}

// Target represents the URL or resource being acted upon.
type Target struct {
	URL string
}

// Clause represents a modifier clause in the command.
// This is a sum type that will be expanded as we add more clause types.
type Clause interface {
	clause()
}

// WithClause represents a "with=" clause for request body.
type WithClause struct {
	Value    string // inline value, file path, or "-" for stdin
	Type     string // json, form, etc. (inferred if empty)
	IsFile   bool   // true if value starts with @
	IsStdin  bool   // true if value is @-
}

func (WithClause) clause() {}

// HeadersClause represents a "headers=" clause.
type HeadersClause struct {
	Headers map[string]string
}

func (HeadersClause) clause() {}

// ParamsClause represents a "params=" clause for query parameters.
type ParamsClause struct {
	Params map[string]string
}

func (ParamsClause) clause() {}

// AsClause represents an "as=" clause for output format.
type AsClause struct {
	Format string // json, csv, text, raw
}

func (AsClause) clause() {}

// ToClause represents a "to=" clause for destination.
type ToClause struct {
	Destination string
}

func (ToClause) clause() {}

// UsingClause represents a "using=" clause for HTTP method override.
type UsingClause struct {
	Method string // GET, POST, PUT, PATCH, DELETE, etc.
}

func (UsingClause) clause() {}

// RetryClause represents a "retry=" clause.
type RetryClause struct {
	Count int
}

func (RetryClause) clause() {}

// BackoffClause represents a "backoff=" clause.
type BackoffClause struct {
	Min time.Duration
	Max time.Duration
}

func (BackoffClause) clause() {}

// TimeoutClause represents a "timeout=" clause.
type TimeoutClause struct {
	Duration time.Duration
}

func (TimeoutClause) clause() {}

// ProxyClause represents a "proxy=" clause.
type ProxyClause struct {
	URL string
}

func (ProxyClause) clause() {}

// PickClause represents a "pick=" clause for JSON path selection.
type PickClause struct {
	Path string // JSONPath expression
}

func (PickClause) clause() {}

// EveryClause represents an "every=" clause for polling.
type EveryClause struct {
	Interval time.Duration
}

func (EveryClause) clause() {}

// UntilClause represents an "until=" clause for conditional polling.
type UntilClause struct {
	Predicate string
}

func (UntilClause) clause() {}

// FieldClause represents a "field=" clause for multipart uploads.
type FieldClause struct {
	Name  string
	Value string
}

func (FieldClause) clause() {}

// VerboseClause represents the "verbose" flag.
type VerboseClause struct{}

func (VerboseClause) clause() {}

// ResumeClause represents the "resume" flag for resumable downloads.
type ResumeClause struct{}

func (ResumeClause) clause() {}

// IncludeClause represents an "include=" clause for headers, params, and cookies.
type IncludeClause struct {
	Items []IncludeItem
}

func (IncludeClause) clause() {}

// IncludeItem represents a single item in an include clause.
type IncludeItem struct {
	Type  string // "header", "param", "cookie", "basic"
	Name  string // header name, param key, or cookie key (empty for basic)
	Value string // header value, param value, cookie value, or username:password for basic
}

// AttachClause represents an "attach=" clause for multipart form data.
type AttachClause struct {
	Parts    []AttachPart
	Boundary string // optional explicit boundary
}

func (AttachClause) clause() {}

// AttachPart represents a single part in an attach clause.
type AttachPart struct {
	Name     string // required
	FilePath string // file=@path (mutually exclusive with Value)
	Value    string // value=... (mutually exclusive with FilePath)
	Filename string // optional filename
	Type     string // optional Content-Type
}

// ExpectClause represents an "expect=" clause for response assertions.
type ExpectClause struct {
	Checks []ExpectCheck
}

func (ExpectClause) clause() {}

// ExpectCheck represents a single assertion check.
type ExpectCheck struct {
	Type  string // "status", "header", "contains", "jsonpath", "matches"
	Name  string // for header checks, the header name
	Value string // the value to check against
	Path  string // for jsonpath, the JSONPath expression
	Regex string // for matches, the regex pattern
}

// FollowClause represents a "follow=" clause for redirect policy.
type FollowClause struct {
	Policy string // "smart" or empty for default
}

func (FollowClause) clause() {}

// UnderClause represents an "under=" clause for timeout or size limit.
type UnderClause struct {
	Duration time.Duration // if it's a duration
	Size     int64         // if it's a size (in bytes)
	IsSize   bool          // true if it's a size limit, false if duration
}

func (UnderClause) clause() {}

// ViaClause represents a "via=" clause for proxy URL.
type ViaClause struct {
	URL string
}

func (ViaClause) clause() {}

// InsecureClause represents an "insecure=" clause (updated to support true/false).
type InsecureClause struct {
	Value bool // true or false
}

func (InsecureClause) clause() {}



----
tests/fixtures/grammar_snapshot.json
{
  "verbs": [
    "read",
    "save",
    "send",
    "upload",
    "watch",
    "inspect",
    "authenticate",
    "session"
  ],
  "clauses": [
    {
      "name": "using=",
      "description": "HTTP method override",
      "repeatable": false
    },
    {
      "name": "include=",
      "description": "Add headers, params, cookies",
      "repeatable": true
    },
    {
      "name": "with=",
      "description": "Request body",
      "repeatable": false
    },
    {
      "name": "expect=",
      "description": "Assertions on response",
      "repeatable": false
    },
    {
      "name": "as=",
      "description": "Output format for stdout",
      "repeatable": false
    },
    {
      "name": "to=",
      "description": "Destination path",
      "repeatable": false
    },
    {
      "name": "retry=",
      "description": "Retry attempts for transient errors",
      "repeatable": false
    },
    {
      "name": "under=",
      "description": "Timeout or size limit",
      "repeatable": false
    },
    {
      "name": "via=",
      "description": "Proxy URL",
      "repeatable": false
    },
    {
      "name": "attach=",
      "description": "Multipart parts for upload or send",
      "repeatable": true
    },
    {
      "name": "follow=",
      "description": "Redirect policy for write verbs",
      "repeatable": false
    },
    {
      "name": "insecure=",
      "description": "Disable TLS verification for this request",
      "repeatable": false
    }
  ]
}


----
tests/grammar_drift_test.go
package tests

import (
	"encoding/json"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/grammar"
)

// TestGrammarDrift ensures the binary help output matches the grammar snapshot.
func TestGrammarDrift(t *testing.T) {
	// Get expected snapshot from grammar package
	expectedJSON, err := grammar.GetSnapshotJSON()
	if err != nil {
		t.Fatalf("Failed to generate expected snapshot: %v", err)
	}

	var expected grammar.Snapshot
	if err := json.Unmarshal(expectedJSON, &expected); err != nil {
		t.Fatalf("Failed to unmarshal expected snapshot: %v", err)
	}

	// Load actual snapshot from file
	snapshotPath := filepath.Join("fixtures", "grammar_snapshot.json")
	actualJSON, err := os.ReadFile(snapshotPath)
	if err != nil {
		t.Fatalf("Failed to read snapshot file: %v", err)
	}

	var actual grammar.Snapshot
	if err := json.Unmarshal(actualJSON, &actual); err != nil {
		t.Fatalf("Failed to unmarshal actual snapshot: %v", err)
	}

	// Compare verbs
	if len(expected.Verbs) != len(actual.Verbs) {
		t.Errorf("Verb count mismatch: expected %d, got %d", len(expected.Verbs), len(actual.Verbs))
	}

	expectedVerbs := make(map[string]bool)
	for _, v := range expected.Verbs {
		expectedVerbs[v] = true
	}
	for _, v := range actual.Verbs {
		if !expectedVerbs[v] {
			t.Errorf("Unexpected verb in snapshot: %s", v)
		}
	}
	for _, v := range expected.Verbs {
		found := false
		for _, av := range actual.Verbs {
			if av == v {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Missing verb in snapshot: %s", v)
		}
	}

	// Compare clauses
	if len(expected.Clauses) != len(actual.Clauses) {
		t.Errorf("Clause count mismatch: expected %d, got %d", len(expected.Clauses), len(actual.Clauses))
	}

	expectedClauses := make(map[string]grammar.ClauseSnapshot)
	for _, c := range expected.Clauses {
		expectedClauses[c.Name] = c
	}

	for _, ac := range actual.Clauses {
		ec, ok := expectedClauses[ac.Name]
		if !ok {
			t.Errorf("Unexpected clause in snapshot: %s", ac.Name)
			continue
		}
		if ec.Description != ac.Description {
			t.Errorf("Clause %s description mismatch: expected %q, got %q", ac.Name, ec.Description, ac.Description)
		}
		if ec.Repeatable != ac.Repeatable {
			t.Errorf("Clause %s repeatable mismatch: expected %v, got %v", ac.Name, ec.Repeatable, ac.Repeatable)
		}
	}

	for _, ec := range expected.Clauses {
		found := false
		for _, ac := range actual.Clauses {
			if ac.Name == ec.Name {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Missing clause in snapshot: %s", ec.Name)
		}
	}
}

// TestBinaryHelpDrift ensures the binary help output matches the grammar.
func TestBinaryHelpDrift(t *testing.T) {
	// Build the binary
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	// Run req help
	cmd := exec.Command(binaryPath, "help")
	output, err := cmd.Output()
	if err != nil {
		t.Fatalf("Failed to run req help: %v", err)
	}

	helpText := string(output)

	// Get grammar
	g := grammar.GetGrammar()

	// Check that all verbs appear in help
	for _, verb := range g.Verbs {
		if !strings.Contains(helpText, verb.Name) {
			t.Errorf("Verb %s not found in help output", verb.Name)
		}
		if !strings.Contains(helpText, verb.Description) {
			t.Errorf("Verb %s description not found in help output", verb.Name)
		}
	}

	// Check that all clauses appear in help
	for _, clause := range g.Clauses {
		if !strings.Contains(helpText, clause.Name) {
			t.Errorf("Clause %s not found in help output", clause.Name)
		}
		if !strings.Contains(helpText, clause.Description) {
			t.Errorf("Clause %s description not found in help output", clause.Name)
		}
	}
}


----
tests/parser_test.go
package tests

import (
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/types"
)

func TestParseBasicRead(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    *types.Command
		wantErr bool
	}{
		{
			name:  "simple read",
			input: "read https://api.example.com/users",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
			},
			wantErr: false,
		},
		{
			name:  "read with as clause",
			input: "read https://api.example.com/users as=json",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.AsClause{Format: "json"},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with multiple clauses",
			input: "read https://api.example.com/users as=json verbose",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.AsClause{Format: "json"},
					types.VerboseClause{},
				},
			},
			wantErr: false,
		},
		{
			name:  "send with json body",
			input: "send https://api.example.com/users with='{\"name\":\"Ada\"}'",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.WithClause{Type: "json", Value: "'{\"name\":\"Ada\"}'"},
				},
			},
			wantErr: false,
		},
		{
			name:  "save with destination",
			input: "save https://example.com/file.zip to=file.zip",
			want: &types.Command{
				Verb:   types.VerbSave,
				Target: types.Target{URL: "https://example.com/file.zip"},
				Clauses: []types.Clause{
					types.ToClause{Destination: "file.zip"},
				},
			},
			wantErr: false,
		},
		{
			name:    "invalid verb",
			input:   "invalid https://example.com",
			wantErr: true,
		},
		{
			name:    "missing target",
			input:   "read",
			wantErr: true,
		},
		{
			name:  "read with insecure clause",
			input: "read https://api.example.com/users insecure=true",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.InsecureClause{Value: true},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with timeout",
			input: "read https://api.example.com/users under=5s",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UnderClause{Duration: 5000000000, IsSize: false}, // 5s in nanoseconds
				},
			},
			wantErr: false,
		},
		{
			name:  "send with using=PUT",
			input: "send https://api.example.com/users using=PUT",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "PUT"},
				},
			},
			wantErr: false,
		},
		{
			name:  "send with using=patch (normalize to uppercase)",
			input: "send https://api.example.com/users using=patch",
			want: &types.Command{
				Verb:   types.VerbSend,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "PATCH"},
				},
			},
			wantErr: false,
		},
		{
			name:  "read with using=HEAD",
			input: "read https://api.example.com/users using=HEAD",
			want: &types.Command{
				Verb:   types.VerbRead,
				Target: types.Target{URL: "https://api.example.com/users"},
				Clauses: []types.Clause{
					types.UsingClause{Method: "HEAD"},
				},
			},
			wantErr: false,
		},
		{
			name:    "using= with invalid method",
			input:   "read https://api.example.com/users using=INVALID",
			wantErr: true,
		},
		{
			name:    "old method= syntax should error",
			input:   "read https://api.example.com/users method=PUT",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parser.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if got.Verb != tt.want.Verb {
				t.Errorf("Parse() Verb = %v, want %v", got.Verb, tt.want.Verb)
			}
			if got.Target.URL != tt.want.Target.URL {
				t.Errorf("Parse() Target.URL = %v, want %v", got.Target.URL, tt.want.Target.URL)
			}
			if len(got.Clauses) != len(tt.want.Clauses) {
				t.Errorf("Parse() Clauses length = %v, want %v", len(got.Clauses), len(tt.want.Clauses))
				return
			}
			// Check UsingClause if present
			for i, clause := range got.Clauses {
				if usingClause, ok := clause.(types.UsingClause); ok {
					if i >= len(tt.want.Clauses) {
						t.Errorf("Parse() UsingClause found but not expected")
						continue
					}
					if wantUsingClause, ok := tt.want.Clauses[i].(types.UsingClause); ok {
						if usingClause.Method != wantUsingClause.Method {
							t.Errorf("Parse() UsingClause.Method = %v, want %v", usingClause.Method, wantUsingClause.Method)
						}
					}
				}
			}
		})
	}
}

func TestParseErrorSuggestions(t *testing.T) {
	tests := []struct {
		name       string
		input      string
		wantSuggestion string
	}{
		{
			name: "typo in verb",
			input: "reed https://api.example.com/users",
			wantSuggestion: "read",
		},
		{
			name: "typo in clause",
			input: "read https://api.example.com/users ass=json",
			wantSuggestion: "as",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := parser.Parse(tt.input)
			if err == nil {
				t.Errorf("Parse() expected error but got none")
				return
			}
			parseErr, ok := err.(*parser.ParseError)
			if !ok {
				t.Errorf("Parse() error is not a ParseError: %T", err)
				return
			}
			if parseErr.Suggest != tt.wantSuggestion {
				t.Errorf("Parse() Suggest = %v, want %v", parseErr.Suggest, tt.wantSuggestion)
			}
		})
	}
}

func TestParseQuotedStringsWithSemicolons(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		wantErr bool
		check   func(*testing.T, *types.Command)
	}{
		{
			name:    "include with semicolon in header value",
			input:   `read https://api.example.com/users include="header: Content-Type: application/json; charset=UTF-8"`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				if len(cmd.Clauses) != 1 {
					t.Fatalf("expected 1 clause, got %d", len(cmd.Clauses))
				}
				includeClause, ok := cmd.Clauses[0].(types.IncludeClause)
				if !ok {
					t.Fatalf("expected IncludeClause, got %T", cmd.Clauses[0])
				}
				if len(includeClause.Items) != 1 {
					t.Fatalf("expected 1 include item, got %d", len(includeClause.Items))
				}
				item := includeClause.Items[0]
				if item.Type != "header" {
					t.Errorf("expected header type, got %s", item.Type)
				}
				if item.Name != "Content-Type" {
					t.Errorf("expected header name Content-Type, got %s", item.Name)
				}
				if item.Value != "application/json; charset=UTF-8" {
					t.Errorf("expected header value 'application/json; charset=UTF-8', got %s", item.Value)
				}
			},
		},
		{
			name:    "expect with semicolon in header value",
			input:   `read https://api.example.com/users expect="status:200, header:Content-Type=application/json; charset=utf-8"`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				if len(cmd.Clauses) != 1 {
					t.Fatalf("expected 1 clause, got %d", len(cmd.Clauses))
				}
				expectClause, ok := cmd.Clauses[0].(types.ExpectClause)
				if !ok {
					t.Fatalf("expected ExpectClause, got %T", cmd.Clauses[0])
				}
				if len(expectClause.Checks) != 2 {
					t.Fatalf("expected 2 expect checks, got %d", len(expectClause.Checks))
				}
				headerCheck := expectClause.Checks[1]
				if headerCheck.Type != "header" {
					t.Errorf("expected header check type, got %s", headerCheck.Type)
				}
				if headerCheck.Name != "Content-Type" {
					t.Errorf("expected header name Content-Type, got %s", headerCheck.Name)
				}
				if headerCheck.Value != "application/json; charset=utf-8" {
					t.Errorf("expected header value 'application/json; charset=utf-8', got %s", headerCheck.Value)
				}
			},
		},
		{
			name:    "multiple include items with semicolons",
			input:   `read https://api.example.com/users include="header: Accept: application/json; q=0.9; param: q=test"`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				includeClause := cmd.Clauses[0].(types.IncludeClause)
				if len(includeClause.Items) != 2 {
					t.Fatalf("expected 2 include items, got %d", len(includeClause.Items))
				}
				headerItem := includeClause.Items[0]
				if headerItem.Value != "application/json; q=0.9" {
					t.Errorf("expected header value 'application/json; q=0.9', got %s", headerItem.Value)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd, err := parser.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && tt.check != nil {
				tt.check(t, cmd)
			}
		})
	}
}

func TestParseBasicAuth(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		wantErr bool
		check   func(*testing.T, *types.Command)
	}{
		{
			name:    "basic auth with username:password",
			input:   `read https://httpbin.org/basic-auth/user/passwd include='basic: user:passwd'`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				if len(cmd.Clauses) != 1 {
					t.Fatalf("expected 1 clause, got %d", len(cmd.Clauses))
				}
				includeClause, ok := cmd.Clauses[0].(types.IncludeClause)
				if !ok {
					t.Fatalf("expected IncludeClause, got %T", cmd.Clauses[0])
				}
				if len(includeClause.Items) != 1 {
					t.Fatalf("expected 1 include item, got %d", len(includeClause.Items))
				}
				item := includeClause.Items[0]
				if item.Type != "basic" {
					t.Errorf("expected basic type, got %s", item.Type)
				}
				if item.Value != "user:passwd" {
					t.Errorf("expected value 'user:passwd', got %s", item.Value)
				}
			},
		},
		{
			name:    "basic auth with quoted credentials",
			input:   `read https://httpbin.org/basic-auth/user/passwd include="basic: user:passwd"`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				includeClause := cmd.Clauses[0].(types.IncludeClause)
				item := includeClause.Items[0]
				if item.Type != "basic" {
					t.Errorf("expected basic type, got %s", item.Type)
				}
				if item.Value != "user:passwd" {
					t.Errorf("expected value 'user:passwd', got %s", item.Value)
				}
			},
		},
		{
			name:    "basic auth combined with other include items",
			input:   `read https://httpbin.org/basic-auth/user/passwd include='basic: user:passwd; header: Accept: application/json'`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				includeClause := cmd.Clauses[0].(types.IncludeClause)
				if len(includeClause.Items) != 2 {
					t.Fatalf("expected 2 include items, got %d", len(includeClause.Items))
				}
				basicItem := includeClause.Items[0]
				if basicItem.Type != "basic" {
					t.Errorf("expected first item to be basic, got %s", basicItem.Type)
				}
				headerItem := includeClause.Items[1]
				if headerItem.Type != "header" {
					t.Errorf("expected second item to be header, got %s", headerItem.Type)
				}
			},
		},
		{
			name:    "basic auth missing colon",
			input:   `read https://httpbin.org/basic-auth/user/passwd include='basic: userpass'`,
			wantErr: true,
		},
		{
			name:    "basic auth with empty username",
			input:   `read https://httpbin.org/basic-auth/user/passwd include='basic: :passwd'`,
			wantErr: false,
			check: func(t *testing.T, cmd *types.Command) {
				includeClause := cmd.Clauses[0].(types.IncludeClause)
				item := includeClause.Items[0]
				if item.Value != ":passwd" {
					t.Errorf("expected value ':passwd', got %s", item.Value)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd, err := parser.Parse(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("Parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err == nil && tt.check != nil {
				tt.check(t, cmd)
			}
		})
	}
}


----
tests/planner_test.go
package tests

import (
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/types"
)

func TestPlanRead(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.AsClause{Format: "json"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Method != http.MethodGet {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodGet)
	}
	if plan.URL != "https://api.example.com/users" {
		t.Errorf("Plan() URL = %v, want %v", plan.URL, "https://api.example.com/users")
	}
	if plan.Output == nil {
		t.Errorf("Plan() Output is nil")
	} else if plan.Output.Format != "json" {
		t.Errorf("Plan() Output.Format = %v, want json", plan.Output.Format)
	}
}

func TestPlanSend(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.WithClause{Type: "json", Value: "{\"name\":\"Ada\"}"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Send with with= should default to POST
	if plan.Method != http.MethodPost {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodPost)
	}
	if plan.Body == nil {
		t.Errorf("Plan() Body is nil")
	} else if plan.Body.Type != "json" {
		t.Errorf("Plan() Body.Type = %v, want json", plan.Body.Type)
	}
}

func TestPlanSave(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSave,
		Target: types.Target{URL: "https://example.com/file.zip"},
		Clauses: []types.Clause{
			types.ToClause{Destination: "file.zip"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Method != http.MethodGet {
		t.Errorf("Plan() Method = %v, want %v", plan.Method, http.MethodGet)
	}
	if plan.Output == nil {
		t.Errorf("Plan() Output is nil")
	} else if plan.Output.Destination != "file.zip" {
		t.Errorf("Plan() Output.Destination = %v, want file.zip", plan.Output.Destination)
	}
}

func TestPlanWithTimeout(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.TimeoutClause{Duration: 5 * time.Second},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Timeout == nil {
		t.Errorf("Plan() Timeout is nil")
	} else if *plan.Timeout != 5*time.Second {
		t.Errorf("Plan() Timeout = %v, want %v", *plan.Timeout, 5*time.Second)
	}
}

func TestPlanWithRetry(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.RetryClause{Count: 3},
			types.BackoffClause{
				Min: 200 * time.Millisecond,
				Max: 5 * time.Second,
			},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	if plan.Retry == nil {
		t.Errorf("Plan() Retry is nil")
	} else {
		if plan.Retry.Count != 3 {
			t.Errorf("Plan() Retry.Count = %v, want 3", plan.Retry.Count)
		}
		if plan.Retry.Backoff.Min != 200*time.Millisecond {
			t.Errorf("Plan() Retry.Backoff.Min = %v, want %v", plan.Retry.Backoff.Min, 200*time.Millisecond)
		}
		if plan.Retry.Backoff.Max != 5*time.Second {
			t.Errorf("Plan() Retry.Backoff.Max = %v, want %v", plan.Retry.Backoff.Max, 5*time.Second)
		}
	}
}

func TestPlanWithUsingOverride(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "PUT"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Method override should take precedence
	if plan.Method != "PUT" {
		t.Errorf("Plan() Method = %v, want PUT", plan.Method)
	}
}

func TestPlanWithUsingIncompatible(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbRead,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "POST"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err == nil {
		t.Fatalf("Plan() expected error for incompatible verb-method combination")
	}

	// Should have error message
	if plan != nil {
		t.Errorf("Plan() should return nil on error")
	}
	
	// Check error message
	if !strings.Contains(err.Error(), "incompatible") {
		t.Errorf("Plan() error message should mention incompatibility, got: %v", err)
	}
}

func TestPlanWithUsingDeleteForSend(t *testing.T) {
	cmd := &types.Command{
		Verb:   types.VerbSend,
		Target: types.Target{URL: "https://api.example.com/users"},
		Clauses: []types.Clause{
			types.UsingClause{Method: "DELETE"},
		},
	}

	plan, err := planner.Plan(cmd)
	if err == nil {
		t.Fatalf("Plan() expected error for incompatible verb-method combination")
	}

	if plan != nil {
		t.Errorf("Plan() should return nil on error")
	}
}


----
tests/redirect_compression_test.go
package tests

import (
	"bytes"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestRedirectTrace tests that redirect traces appear in stderr.
func TestRedirectTrace(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Test redirect with read verb (should follow by default)
	cmdStr := "read " + ts.URL() + "/redirect/301"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	err = executor.Execute(plan)
	os.Stderr = oldStderr
	w.Close()

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read stderr
	var buf bytes.Buffer
	buf.ReadFrom(r)
	stderr := buf.String()

	// Check for redirect trace
	if !strings.Contains(stderr, "→") {
		t.Errorf("Expected redirect trace in stderr, got: %s", stderr)
	}
	if !strings.Contains(stderr, "301") {
		t.Errorf("Expected status code 301 in redirect trace, got: %s", stderr)
	}
}

// TestCompressionTrace tests that decompression notes appear in stderr.
func TestCompressionTrace(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/gzip"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	err = executor.Execute(plan)
	os.Stderr = oldStderr
	w.Close()

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read stderr
	var buf bytes.Buffer
	buf.ReadFrom(r)
	stderr := buf.String()

	// Check for decompression note
	if !strings.Contains(stderr, "Decompressed") {
		t.Errorf("Expected decompression note in stderr, got: %s", stderr)
	}
}

// TestRedirectTraceGolden tests redirect trace output against golden file.
func TestRedirectTraceGolden(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/redirect/307"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	stderr := stderrBuf.String()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "redirect_trace.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		// Create golden file if it doesn't exist
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, []byte(stderr), 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare (normalize line endings)
	actualNorm := strings.ReplaceAll(stderr, "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Redirect trace mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestCompressionTraceGolden tests compression trace output against golden file.
func TestCompressionTraceGolden(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	cmdStr := "read " + ts.URL() + "/gzip"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	stderr := stderrBuf.String()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "compression_trace.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		// Create golden file if it doesn't exist
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, []byte(stderr), 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare (normalize line endings)
	actualNorm := strings.ReplaceAll(stderr, "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Compression trace mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestBinaryRedirectTrace tests redirect trace using the built binary.
func TestBinaryRedirectTrace(t *testing.T) {
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	ts := NewTestServer()
	defer ts.Close()

	// Run req with redirect
	cmd := exec.Command(binaryPath, "read", ts.URL()+"/redirect/302")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Run() // Don't care about exit code, just want stderr

	output := stderr.String()
	if !strings.Contains(output, "→") {
		t.Errorf("Expected redirect trace in binary output, got: %s", output)
	}
}

// TestBinaryCompressionTrace tests compression trace using the built binary.
func TestBinaryCompressionTrace(t *testing.T) {
	binaryPath := filepath.Join("..", "bin", "req")
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		// Try to build it
		cmd := exec.Command("go", "build", "-o", binaryPath, "../cmd/req")
		if err := cmd.Run(); err != nil {
			t.Skipf("Could not build binary: %v", err)
			return
		}
	}

	ts := NewTestServer()
	defer ts.Close()

	// Run req with gzip endpoint
	cmd := exec.Command(binaryPath, "read", ts.URL()+"/gzip")
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	cmd.Run() // Don't care about exit code, just want stderr

	output := stderr.String()
	if !strings.Contains(output, "Decompressed") {
		t.Errorf("Expected decompression note in binary output, got: %s", output)
	}
}


----
tests/runtime_test.go
package tests

import (
	"encoding/json"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestRuntimeReadDogFacts tests reading from a real API.
// Note: This test requires internet connectivity.
func TestRuntimeReadDogFacts(t *testing.T) {
	// Use httpbin.org as a reliable test API
	// If dog-facts-api comes back online, we can switch back
	cmdStr := "read https://httpbin.org/json"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read captured output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	// Verify output is JSON
	var data map[string]interface{}
	if err := json.Unmarshal(output, &data); err != nil {
		t.Fatalf("Output is not valid JSON: %v\nOutput: %s", err, string(output))
	}

	// Verify we got some data
	if len(data) == 0 {
		t.Errorf("Expected non-empty JSON response, got empty map")
	}

	t.Logf("Successfully received JSON response: %v", data)
}

// TestRuntimeReadMultipleDogFacts tests reading from a real API with query params.
// Note: This test requires internet connectivity.
func TestRuntimeReadMultipleDogFacts(t *testing.T) {
	// Use httpbin.org with query params
	cmdStr := "read https://httpbin.org/get?foo=bar&baz=qux"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read captured output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	// Verify output is JSON
	var data map[string]interface{}
	if err := json.Unmarshal(output, &data); err != nil {
		t.Fatalf("Output is not valid JSON: %v\nOutput: %s", err, string(output))
	}

	// Verify we got data with query params
	if args, ok := data["args"].(map[string]interface{}); ok {
		if args["foo"] != "bar" || args["baz"] != "qux" {
			t.Errorf("Expected query params foo=bar&baz=qux, got: %v", args)
		}
	} else {
		t.Errorf("Expected 'args' field in response, got: %v", data)
	}

	t.Logf("Successfully received JSON response with query params")
}

// TestRuntimeSaveDogFact tests saving API response to a file.
// Note: This test requires internet connectivity.
func TestRuntimeSaveDogFact(t *testing.T) {
	// Create a temporary file
	tmpFile, err := os.CreateTemp("", "api-response-*.json")
	if err != nil {
		t.Fatalf("CreateTemp() error = %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	cmdStr := "read https://httpbin.org/json to=" + tmpFile.Name()
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and contains valid JSON
	fileContent, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("ReadFile() error = %v", err)
	}

	var data map[string]interface{}
	if err := json.Unmarshal(fileContent, &data); err != nil {
		t.Fatalf("File content is not valid JSON: %v\nContent: %s", err, string(fileContent))
	}

	if len(data) == 0 {
		t.Errorf("Expected non-empty JSON in file, got empty map")
	}

	t.Logf("Successfully saved API response to file: %s", tmpFile.Name())
}

// TestRuntimeSaveVideoFile tests downloading a video file using the save command.
// Note: This test requires internet connectivity.
func TestRuntimeSaveVideoFile(t *testing.T) {
	// Create a temporary file
	tmpFile, err := os.CreateTemp("", "video-*.mp4")
	if err != nil {
		t.Fatalf("CreateTemp() error = %v", err)
	}
	defer os.Remove(tmpFile.Name())
	tmpFile.Close()

	// Use the provided test video URL
	cmdStr := "save http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4 to=" + tmpFile.Name()
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and has content
	fileInfo, err := os.Stat(tmpFile.Name())
	if err != nil {
		t.Fatalf("Stat() error = %v", err)
	}

	if fileInfo.Size() == 0 {
		t.Error("Expected non-empty file, got empty file")
	}

	// Video files should be reasonably large (at least a few KB)
	if fileInfo.Size() < 1024 {
		t.Errorf("Expected file size >= 1KB, got %d bytes", fileInfo.Size())
	}

	// Verify file content is binary (not text)
	fileContent, err := os.ReadFile(tmpFile.Name())
	if err != nil {
		t.Fatalf("ReadFile() error = %v", err)
	}

	// Check for MP4 file signature (ftyp box at the beginning)
	// MP4 files typically start with some metadata, but we can check for non-text content
	if len(fileContent) == 0 {
		t.Error("Expected non-empty file content")
	}

	// MP4 files typically start with specific bytes or contain binary data
	// For a simple test, verify it's not plain text by checking for null bytes
	// or non-printable characters in the first few bytes
	hasBinaryContent := false
	for i := 0; i < len(fileContent) && i < 100; i++ {
		if fileContent[i] == 0 || (fileContent[i] < 32 && fileContent[i] != 9 && fileContent[i] != 10 && fileContent[i] != 13) {
			hasBinaryContent = true
			break
		}
	}

	if !hasBinaryContent && len(fileContent) > 100 {
		// If first 100 bytes are all printable, it's likely not a binary video file
		t.Logf("Warning: File content appears to be text, expected binary video file")
	}

	t.Logf("Successfully downloaded video file: %s (size: %d bytes)", tmpFile.Name(), fileInfo.Size())
}

// TestRuntimeReadWithTimeout tests request with timeout.
// Note: This test requires internet connectivity.
func TestRuntimeReadWithTimeout(t *testing.T) {
	cmdStr := "read https://httpbin.org/json under=10s"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify we got output
	output, err := io.ReadAll(r)
	if err != nil {
		t.Fatalf("ReadAll() error = %v", err)
	}

	if len(output) == 0 {
		t.Error("Expected non-empty output")
	}

	t.Logf("Successfully received response with timeout")
}

// TestRuntimeHTTPError tests handling of HTTP errors.
// Note: This test requires internet connectivity.
func TestRuntimeHTTPError(t *testing.T) {
	// Use a non-existent endpoint to trigger 404
	cmdStr := "read https://httpbin.org/status/404"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	
	// Should return an error for non-2xx status
	if err == nil {
		t.Error("Expected error for non-existent endpoint, got nil")
	}

	// Verify error message contains status code
	if !strings.Contains(err.Error(), "404") {
		t.Errorf("Expected error to contain '404', got: %v", err)
	}

	t.Logf("Successfully handled HTTP error: %v", err)
}

// TestRuntimeInvalidURL tests handling of invalid URLs.
func TestRuntimeInvalidURL(t *testing.T) {
	cmdStr := "read https://this-domain-does-not-exist-12345.example.com/nonexistent"
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	
	// Should return an error for invalid domain
	if err == nil {
		t.Error("Expected error for invalid domain, got nil")
	}

	t.Logf("Successfully handled invalid URL error: %v", err)
}

// TestRuntimeBasicAuth tests Basic Auth with httpbin.org/basic-auth endpoint.
// Note: This test requires internet connectivity.
func TestRuntimeBasicAuth(t *testing.T) {
	cmdStr := `read https://httpbin.org/basic-auth/user/passwd include='basic: user:passwd' expect=status:200`
	
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	// Verify that Authorization header was set correctly
	authHeader, ok := plan.Headers["Authorization"]
	if !ok {
		t.Fatal("Authorization header not set in plan")
	}
	if !strings.HasPrefix(authHeader, "Basic ") {
		t.Errorf("Authorization header should start with 'Basic ', got: %s", authHeader)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	err = executor.Execute(plan)
	
	// Close write end and restore stdout
	w.Close()
	os.Stdout = oldStdout

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Read output
	output, _ := io.ReadAll(r)
	
	// Verify we got a successful response
	var result map[string]interface{}
	if err := json.Unmarshal(output, &result); err != nil {
		t.Fatalf("Failed to parse JSON response: %v", err)
	}
	
	authenticated, ok := result["authenticated"].(bool)
	if !ok || !authenticated {
		t.Errorf("Expected authenticated=true, got: %v", result["authenticated"])
	}
	
	user, ok := result["user"].(string)
	if !ok || user != "user" {
		t.Errorf("Expected user='user', got: %v", result["user"])
	}
}


----
tests/session_test.go
package tests

import (
	"bytes"
	"net/http"
	"os"
	"strings"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
	"github.com/adammpkins/req/internal/session"
)

// TestAuthenticateStoresSession tests that authenticate verb stores Set-Cookie and access_token.
func TestAuthenticateStoresSession(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Create a login endpoint that returns Set-Cookie and access_token
	ts.mux.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) {
		http.SetCookie(w, &http.Cookie{
			Name:  "session",
			Value: "test-session-123",
			Path:  "/",
		})
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte(`{"access_token": "test-token-456", "user": "test"}`))
	})

	// Clean up any existing session
	host, _ := session.ExtractHost(ts.URL())
	session.DeleteSession(host)

	cmdStr := "authenticate " + ts.URL() + "/login using=POST with='{\"user\":\"test\"}'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify session was saved
	sess, err := session.LoadSession(host)
	if err != nil {
		t.Fatalf("LoadSession() error = %v", err)
	}
	if sess == nil {
		t.Fatal("Session was not saved")
	}

	// Verify cookie was captured
	if sess.Cookies["session"] != "test-session-123" {
		t.Errorf("Expected cookie 'session'='test-session-123', got %q", sess.Cookies["session"])
	}

	// Verify access_token was captured
	if sess.Authorization != "Bearer test-token-456" {
		t.Errorf("Expected Authorization 'Bearer test-token-456', got %q", sess.Authorization)
	}

	// Verify stderr shows session saved
	stderr := stderrBuf.String()
	if !strings.Contains(stderr, "Session saved") {
		t.Errorf("Expected 'Session saved' in stderr, got: %s", stderr)
	}

	// Clean up
	session.DeleteSession(host)
}

// TestAutoApplySession tests that sessions are auto-applied for matching hosts.
func TestAutoApplySession(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "auto-applied-session"},
		Authorization: "Bearer auto-applied-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes headers
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		auth := r.Header.Get("Authorization")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"auth": "` + auth + `", "cookie": "` + cookie + `"}`))
	})

	cmdStr := "read " + ts.URL() + "/test"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify Authorization header was applied
	output := stdoutBuf.String()
	if !strings.Contains(output, "Bearer auto-applied-token") {
		t.Errorf("Expected Authorization header in request, output: %s", output)
	}

	// Verify Cookie was applied
	if !strings.Contains(output, "auto-applied-session") {
		t.Errorf("Expected session cookie in request, output: %s", output)
	}

	// Verify stderr shows session was used
	stderr := stderrBuf.String()
	if !strings.Contains(stderr, "Using session for") {
		t.Errorf("Expected 'Using session for' in stderr, got: %s", stderr)
	}
}

// TestSessionSuppression tests that explicit include of Authorization or Cookie suppresses session injection.
func TestSessionSuppression(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes headers
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		auth := r.Header.Get("Authorization")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"auth": "` + auth + `", "cookie": "` + cookie + `"}`))
	})

	// Test with explicit Authorization header
	cmdStr := "read " + ts.URL() + "/test include='header: Authorization: Bearer explicit-token'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify explicit Authorization was used, not stored session
	output := stdoutBuf.String()
	if !strings.Contains(output, "Bearer explicit-token") {
		t.Errorf("Expected explicit Authorization header, output: %s", output)
	}
	if strings.Contains(output, "Bearer stored-token") {
		t.Errorf("Stored session token should not be used when explicit header is set, output: %s", output)
	}

	// Verify stderr does NOT show "Using session for"
	stderr := stderrBuf.String()
	if strings.Contains(stderr, "Using session for") {
		t.Errorf("Session should not be auto-applied when explicit Authorization is set, stderr: %s", stderr)
	}
}

// TestSessionSuppressionWithCookie tests that explicit Cookie suppresses session injection.
func TestSessionSuppressionWithCookie(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Create an endpoint that echoes cookies
	ts.mux.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		cookie := ""
		if c, err := r.Cookie("session"); err == nil {
			cookie = c.Value
		}
		w.Write([]byte(`{"cookie": "` + cookie + `"}`))
	})

	// Test with explicit Cookie
	cmdStr := "read " + ts.URL() + "/test include='cookie: session=explicit-cookie'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stdout and stderr
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	stdoutR, stdoutW, _ := os.Pipe()
	stderrR, stderrW, _ := os.Pipe()
	os.Stdout = stdoutW
	os.Stderr = stderrW

	var stdoutBuf, stderrBuf bytes.Buffer
	stdoutDone := make(chan bool)
	stderrDone := make(chan bool)
	go func() {
		stdoutBuf.ReadFrom(stdoutR)
		stdoutDone <- true
	}()
	go func() {
		stderrBuf.ReadFrom(stderrR)
		stderrDone <- true
	}()

	err = executor.Execute(plan)
	stdoutW.Close()
	stderrW.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	<-stdoutDone
	<-stderrDone

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify explicit cookie was used
	output := stdoutBuf.String()
	if !strings.Contains(output, "explicit-cookie") {
		t.Errorf("Expected explicit cookie, output: %s", output)
	}
	if strings.Contains(output, "stored-session") {
		t.Errorf("Stored session cookie should not be used when explicit cookie is set, output: %s", output)
	}

	// Verify stderr does NOT show "Using session for"
	stderr := stderrBuf.String()
	if strings.Contains(stderr, "Using session for") {
		t.Errorf("Session should not be auto-applied when explicit Cookie is set, stderr: %s", stderr)
	}
}

// TestSessionNotUsedMessage tests that stderr prints a message when session exists but wasn't used.
// Note: This test may need adjustment based on actual implementation behavior.
func TestSessionNotUsedMessage(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	host, _ := session.ExtractHost(ts.URL())

	// Create a session manually
	testSession := &session.Session{
		Host:          host,
		Cookies:       map[string]string{"session": "stored-session"},
		Authorization: "Bearer stored-token",
	}
	if err := session.SaveSession(testSession); err != nil {
		t.Fatalf("SaveSession() error = %v", err)
	}
	defer session.DeleteSession(host)

	// Request with explicit Authorization (suppresses session)
	cmdStr := "read " + ts.URL() + "/json include='header: Authorization: Bearer explicit'"
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	// Capture stderr
	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	var stderrBuf bytes.Buffer
	done := make(chan bool)
	go func() {
		stderrBuf.ReadFrom(r)
		done <- true
	}()

	err = executor.Execute(plan)
	w.Close()
	os.Stderr = oldStderr
	<-done

	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// The current implementation doesn't print a message when session exists but wasn't used
	// This test documents the expected behavior - if we want to add this feature, we'd need
	// to modify the executor to check if a session exists but wasn't applied
	stderr := stderrBuf.String()
	// For now, just verify the request succeeded
	_ = stderr
}


----
tests/shell_quoting_test.go
package tests

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

// TestShellQuotingBash tests bash quoting behavior.
func TestShellQuotingBash(t *testing.T) {
	if _, err := exec.LookPath("bash"); err != nil {
		t.Skip("bash not available")
		return
	}

	// Test command with include clause containing commas and semicolons
	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	// Create a test script that prints argv
	script := `#!/bin/bash
exec "$@" --argv-test
`
	tmpScript := filepath.Join(t.TempDir(), "test.sh")
	if err := os.WriteFile(tmpScript, []byte(script), 0755); err != nil {
		t.Fatalf("Failed to write test script: %v", err)
	}

	// Run through bash and capture output
	cmd := exec.Command("bash", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	// Load golden file
	goldenPath := filepath.Join("fixtures", "shell_quoting_bash.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Compare
	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Bash quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingZsh tests zsh quoting behavior.
func TestShellQuotingZsh(t *testing.T) {
	if _, err := exec.LookPath("zsh"); err != nil {
		t.Skip("zsh not available")
		return
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	cmd := exec.Command("zsh", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_zsh.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Zsh quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingFish tests fish shell quoting behavior.
func TestShellQuotingFish(t *testing.T) {
	if _, err := exec.LookPath("fish"); err != nil {
		t.Skip("fish not available")
		return
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	cmd := exec.Command("fish", "-c", testCmd+" --argv-test")
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_fish.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("Fish quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// TestShellQuotingPowerShell tests PowerShell quoting behavior.
func TestShellQuotingPowerShell(t *testing.T) {
	if _, err := exec.LookPath("pwsh"); err != nil {
		if _, err := exec.LookPath("powershell"); err != nil {
			t.Skip("PowerShell not available")
			return
		}
	}

	testCmd := `req read https://api.example.com/search include='header: Accept: application/json, application/problem+json; param: q=test;value; cookie: session=abc' as=json`

	var cmd *exec.Cmd
	if _, err := exec.LookPath("pwsh"); err == nil {
		cmd = exec.Command("pwsh", "-Command", testCmd+" --argv-test")
	} else {
		cmd = exec.Command("powershell", "-Command", testCmd+" --argv-test")
	}
	output, _ := cmd.CombinedOutput()

	goldenPath := filepath.Join("fixtures", "shell_quoting_powershell.golden")
	expected, err := os.ReadFile(goldenPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.WriteFile(goldenPath, output, 0644)
			t.Logf("Created golden file: %s", goldenPath)
			return
		}
		t.Fatalf("Failed to read golden file: %v", err)
	}

	actualNorm := strings.ReplaceAll(string(output), "\r\n", "\n")
	expectedNorm := strings.ReplaceAll(string(expected), "\r\n", "\n")

	if actualNorm != expectedNorm {
		t.Errorf("PowerShell quoting mismatch:\nExpected:\n%s\nGot:\n%s", expectedNorm, actualNorm)
	}
}

// Note: These tests require the binary to support --argv-test flag that prints argv.
// For now, they will skip if shells are not available, which is acceptable.
// The golden files can be created manually by running the commands and capturing output.


----
tests/testserver.go
// Package tests provides a local HTTP test server for integration tests.
package tests

import (
	"compress/gzip"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
)

// TestServer provides a test HTTP server with various endpoints.
type TestServer struct {
	server *httptest.Server
	mux    *http.ServeMux
}

// NewTestServer creates a new test server.
func NewTestServer() *TestServer {
	mux := http.NewServeMux()
	ts := &TestServer{
		mux: mux,
	}

	// Echo endpoint - returns request details
	mux.HandleFunc("/echo", ts.handleEcho)

	// Headers endpoint - returns request headers
	mux.HandleFunc("/headers", ts.handleHeaders)

	// Cookies endpoint - sets and returns cookies
	mux.HandleFunc("/cookies", ts.handleCookies)

	// Query endpoint - returns query parameters
	mux.HandleFunc("/query", ts.handleQuery)

	// Gzip endpoint - returns gzipped content
	mux.HandleFunc("/gzip", ts.handleGzip)

	// Redirect endpoints
	mux.HandleFunc("/redirect/301", ts.handleRedirect(301))
	mux.HandleFunc("/redirect/302", ts.handleRedirect(302))
	mux.HandleFunc("/redirect/303", ts.handleRedirect(303))
	mux.HandleFunc("/redirect/307", ts.handleRedirect(307))
	mux.HandleFunc("/redirect/308", ts.handleRedirect(308))
	mux.HandleFunc("/final", ts.handleFinal)

	// Multipart endpoint - echoes multipart form data
	mux.HandleFunc("/multipart", ts.handleMultipart)

	// JSON endpoint - returns JSON
	mux.HandleFunc("/json", ts.handleJSON)

	// Status endpoint - returns specific status code
	mux.HandleFunc("/status/", ts.handleStatus)

	ts.server = httptest.NewServer(mux)
	return ts
}

// URL returns the base URL of the test server.
func (ts *TestServer) URL() string {
	return ts.server.URL
}

// Close shuts down the test server.
func (ts *TestServer) Close() {
	ts.server.Close()
}

// handleEcho returns request details as JSON.
func (ts *TestServer) handleEcho(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{
  "method": "%s",
  "url": "%s",
  "headers": %s,
  "body": "%s"
}`, r.Method, r.URL.String(), ts.headersJSON(r), ts.bodyString(r))
}

// handleHeaders returns request headers as JSON.
func (ts *TestServer) handleHeaders(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"headers": %s}`, ts.headersJSON(r))
}

// handleCookies sets and returns cookies.
func (ts *TestServer) handleCookies(w http.ResponseWriter, r *http.Request) {
	// Set a test cookie
	http.SetCookie(w, &http.Cookie{
		Name:  "session",
		Value: "test-session-value",
		Path:  "/",
	})

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"cookies": %s}`, ts.cookiesJSON(r))
}

// handleQuery returns query parameters as JSON.
func (ts *TestServer) handleQuery(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{"query": %s}`, ts.queryJSON(r))
}

// handleGzip returns gzipped content.
func (ts *TestServer) handleGzip(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Encoding", "gzip")
	w.Header().Set("Content-Type", "text/plain")

	gz := gzip.NewWriter(w)
	defer gz.Close()
	fmt.Fprint(gz, "This is gzipped content")
}

// handleFinal is the final destination for redirects.
func (ts *TestServer) handleFinal(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	fmt.Fprint(w, "Final destination")
}

// handleRedirect returns a redirect response.
func (ts *TestServer) handleRedirect(code int) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Location", ts.server.URL+"/final")
		w.WriteHeader(code)
	}
}

// handleMultipart echoes multipart form data.
func (ts *TestServer) handleMultipart(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	err := r.ParseMultipartForm(10 << 20) // 10 MB
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Error parsing multipart: %v", err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, `{
  "form": %s,
  "files": %s
}`, ts.formJSON(r), ts.filesJSON(r))
}

// handleJSON returns JSON data.
func (ts *TestServer) handleJSON(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprint(w, `{"message": "Hello, World!", "items": [1, 2, 3]}`)
}

// handleStatus returns a specific HTTP status code.
func (ts *TestServer) handleStatus(w http.ResponseWriter, r *http.Request) {
	// Extract status code from path
	path := strings.TrimPrefix(r.URL.Path, "/status/")
	var code int
	fmt.Sscanf(path, "%d", &code)
	if code == 0 {
		code = 200
	}
	w.WriteHeader(code)
	fmt.Fprintf(w, "Status %d", code)
}

// Helper functions

func (ts *TestServer) headersJSON(r *http.Request) string {
	headers := make(map[string]string)
	for k, v := range r.Header {
		headers[k] = strings.Join(v, ", ")
	}
	return fmt.Sprintf(`{"%s": "%s"}`, "User-Agent", headers["User-Agent"])
}

func (ts *TestServer) cookiesJSON(r *http.Request) string {
	cookies := make([]string, 0)
	for _, cookie := range r.Cookies() {
		cookies = append(cookies, fmt.Sprintf(`"%s=%s"`, cookie.Name, cookie.Value))
	}
	return "[" + strings.Join(cookies, ", ") + "]"
}

func (ts *TestServer) queryJSON(r *http.Request) string {
	params := make([]string, 0)
	for k, v := range r.URL.Query() {
		for _, val := range v {
			params = append(params, fmt.Sprintf(`"%s": "%s"`, k, val))
		}
	}
	return "{" + strings.Join(params, ", ") + "}"
}

func (ts *TestServer) bodyString(r *http.Request) string {
	body, _ := io.ReadAll(r.Body)
	return strings.ReplaceAll(string(body), "\"", "\\\"")
}

func (ts *TestServer) formJSON(r *http.Request) string {
	form := make([]string, 0)
	for k, v := range r.MultipartForm.Value {
		for _, val := range v {
			form = append(form, fmt.Sprintf(`"%s": "%s"`, k, val))
		}
	}
	return "{" + strings.Join(form, ", ") + "}"
}

func (ts *TestServer) filesJSON(r *http.Request) string {
	files := make([]string, 0)
	for k, v := range r.MultipartForm.File {
		for _, fh := range v {
			files = append(files, fmt.Sprintf(`"%s": "%s"`, k, fh.Filename))
		}
	}
	return "{" + strings.Join(files, ", ") + "}"
}

----
tests/watch_save_test.go
package tests

import (
	"net/http"
	"os"
	"path/filepath"
	"testing"

	"github.com/adammpkins/req/internal/parser"
	"github.com/adammpkins/req/internal/planner"
	"github.com/adammpkins/req/internal/runtime"
)

// TestSaveStreaming tests that save verb uses efficient file writing.
// Note: Current implementation uses io.Copy which is efficient, but reads body into memory first.
// Future optimization: stream directly from resp.Body when no expect checks are present.
func TestSaveStreaming(t *testing.T) {
	ts := NewTestServer()
	defer ts.Close()

	// Create a large response endpoint
	ts.mux.HandleFunc("/large", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/plain")
		// Write 1MB of data
		data := make([]byte, 1024*1024)
		for i := range data {
			data[i] = byte(i % 256)
		}
		w.Write(data)
	})

	tmpFile := filepath.Join(t.TempDir(), "output.bin")
	cmdStr := "save " + ts.URL() + "/large to=" + tmpFile
	cmd, err := parser.Parse(cmdStr)
	if err != nil {
		t.Fatalf("Parse() error = %v", err)
	}

	plan, err := planner.Plan(cmd)
	if err != nil {
		t.Fatalf("Plan() error = %v", err)
	}

	executor, err := runtime.NewExecutor(plan)
	if err != nil {
		t.Fatalf("NewExecutor() error = %v", err)
	}

	err = executor.Execute(plan)
	if err != nil {
		t.Fatalf("Execute() error = %v", err)
	}

	// Verify file was created and has correct size
	info, err := os.Stat(tmpFile)
	if err != nil {
		t.Fatalf("Failed to stat output file: %v", err)
	}

	expectedSize := int64(1024 * 1024)
	if info.Size() != expectedSize {
		t.Errorf("Expected file size %d, got %d", expectedSize, info.Size())
	}
}

// TestWatchTTYDetection tests TTY detection for watch verb.
// Note: Watch verb TTY detection is not yet implemented.
func TestWatchTTYDetection(t *testing.T) {
	t.Skip("Watch verb TTY detection not yet implemented")
}


--END--